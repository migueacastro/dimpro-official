{
  "version": 3,
  "sources": ["../../jsbi/tsc-out/jsbi.mjs", "../../@js-temporal/polyfill/lib/intrinsicclass.ts", "../../@js-temporal/polyfill/lib/slots.ts", "../../@js-temporal/polyfill/lib/regex.ts", "../../@js-temporal/polyfill/lib/ecmascript.ts", "../../@js-temporal/polyfill/lib/intl.ts", "../../@js-temporal/polyfill/lib/instant.ts", "../../@js-temporal/polyfill/lib/calendar.ts", "../../@js-temporal/polyfill/lib/plaindate.ts", "../../@js-temporal/polyfill/lib/plaindatetime.ts", "../../@js-temporal/polyfill/lib/duration.ts", "../../@js-temporal/polyfill/lib/plainmonthday.ts", "../../@js-temporal/polyfill/lib/now.ts", "../../@js-temporal/polyfill/lib/plaintime.ts", "../../@js-temporal/polyfill/lib/timezone.ts", "../../@js-temporal/polyfill/lib/plainyearmonth.ts", "../../@js-temporal/polyfill/lib/zoneddatetime.ts", "../../@js-temporal/polyfill/lib/legacydate.ts", "../../@js-temporal/polyfill/lib/index.ts"],
  "sourcesContent": ["// Copyright 2018 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the “License”);\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// <https://apache.org/licenses/LICENSE-2.0>.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an “AS IS” BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass JSBI extends Array {\n    constructor(length, sign) {\n        super(length);\n        this.sign = sign;\n        // Explicitly set the prototype as per\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, JSBI.prototype);\n        if (length > JSBI.__kMaxLength) {\n            throw new RangeError('Maximum BigInt size exceeded');\n        }\n    }\n    static BigInt(arg) {\n        if (typeof arg === 'number') {\n            if (arg === 0)\n                return JSBI.__zero();\n            if (JSBI.__isOneDigitInt(arg)) {\n                if (arg < 0) {\n                    return JSBI.__oneDigit(-arg, true);\n                }\n                return JSBI.__oneDigit(arg, false);\n            }\n            if (!Number.isFinite(arg) || Math.floor(arg) !== arg) {\n                throw new RangeError('The number ' + arg + ' cannot be converted to ' +\n                    'BigInt because it is not an integer');\n            }\n            return JSBI.__fromDouble(arg);\n        }\n        else if (typeof arg === 'string') {\n            const result = JSBI.__fromString(arg);\n            if (result === null) {\n                throw new SyntaxError('Cannot convert ' + arg + ' to a BigInt');\n            }\n            return result;\n        }\n        else if (typeof arg === 'boolean') {\n            if (arg === true) {\n                return JSBI.__oneDigit(1, false);\n            }\n            return JSBI.__zero();\n        }\n        else if (typeof arg === 'object') {\n            if (arg.constructor === JSBI)\n                return arg;\n            const primitive = JSBI.__toPrimitive(arg);\n            return JSBI.BigInt(primitive);\n        }\n        throw new TypeError('Cannot convert ' + arg + ' to a BigInt');\n    }\n    toDebugString() {\n        const result = ['BigInt['];\n        for (const digit of this) {\n            result.push((digit ? (digit >>> 0).toString(16) : digit) + ', ');\n        }\n        result.push(']');\n        return result.join('');\n    }\n    toString(radix = 10) {\n        if (radix < 2 || radix > 36) {\n            throw new RangeError('toString() radix argument must be between 2 and 36');\n        }\n        if (this.length === 0)\n            return '0';\n        if ((radix & (radix - 1)) === 0) {\n            return JSBI.__toStringBasePowerOfTwo(this, radix);\n        }\n        return JSBI.__toStringGeneric(this, radix, false);\n    }\n    valueOf() {\n        throw new Error('Convert JSBI instances to native numbers using `toNumber`.');\n    }\n    // Equivalent of \"Number(my_bigint)\" in the native implementation.\n    // TODO: add more tests\n    static toNumber(x) {\n        const xLength = x.length;\n        if (xLength === 0)\n            return 0;\n        if (xLength === 1) {\n            const value = x.__unsignedDigit(0);\n            return x.sign ? -value : value;\n        }\n        const xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        if (xBitLength > 1024)\n            return x.sign ? -Infinity : Infinity;\n        let exponent = xBitLength - 1;\n        let currentDigit = xMsd;\n        let digitIndex = xLength - 1;\n        const shift = msdLeadingZeros + 3;\n        let mantissaHigh = (shift === 32) ? 0 : currentDigit << shift;\n        mantissaHigh >>>= 12;\n        const mantissaHighBitsUnset = shift - 12;\n        let mantissaLow = (shift >= 12) ? 0 : (currentDigit << (20 + shift));\n        let mantissaLowBitsUnset = 20 + shift;\n        if (mantissaHighBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            mantissaHigh |= (currentDigit >>> (30 - mantissaHighBitsUnset));\n            mantissaLow = currentDigit << mantissaHighBitsUnset + 2;\n            mantissaLowBitsUnset = mantissaHighBitsUnset + 2;\n        }\n        while (mantissaLowBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            if (mantissaLowBitsUnset >= 30) {\n                mantissaLow |= (currentDigit << (mantissaLowBitsUnset - 30));\n            }\n            else {\n                mantissaLow |= (currentDigit >>> (30 - mantissaLowBitsUnset));\n            }\n            mantissaLowBitsUnset -= 30;\n        }\n        const rounding = JSBI.__decideRounding(x, mantissaLowBitsUnset, digitIndex, currentDigit);\n        if (rounding === 1 || (rounding === 0 && (mantissaLow & 1) === 1)) {\n            mantissaLow = (mantissaLow + 1) >>> 0;\n            if (mantissaLow === 0) {\n                // Incrementing mantissaLow overflowed.\n                mantissaHigh++;\n                if ((mantissaHigh >>> 20) !== 0) {\n                    // Incrementing mantissaHigh overflowed.\n                    mantissaHigh = 0;\n                    exponent++;\n                    if (exponent > 1023) {\n                        // Incrementing the exponent overflowed.\n                        return x.sign ? -Infinity : Infinity;\n                    }\n                }\n            }\n        }\n        const signBit = x.sign ? (1 << 31) : 0;\n        exponent = (exponent + 0x3FF) << 20;\n        JSBI.__kBitConversionInts[1] = signBit | exponent | mantissaHigh;\n        JSBI.__kBitConversionInts[0] = mantissaLow;\n        return JSBI.__kBitConversionDouble[0];\n    }\n    // Operations.\n    static unaryMinus(x) {\n        if (x.length === 0)\n            return x;\n        const result = x.__copy();\n        result.sign = !x.sign;\n        return result;\n    }\n    static bitwiseNot(x) {\n        if (x.sign) {\n            // ~(-x) == ~(~(x-1)) == x-1\n            return JSBI.__absoluteSubOne(x).__trim();\n        }\n        // ~x == -x-1 == -(x+1)\n        return JSBI.__absoluteAddOne(x, true);\n    }\n    static exponentiate(x, y) {\n        if (y.sign) {\n            throw new RangeError('Exponent must be positive');\n        }\n        if (y.length === 0) {\n            return JSBI.__oneDigit(1, false);\n        }\n        if (x.length === 0)\n            return x;\n        if (x.length === 1 && x.__digit(0) === 1) {\n            // (-1) ** even_number == 1.\n            if (x.sign && (y.__digit(0) & 1) === 0) {\n                return JSBI.unaryMinus(x);\n            }\n            // (-1) ** odd_number == -1, 1 ** anything == 1.\n            return x;\n        }\n        // For all bases >= 2, very large exponents would lead to unrepresentable\n        // results.\n        if (y.length > 1)\n            throw new RangeError('BigInt too big');\n        let expValue = y.__unsignedDigit(0);\n        if (expValue === 1)\n            return x;\n        if (expValue >= JSBI.__kMaxLengthBits) {\n            throw new RangeError('BigInt too big');\n        }\n        if (x.length === 1 && x.__digit(0) === 2) {\n            // Fast path for 2^n.\n            const neededDigits = 1 + ((expValue / 30) | 0);\n            const sign = x.sign && ((expValue & 1) !== 0);\n            const result = new JSBI(neededDigits, sign);\n            result.__initializeDigits();\n            // All bits are zero. Now set the n-th bit.\n            const msd = 1 << (expValue % 30);\n            result.__setDigit(neededDigits - 1, msd);\n            return result;\n        }\n        let result = null;\n        let runningSquare = x;\n        // This implicitly sets the result's sign correctly.\n        if ((expValue & 1) !== 0)\n            result = x;\n        expValue >>= 1;\n        for (; expValue !== 0; expValue >>= 1) {\n            runningSquare = JSBI.multiply(runningSquare, runningSquare);\n            if ((expValue & 1) !== 0) {\n                if (result === null) {\n                    result = runningSquare;\n                }\n                else {\n                    result = JSBI.multiply(result, runningSquare);\n                }\n            }\n        }\n        // TODO see if there's a way for tsc to infer this will always happen?\n        return result;\n    }\n    static multiply(x, y) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return y;\n        let resultLength = x.length + y.length;\n        if (x.__clzmsd() + y.__clzmsd() >= 30) {\n            resultLength--;\n        }\n        const result = new JSBI(resultLength, x.sign !== y.sign);\n        result.__initializeDigits();\n        for (let i = 0; i < x.length; i++) {\n            JSBI.__multiplyAccumulate(y, x.__digit(i), result, i);\n        }\n        return result.__trim();\n    }\n    static divide(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return JSBI.__zero();\n        const resultSign = x.sign !== y.sign;\n        const divisor = y.__unsignedDigit(0);\n        let quotient;\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1) {\n                return resultSign === x.sign ? x : JSBI.unaryMinus(x);\n            }\n            quotient = JSBI.__absoluteDivSmall(x, divisor, null);\n        }\n        else {\n            quotient = JSBI.__absoluteDivLarge(x, y, true, false);\n        }\n        quotient.sign = resultSign;\n        return quotient.__trim();\n    }\n    static remainder(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return x;\n        const divisor = y.__unsignedDigit(0);\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1)\n                return JSBI.__zero();\n            const remainderDigit = JSBI.__absoluteModSmall(x, divisor);\n            if (remainderDigit === 0)\n                return JSBI.__zero();\n            return JSBI.__oneDigit(remainderDigit, x.sign);\n        }\n        const remainder = JSBI.__absoluteDivLarge(x, y, false, true);\n        remainder.sign = x.sign;\n        return remainder.__trim();\n    }\n    static add(x, y) {\n        const sign = x.sign;\n        if (sign === y.sign) {\n            // x + y == x + y\n            // -x + -y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x + -y == x - y == -(y - x)\n        // -x + y == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static subtract(x, y) {\n        const sign = x.sign;\n        if (sign !== y.sign) {\n            // x - (-y) == x + y\n            // (-x) - y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x - y == -(y - x)\n        // (-x) - (-y) == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static leftShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__rightShiftByAbsolute(x, y);\n        return JSBI.__leftShiftByAbsolute(x, y);\n    }\n    static signedRightShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__leftShiftByAbsolute(x, y);\n        return JSBI.__rightShiftByAbsolute(x, y);\n    }\n    static unsignedRightShift() {\n        throw new TypeError('BigInts have no unsigned right shift; use >> instead');\n    }\n    static lessThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) < 0;\n    }\n    static lessThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) <= 0;\n    }\n    static greaterThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) > 0;\n    }\n    static greaterThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) >= 0;\n    }\n    static equal(x, y) {\n        if (x.sign !== y.sign)\n            return false;\n        if (x.length !== y.length)\n            return false;\n        for (let i = 0; i < x.length; i++) {\n            if (x.__digit(i) !== y.__digit(i))\n                return false;\n        }\n        return true;\n    }\n    static notEqual(x, y) {\n        return !JSBI.equal(x, y);\n    }\n    static bitwiseAnd(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteAnd(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            const resultLength = Math.max(x.length, y.length) + 1;\n            // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))\n            // == -(((x-1) | (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteOr(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x & (-y) == x & ~(y-1) == x &~ (y-1)\n        return JSBI.__absoluteAndNot(x, JSBI.__absoluteSubOne(y)).__trim();\n    }\n    static bitwiseXor(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteXor(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)\n            const resultLength = Math.max(x.length, y.length);\n            const result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            return JSBI.__absoluteXor(result, y1, result).__trim();\n        }\n        const resultLength = Math.max(x.length, y.length) + 1;\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteXor(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static bitwiseOr(x, y) {\n        const resultLength = Math.max(x.length, y.length);\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteOr(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))\n            // == -(((x-1) & (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteAnd(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteAndNot(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static asIntN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} has less than {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const topDigit = x.__unsignedDigit(neededLength - 1);\n        const compareDigit = 1 << ((n - 1) % 30);\n        if (x.length === neededLength && topDigit < compareDigit)\n            return x;\n        // Otherwise truncate and simulate two's complement.\n        const hasBit = (topDigit & compareDigit) === compareDigit;\n        if (!hasBit)\n            return JSBI.__truncateToNBits(n, x);\n        if (!x.sign)\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, true);\n        if ((topDigit & (compareDigit - 1)) === 0) {\n            for (let i = neededLength - 2; i >= 0; i--) {\n                if (x.__digit(i) !== 0) {\n                    return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n                }\n            }\n            if (x.length === neededLength && topDigit === compareDigit)\n                return x;\n            return JSBI.__truncateToNBits(n, x);\n        }\n        return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n    }\n    static asUintN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} is negative, simulate two's complement representation.\n        if (x.sign) {\n            if (n > JSBI.__kMaxLengthBits) {\n                throw new RangeError('BigInt too big');\n            }\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n        }\n        // If {x} is positive and has up to {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const bitsInTopDigit = n % 30;\n        if (x.length == neededLength) {\n            if (bitsInTopDigit === 0)\n                return x;\n            const topDigit = x.__digit(neededLength - 1);\n            if ((topDigit >>> bitsInTopDigit) === 0)\n                return x;\n        }\n        // Otherwise, truncate.\n        return JSBI.__truncateToNBits(n, x);\n    }\n    // Operators.\n    static ADD(x, y) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string') {\n            if (typeof y !== 'string')\n                y = y.toString();\n            return x + y;\n        }\n        if (typeof y === 'string') {\n            return x.toString() + y;\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x) && JSBI.__isBigInt(y)) {\n            return JSBI.add(x, y);\n        }\n        if (typeof x === 'number' && typeof y === 'number') {\n            return x + y;\n        }\n        throw new TypeError('Cannot mix BigInt and other types, use explicit conversions');\n    }\n    static LT(x, y) {\n        return JSBI.__compare(x, y, 0);\n    }\n    static LE(x, y) {\n        return JSBI.__compare(x, y, 1);\n    }\n    static GT(x, y) {\n        return JSBI.__compare(x, y, 2);\n    }\n    static GE(x, y) {\n        return JSBI.__compare(x, y, 3);\n    }\n    static EQ(x, y) {\n        while (true) {\n            if (JSBI.__isBigInt(x)) {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.equal(x, y);\n                return JSBI.EQ(y, x);\n            }\n            else if (typeof x === 'number') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'string') {\n                if (JSBI.__isBigInt(y)) {\n                    x = JSBI.__fromString(x);\n                    if (x === null)\n                        return false;\n                    return JSBI.equal(x, y);\n                }\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'boolean') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, +x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'symbol') {\n                if (JSBI.__isBigInt(y))\n                    return false;\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'object') {\n                if (typeof y === 'object' && y.constructor !== JSBI)\n                    return x == y;\n                x = JSBI.__toPrimitive(x);\n            }\n            else {\n                return x == y;\n            }\n        }\n    }\n    static NE(x, y) {\n        return !JSBI.EQ(x, y);\n    }\n    // DataView-related functionality.\n    static DataViewGetBigInt64(dataview, byteOffset, littleEndian = false) {\n        return JSBI.asIntN(64, JSBI.DataViewGetBigUint64(dataview, byteOffset, littleEndian));\n    }\n    static DataViewGetBigUint64(dataview, byteOffset, littleEndian = false) {\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        const high = dataview.getUint32(byteOffset + h, littleEndian);\n        const low = dataview.getUint32(byteOffset + l, littleEndian);\n        const result = new JSBI(3, false);\n        result.__setDigit(0, low & 0x3FFFFFFF);\n        result.__setDigit(1, ((high & 0xFFFFFFF) << 2) | (low >>> 30));\n        result.__setDigit(2, high >>> 28);\n        return result.__trim();\n    }\n    static DataViewSetBigInt64(dataview, byteOffset, value, littleEndian = false) {\n        JSBI.DataViewSetBigUint64(dataview, byteOffset, value, littleEndian);\n    }\n    static DataViewSetBigUint64(dataview, byteOffset, value, littleEndian = false) {\n        value = JSBI.asUintN(64, value);\n        let high = 0;\n        let low = 0;\n        if (value.length > 0) {\n            low = value.__digit(0);\n            if (value.length > 1) {\n                const d1 = value.__digit(1);\n                low = low | d1 << 30;\n                high = d1 >>> 2;\n                if (value.length > 2) {\n                    high = high | (value.__digit(2) << 28);\n                }\n            }\n        }\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        dataview.setUint32(byteOffset + h, high, littleEndian);\n        dataview.setUint32(byteOffset + l, low, littleEndian);\n    }\n    // Helpers.\n    static __zero() {\n        return new JSBI(0, false);\n    }\n    static __oneDigit(value, sign) {\n        const result = new JSBI(1, sign);\n        result.__setDigit(0, value);\n        return result;\n    }\n    __copy() {\n        const result = new JSBI(this.length, this.sign);\n        for (let i = 0; i < this.length; i++) {\n            result[i] = this[i];\n        }\n        return result;\n    }\n    __trim() {\n        let newLength = this.length;\n        let last = this[newLength - 1];\n        while (last === 0) {\n            newLength--;\n            last = this[newLength - 1];\n            this.pop();\n        }\n        if (newLength === 0)\n            this.sign = false;\n        return this;\n    }\n    __initializeDigits() {\n        for (let i = 0; i < this.length; i++) {\n            this[i] = 0;\n        }\n    }\n    static __decideRounding(x, mantissaBitsUnset, digitIndex, currentDigit) {\n        if (mantissaBitsUnset > 0)\n            return -1;\n        let topUnconsumedBit;\n        if (mantissaBitsUnset < 0) {\n            topUnconsumedBit = -mantissaBitsUnset - 1;\n        }\n        else {\n            // {currentDigit} fit the mantissa exactly; look at the next digit.\n            if (digitIndex === 0)\n                return -1;\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            topUnconsumedBit = 29;\n        }\n        // If the most significant remaining bit is 0, round down.\n        let mask = 1 << topUnconsumedBit;\n        if ((currentDigit & mask) === 0)\n            return -1;\n        // If any other remaining bit is set, round up.\n        mask -= 1;\n        if ((currentDigit & mask) !== 0)\n            return 1;\n        while (digitIndex > 0) {\n            digitIndex--;\n            if (x.__digit(digitIndex) !== 0)\n                return 1;\n        }\n        return 0;\n    }\n    static __fromDouble(value) {\n        const sign = value < 0;\n        JSBI.__kBitConversionDouble[0] = value;\n        const rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;\n        const exponent = rawExponent - 0x3FF;\n        const digits = ((exponent / 30) | 0) + 1;\n        const result = new JSBI(digits, sign);\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[0];\n        const kMantissaHighTopBit = 20;\n        // 0-indexed position of most significant bit in most significant digit.\n        const msdTopBit = exponent % 30;\n        // Number of unused bits in the mantissa. We'll keep them shifted to the\n        // left (i.e. most significant part).\n        let remainingMantissaBits = 0;\n        // Next digit under construction.\n        let digit;\n        // First, build the MSD by shifting the mantissa appropriately.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            digit = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            digit = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            digit = (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        result.__setDigit(digits - 1, digit);\n        // Then fill in the rest of the digits.\n        for (let digitIndex = digits - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                digit = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                digit = 0;\n            }\n            result.__setDigit(digitIndex, digit);\n        }\n        return result.__trim();\n    }\n    static __isWhitespace(c) {\n        if (c <= 0x0D && c >= 0x09)\n            return true;\n        if (c <= 0x9F)\n            return c === 0x20;\n        if (c <= 0x01FFFF) {\n            return c === 0xA0 || c === 0x1680;\n        }\n        if (c <= 0x02FFFF) {\n            c &= 0x01FFFF;\n            return c <= 0x0A || c === 0x28 || c === 0x29 || c === 0x2F ||\n                c === 0x5F || c === 0x1000;\n        }\n        return c === 0xFEFF;\n    }\n    static __fromString(string, radix = 0) {\n        let sign = 0;\n        let leadingZero = false;\n        const length = string.length;\n        let cursor = 0;\n        if (cursor === length)\n            return JSBI.__zero();\n        let current = string.charCodeAt(cursor);\n        // Skip whitespace.\n        while (JSBI.__isWhitespace(current)) {\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Detect radix.\n        if (current === 0x2B) { // '+'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = 1;\n        }\n        else if (current === 0x2D) { // '-'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = -1;\n        }\n        if (radix === 0) {\n            radix = 10;\n            if (current === 0x30) { // '0'\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    radix = 16;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x4F || current === 0x6F) { // 'O' or 'o'\n                    radix = 8;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x42 || current === 0x62) { // 'B' or 'b'\n                    radix = 2;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        else if (radix === 16) {\n            if (current === 0x30) { // '0'\n                // Allow \"0x\" prefix.\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        if (sign !== 0 && radix !== 10)\n            return null;\n        // Skip leading zeros.\n        while (current === 0x30) {\n            leadingZero = true;\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Allocate result.\n        const chars = length - cursor;\n        let bitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        let roundup = JSBI.__kBitsPerCharTableMultiplier - 1;\n        if (chars > (1 << 30) / bitsPerChar)\n            return null;\n        const bitsMin = (bitsPerChar * chars + roundup) >>> JSBI.__kBitsPerCharTableShift;\n        const resultLength = ((bitsMin + 29) / 30) | 0;\n        const result = new JSBI(resultLength, false);\n        // Parse.\n        const limDigit = radix < 10 ? radix : 10;\n        const limAlpha = radix > 10 ? radix - 10 : 0;\n        if ((radix & (radix - 1)) === 0) {\n            // Power-of-two radix.\n            bitsPerChar >>= JSBI.__kBitsPerCharTableShift;\n            const parts = [];\n            const partsBits = [];\n            let done = false;\n            do {\n                let part = 0;\n                let bits = 0;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    bits += bitsPerChar;\n                    part = (part << bitsPerChar) | d;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                    if (bits + bitsPerChar > 30)\n                        break;\n                }\n                parts.push(part);\n                partsBits.push(bits);\n            } while (!done);\n            JSBI.__fillFromParts(result, parts, partsBits);\n        }\n        else {\n            result.__initializeDigits();\n            let done = false;\n            let charsSoFar = 0;\n            do {\n                let part = 0;\n                let multiplier = 1;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    const m = multiplier * radix;\n                    if (m > 0x3FFFFFFF)\n                        break;\n                    multiplier = m;\n                    part = part * radix + d;\n                    charsSoFar++;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                }\n                roundup = JSBI.__kBitsPerCharTableMultiplier * 30 - 1;\n                const digitsSoFar = (((bitsPerChar * charsSoFar + roundup) >>>\n                    JSBI.__kBitsPerCharTableShift) / 30) | 0;\n                result.__inplaceMultiplyAdd(multiplier, part, digitsSoFar);\n            } while (!done);\n        }\n        if (cursor !== length) {\n            if (!JSBI.__isWhitespace(current))\n                return null;\n            for (cursor++; cursor < length; cursor++) {\n                current = string.charCodeAt(cursor);\n                if (!JSBI.__isWhitespace(current))\n                    return null;\n            }\n        }\n        // Get result.\n        result.sign = (sign === -1);\n        return result.__trim();\n    }\n    static __fillFromParts(result, parts, partsBits) {\n        let digitIndex = 0;\n        let digit = 0;\n        let bitsInDigit = 0;\n        for (let i = parts.length - 1; i >= 0; i--) {\n            const part = parts[i];\n            const partBits = partsBits[i];\n            digit |= (part << bitsInDigit);\n            bitsInDigit += partBits;\n            if (bitsInDigit === 30) {\n                result.__setDigit(digitIndex++, digit);\n                bitsInDigit = 0;\n                digit = 0;\n            }\n            else if (bitsInDigit > 30) {\n                result.__setDigit(digitIndex++, digit & 0x3FFFFFFF);\n                bitsInDigit -= 30;\n                digit = part >>> (partBits - bitsInDigit);\n            }\n        }\n        if (digit !== 0) {\n            if (digitIndex >= result.length)\n                throw new Error('implementation bug');\n            result.__setDigit(digitIndex++, digit);\n        }\n        for (; digitIndex < result.length; digitIndex++) {\n            result.__setDigit(digitIndex, 0);\n        }\n    }\n    static __toStringBasePowerOfTwo(x, radix) {\n        const length = x.length;\n        let bits = radix - 1;\n        bits = ((bits >>> 1) & 0x55) + (bits & 0x55);\n        bits = ((bits >>> 2) & 0x33) + (bits & 0x33);\n        bits = ((bits >>> 4) & 0x0F) + (bits & 0x0F);\n        const bitsPerChar = bits;\n        const charMask = radix - 1;\n        const msd = x.__digit(length - 1);\n        const msdLeadingZeros = JSBI.__clz30(msd);\n        const bitLength = length * 30 - msdLeadingZeros;\n        let charsRequired = ((bitLength + bitsPerChar - 1) / bitsPerChar) | 0;\n        if (x.sign)\n            charsRequired++;\n        if (charsRequired > (1 << 28))\n            throw new Error('string too long');\n        const result = new Array(charsRequired);\n        let pos = charsRequired - 1;\n        let digit = 0;\n        let availableBits = 0;\n        for (let i = 0; i < length - 1; i++) {\n            const newDigit = x.__digit(i);\n            const current = (digit | (newDigit << availableBits)) & charMask;\n            result[pos--] = JSBI.__kConversionChars[current];\n            const consumedBits = bitsPerChar - availableBits;\n            digit = newDigit >>> consumedBits;\n            availableBits = 30 - consumedBits;\n            while (availableBits >= bitsPerChar) {\n                result[pos--] = JSBI.__kConversionChars[digit & charMask];\n                digit >>>= bitsPerChar;\n                availableBits -= bitsPerChar;\n            }\n        }\n        const current = (digit | (msd << availableBits)) & charMask;\n        result[pos--] = JSBI.__kConversionChars[current];\n        digit = msd >>> (bitsPerChar - availableBits);\n        while (digit !== 0) {\n            result[pos--] = JSBI.__kConversionChars[digit & charMask];\n            digit >>>= bitsPerChar;\n        }\n        if (x.sign)\n            result[pos--] = '-';\n        if (pos !== -1)\n            throw new Error('implementation bug');\n        return result.join('');\n    }\n    static __toStringGeneric(x, radix, isRecursiveCall) {\n        const length = x.length;\n        if (length === 0)\n            return '';\n        if (length === 1) {\n            let result = x.__unsignedDigit(0).toString(radix);\n            if (isRecursiveCall === false && x.sign) {\n                result = '-' + result;\n            }\n            return result;\n        }\n        const bitLength = length * 30 - JSBI.__clz30(x.__digit(length - 1));\n        const maxBitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        const minBitsPerChar = maxBitsPerChar - 1;\n        let charsRequired = bitLength * JSBI.__kBitsPerCharTableMultiplier;\n        charsRequired += minBitsPerChar - 1;\n        charsRequired = (charsRequired / minBitsPerChar) | 0;\n        const secondHalfChars = (charsRequired + 1) >> 1;\n        // Divide-and-conquer: split by a power of {radix} that's approximately\n        // the square root of {x}, then recurse.\n        const conqueror = JSBI.exponentiate(JSBI.__oneDigit(radix, false), JSBI.__oneDigit(secondHalfChars, false));\n        let quotient;\n        let secondHalf;\n        const divisor = conqueror.__unsignedDigit(0);\n        if (conqueror.length === 1 && divisor <= 0x7FFF) {\n            quotient = new JSBI(x.length, false);\n            quotient.__initializeDigits();\n            let remainder = 0;\n            for (let i = x.length * 2 - 1; i >= 0; i--) {\n                const input = (remainder << 15) | x.__halfDigit(i);\n                quotient.__setHalfDigit(i, (input / divisor) | 0);\n                remainder = (input % divisor) | 0;\n            }\n            secondHalf = remainder.toString(radix);\n        }\n        else {\n            const divisionResult = JSBI.__absoluteDivLarge(x, conqueror, true, true);\n            quotient = divisionResult.quotient;\n            const remainder = divisionResult.remainder.__trim();\n            secondHalf = JSBI.__toStringGeneric(remainder, radix, true);\n        }\n        quotient.__trim();\n        let firstHalf = JSBI.__toStringGeneric(quotient, radix, true);\n        while (secondHalf.length < secondHalfChars) {\n            secondHalf = '0' + secondHalf;\n        }\n        if (isRecursiveCall === false && x.sign) {\n            firstHalf = '-' + firstHalf;\n        }\n        return firstHalf + secondHalf;\n    }\n    static __unequalSign(leftNegative) {\n        return leftNegative ? -1 : 1;\n    }\n    static __absoluteGreater(bothNegative) {\n        return bothNegative ? -1 : 1;\n    }\n    static __absoluteLess(bothNegative) {\n        return bothNegative ? 1 : -1;\n    }\n    static __compareToBigInt(x, y) {\n        const xSign = x.sign;\n        if (xSign !== y.sign)\n            return JSBI.__unequalSign(xSign);\n        const result = JSBI.__absoluteCompare(x, y);\n        if (result > 0)\n            return JSBI.__absoluteGreater(xSign);\n        if (result < 0)\n            return JSBI.__absoluteLess(xSign);\n        return 0;\n    }\n    static __compareToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            const xSign = x.sign;\n            const ySign = (y < 0);\n            if (xSign !== ySign)\n                return JSBI.__unequalSign(xSign);\n            if (x.length === 0) {\n                if (ySign)\n                    throw new Error('implementation bug');\n                return y === 0 ? 0 : -1;\n            }\n            // Any multi-digit BigInt is bigger than an int32.\n            if (x.length > 1)\n                return JSBI.__absoluteGreater(xSign);\n            const yAbs = Math.abs(y);\n            const xDigit = x.__unsignedDigit(0);\n            if (xDigit > yAbs)\n                return JSBI.__absoluteGreater(xSign);\n            if (xDigit < yAbs)\n                return JSBI.__absoluteLess(xSign);\n            return 0;\n        }\n        return JSBI.__compareToDouble(x, y);\n    }\n    static __compareToDouble(x, y) {\n        if (y !== y)\n            return y; // NaN.\n        if (y === Infinity)\n            return -1;\n        if (y === -Infinity)\n            return 1;\n        const xSign = x.sign;\n        const ySign = (y < 0);\n        if (xSign !== ySign)\n            return JSBI.__unequalSign(xSign);\n        if (y === 0) {\n            throw new Error('implementation bug: should be handled elsewhere');\n        }\n        if (x.length === 0)\n            return -1;\n        JSBI.__kBitConversionDouble[0] = y;\n        const rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;\n        if (rawExponent === 0x7FF) {\n            throw new Error('implementation bug: handled elsewhere');\n        }\n        const exponent = rawExponent - 0x3FF;\n        if (exponent < 0) {\n            // The absolute value of y is less than 1. Only 0n has an absolute\n            // value smaller than that, but we've already covered that case.\n            return JSBI.__absoluteGreater(xSign);\n        }\n        const xLength = x.length;\n        let xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        const yBitLength = exponent + 1;\n        if (xBitLength < yBitLength)\n            return JSBI.__absoluteLess(xSign);\n        if (xBitLength > yBitLength)\n            return JSBI.__absoluteGreater(xSign);\n        // Same sign, same bit length. Shift mantissa to align with x and compare\n        // bit for bit.\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[0];\n        const kMantissaHighTopBit = 20;\n        const msdTopBit = 29 - msdLeadingZeros;\n        if (msdTopBit !== (((xBitLength - 1) % 30) | 0)) {\n            throw new Error('implementation bug');\n        }\n        let compareMantissa; // Shifted chunk of mantissa.\n        let remainingMantissaBits = 0;\n        // First, compare most significant digit against beginning of mantissa.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            compareMantissa = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            compareMantissa = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            compareMantissa =\n                (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        xMsd = xMsd >>> 0;\n        compareMantissa = compareMantissa >>> 0;\n        if (xMsd > compareMantissa)\n            return JSBI.__absoluteGreater(xSign);\n        if (xMsd < compareMantissa)\n            return JSBI.__absoluteLess(xSign);\n        // Then, compare additional digits against remaining mantissa bits.\n        for (let digitIndex = xLength - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                compareMantissa = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                compareMantissa = 0;\n            }\n            const digit = x.__unsignedDigit(digitIndex);\n            if (digit > compareMantissa)\n                return JSBI.__absoluteGreater(xSign);\n            if (digit < compareMantissa)\n                return JSBI.__absoluteLess(xSign);\n        }\n        // Integer parts are equal; check whether {y} has a fractional part.\n        if (mantissaHigh !== 0 || mantissaLow !== 0) {\n            if (remainingMantissaBits === 0)\n                throw new Error('implementation bug');\n            return JSBI.__absoluteLess(xSign);\n        }\n        return 0;\n    }\n    static __equalToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            if (y === 0)\n                return x.length === 0;\n            // Any multi-digit BigInt is bigger than an int32.\n            return (x.length === 1) && (x.sign === (y < 0)) &&\n                (x.__unsignedDigit(0) === Math.abs(y));\n        }\n        return JSBI.__compareToDouble(x, y) === 0;\n    }\n    // Comparison operations, chosen such that \"op ^ 2\" reverses direction:\n    // 0 - lessThan\n    // 1 - lessThanOrEqual\n    // 2 - greaterThan\n    // 3 - greaterThanOrEqual\n    static __comparisonResultToBool(result, op) {\n        switch (op) {\n            case 0: return result < 0;\n            case 1: return result <= 0;\n            case 2: return result > 0;\n            case 3: return result >= 0;\n        }\n    }\n    static __compare(x, y, op) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string' && typeof y === 'string') {\n            switch (op) {\n                case 0: return x < y;\n                case 1: return x <= y;\n                case 2: return x > y;\n                case 3: return x >= y;\n            }\n        }\n        if (JSBI.__isBigInt(x) && typeof y === 'string') {\n            y = JSBI.__fromString(y);\n            if (y === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        if (typeof x === 'string' && JSBI.__isBigInt(y)) {\n            x = JSBI.__fromString(x);\n            if (x === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x)) {\n            if (JSBI.__isBigInt(y)) {\n                return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n            }\n            if (typeof y !== 'number')\n                throw new Error('implementation bug');\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(x, y), op);\n        }\n        if (typeof x !== 'number')\n            throw new Error('implementation bug');\n        if (JSBI.__isBigInt(y)) {\n            // Note that \"op ^ 2\" reverses the op's direction.\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(y, x), (op ^ 2));\n        }\n        if (typeof y !== 'number')\n            throw new Error('implementation bug');\n        switch (op) {\n            case 0: return x < y;\n            case 1: return x <= y;\n            case 2: return x > y;\n            case 3: return x >= y;\n        }\n    }\n    __clzmsd() {\n        return JSBI.__clz30(this.__digit(this.length - 1));\n    }\n    static __absoluteAdd(x, y, resultSign) {\n        if (x.length < y.length)\n            return JSBI.__absoluteAdd(y, x, resultSign);\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        let resultLength = x.length;\n        if (x.__clzmsd() === 0 || (y.length === x.length && y.__clzmsd() === 0)) {\n            resultLength++;\n        }\n        const result = new JSBI(resultLength, resultSign);\n        let carry = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) + y.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (i < result.length) {\n            result.__setDigit(i, carry);\n        }\n        return result.__trim();\n    }\n    static __absoluteSub(x, y, resultSign) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        const result = new JSBI(x.length, resultSign);\n        let borrow = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) - y.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        return result.__trim();\n    }\n    static __absoluteAddOne(x, sign, result = null) {\n        const inputLength = x.length;\n        if (result === null) {\n            result = new JSBI(inputLength, sign);\n        }\n        else {\n            result.sign = sign;\n        }\n        let carry = 1;\n        for (let i = 0; i < inputLength; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (carry !== 0) {\n            result.__setDigitGrow(inputLength, 1);\n        }\n        return result;\n    }\n    static __absoluteSubOne(x, resultLength) {\n        const length = x.length;\n        resultLength = resultLength || length;\n        const result = new JSBI(resultLength, false);\n        let borrow = 1;\n        for (let i = 0; i < length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (borrow !== 0)\n            throw new Error('implementation bug');\n        for (let i = length; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAnd(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = numPairs;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & y.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAndNot(x, y, result = null) {\n        const xLength = x.length;\n        const yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & ~y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteOr(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) | y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteXor(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) ^ y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteCompare(x, y) {\n        const diff = x.length - y.length;\n        if (diff !== 0)\n            return diff;\n        let i = x.length - 1;\n        while (i >= 0 && x.__digit(i) === y.__digit(i))\n            i--;\n        if (i < 0)\n            return 0;\n        return x.__unsignedDigit(i) > y.__unsignedDigit(i) ? 1 : -1;\n    }\n    static __multiplyAccumulate(multiplicand, multiplier, accumulator, accumulatorIndex) {\n        if (multiplier === 0)\n            return;\n        const m2Low = multiplier & 0x7FFF;\n        const m2High = multiplier >>> 15;\n        let carry = 0;\n        let high = 0;\n        for (let i = 0; i < multiplicand.length; i++, accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            const m1 = multiplicand.__digit(i);\n            const m1Low = m1 & 0x7FFF;\n            const m1High = m1 >>> 15;\n            const rLow = JSBI.__imul(m1Low, m2Low);\n            const rMid1 = JSBI.__imul(m1Low, m2High);\n            const rMid2 = JSBI.__imul(m1High, m2Low);\n            const rHigh = JSBI.__imul(m1High, m2High);\n            acc += high + rLow + carry;\n            carry = acc >>> 30;\n            acc &= 0x3FFFFFFF;\n            acc += ((rMid1 & 0x7FFF) << 15) + ((rMid2 & 0x7FFF) << 15);\n            carry += acc >>> 30;\n            high = rHigh + (rMid1 >>> 15) + (rMid2 >>> 15);\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n        for (; carry !== 0 || high !== 0; accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            acc += carry + high;\n            high = 0;\n            carry = acc >>> 30;\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n    }\n    static __internalMultiplyAdd(source, factor, summand, n, result) {\n        let carry = summand;\n        let high = 0;\n        for (let i = 0; i < n; i++) {\n            const digit = source.__digit(i);\n            const rx = JSBI.__imul(digit & 0x7FFF, factor);\n            const ry = JSBI.__imul(digit >>> 15, factor);\n            const r = rx + ((ry & 0x7FFF) << 15) + high + carry;\n            carry = r >>> 30;\n            high = ry >>> 15;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (result.length > n) {\n            result.__setDigit(n++, carry + high);\n            while (n < result.length) {\n                result.__setDigit(n++, 0);\n            }\n        }\n        else {\n            if (carry + high !== 0)\n                throw new Error('implementation bug');\n        }\n    }\n    __inplaceMultiplyAdd(multiplier, summand, length) {\n        if (length > this.length)\n            length = this.length;\n        const mLow = multiplier & 0x7FFF;\n        const mHigh = multiplier >>> 15;\n        let carry = 0;\n        let high = summand;\n        for (let i = 0; i < length; i++) {\n            const d = this.__digit(i);\n            const dLow = d & 0x7FFF;\n            const dHigh = d >>> 15;\n            const pLow = JSBI.__imul(dLow, mLow);\n            const pMid1 = JSBI.__imul(dLow, mHigh);\n            const pMid2 = JSBI.__imul(dHigh, mLow);\n            const pHigh = JSBI.__imul(dHigh, mHigh);\n            let result = high + pLow + carry;\n            carry = result >>> 30;\n            result &= 0x3FFFFFFF;\n            result += ((pMid1 & 0x7FFF) << 15) + ((pMid2 & 0x7FFF) << 15);\n            carry += result >>> 30;\n            high = pHigh + (pMid1 >>> 15) + (pMid2 >>> 15);\n            this.__setDigit(i, result & 0x3FFFFFFF);\n        }\n        if (carry !== 0 || high !== 0) {\n            throw new Error('implementation bug');\n        }\n    }\n    static __absoluteDivSmall(x, divisor, quotient = null) {\n        if (quotient === null)\n            quotient = new JSBI(x.length, false);\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i -= 2) {\n            let input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            const upperHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            input = ((remainder << 15) | x.__halfDigit(i - 1)) >>> 0;\n            const lowerHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            quotient.__setDigit(i >>> 1, (upperHalf << 15) | lowerHalf);\n        }\n        return quotient;\n    }\n    static __absoluteModSmall(x, divisor) {\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i--) {\n            const input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            remainder = (input % divisor) | 0;\n        }\n        return remainder;\n    }\n    static __absoluteDivLarge(dividend, divisor, wantQuotient, wantRemainder) {\n        const n = divisor.__halfDigitLength();\n        const n2 = divisor.length;\n        const m = dividend.__halfDigitLength() - n;\n        let q = null;\n        if (wantQuotient) {\n            q = new JSBI((m + 2) >>> 1, false);\n            q.__initializeDigits();\n        }\n        const qhatv = new JSBI((n + 2) >>> 1, false);\n        qhatv.__initializeDigits();\n        // D1.\n        const shift = JSBI.__clz15(divisor.__halfDigit(n - 1));\n        if (shift > 0) {\n            divisor = JSBI.__specialLeftShift(divisor, shift, 0 /* add no digits*/);\n        }\n        const u = JSBI.__specialLeftShift(dividend, shift, 1 /* add one digit */);\n        // D2.\n        const vn1 = divisor.__halfDigit(n - 1);\n        let halfDigitBuffer = 0;\n        for (let j = m; j >= 0; j--) {\n            // D3.\n            let qhat = 0x7FFF;\n            const ujn = u.__halfDigit(j + n);\n            if (ujn !== vn1) {\n                const input = ((ujn << 15) | u.__halfDigit(j + n - 1)) >>> 0;\n                qhat = (input / vn1) | 0;\n                let rhat = (input % vn1) | 0;\n                const vn2 = divisor.__halfDigit(n - 2);\n                const ujn2 = u.__halfDigit(j + n - 2);\n                while ((JSBI.__imul(qhat, vn2) >>> 0) > (((rhat << 16) | ujn2) >>> 0)) {\n                    qhat--;\n                    rhat += vn1;\n                    if (rhat > 0x7FFF)\n                        break;\n                }\n            }\n            // D4.\n            JSBI.__internalMultiplyAdd(divisor, qhat, 0, n2, qhatv);\n            let c = u.__inplaceSub(qhatv, j, n + 1);\n            if (c !== 0) {\n                c = u.__inplaceAdd(divisor, j, n);\n                u.__setHalfDigit(j + n, (u.__halfDigit(j + n) + c) & 0x7FFF);\n                qhat--;\n            }\n            if (wantQuotient) {\n                if (j & 1) {\n                    halfDigitBuffer = qhat << 15;\n                }\n                else {\n                    // TODO make this statically determinable\n                    q.__setDigit(j >>> 1, halfDigitBuffer | qhat);\n                }\n            }\n        }\n        if (wantRemainder) {\n            u.__inplaceRightShift(shift);\n            if (wantQuotient) {\n                return { quotient: q, remainder: u };\n            }\n            return u;\n        }\n        if (wantQuotient)\n            return q;\n        // TODO find a way to make this statically unreachable?\n        throw new Error('unreachable');\n    }\n    static __clz15(value) {\n        return JSBI.__clz30(value) - 15;\n    }\n    // TODO: work on full digits, like __inplaceSub?\n    __inplaceAdd(summand, startIndex, halfDigits) {\n        let carry = 0;\n        for (let i = 0; i < halfDigits; i++) {\n            const sum = this.__halfDigit(startIndex + i) +\n                summand.__halfDigit(i) +\n                carry;\n            carry = sum >>> 15;\n            this.__setHalfDigit(startIndex + i, sum & 0x7FFF);\n        }\n        return carry;\n    }\n    __inplaceSub(subtrahend, startIndex, halfDigits) {\n        const fullSteps = (halfDigits - 1) >>> 1;\n        let borrow = 0;\n        if (startIndex & 1) {\n            // this:   [..][..][..]\n            // subtr.:   [..][..]\n            startIndex >>= 1;\n            let current = this.__digit(startIndex);\n            let r0 = current & 0x7FFF;\n            let i = 0;\n            for (; i < fullSteps; i++) {\n                const sub = subtrahend.__digit(i);\n                const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - (sub >>> 15) - borrow;\n                borrow = (r0 >>> 15) & 1;\n            }\n            // Unrolling the last iteration gives a 5% performance benefit!\n            const sub = subtrahend.__digit(i);\n            const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n            borrow = (r15 >>> 15) & 1;\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            const subTop = sub >>> 15;\n            if (startIndex + i + 1 >= this.length) {\n                throw new RangeError('out of bounds');\n            }\n            if ((halfDigits & 1) === 0) {\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - subTop - borrow;\n                borrow = (r0 >>> 15) & 1;\n                this.__setDigit(startIndex + subtrahend.length, (current & 0x3FFF8000) | (r0 & 0x7FFF));\n            }\n        }\n        else {\n            startIndex >>= 1;\n            let i = 0;\n            for (; i < subtrahend.length - 1; i++) {\n                const current = this.__digit(startIndex + i);\n                const sub = subtrahend.__digit(i);\n                const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n                borrow = (r0 >>> 15) & 1;\n                const r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            }\n            const current = this.__digit(startIndex + i);\n            const sub = subtrahend.__digit(i);\n            const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n            borrow = (r0 >>> 15) & 1;\n            let r15 = 0;\n            if ((halfDigits & 1) === 0) {\n                r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n            }\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n        }\n        return borrow;\n    }\n    __inplaceRightShift(shift) {\n        if (shift === 0)\n            return;\n        let carry = this.__digit(0) >>> shift;\n        const last = this.length - 1;\n        for (let i = 0; i < last; i++) {\n            const d = this.__digit(i + 1);\n            this.__setDigit(i, ((d << (30 - shift)) & 0x3FFFFFFF) | carry);\n            carry = d >>> shift;\n        }\n        this.__setDigit(last, carry);\n    }\n    static __specialLeftShift(x, shift, addDigit) {\n        const n = x.length;\n        const resultLength = n + addDigit;\n        const result = new JSBI(resultLength, false);\n        if (shift === 0) {\n            for (let i = 0; i < n; i++)\n                result.__setDigit(i, x.__digit(i));\n            if (addDigit > 0)\n                result.__setDigit(n, 0);\n            return result;\n        }\n        let carry = 0;\n        for (let i = 0; i < n; i++) {\n            const d = x.__digit(i);\n            result.__setDigit(i, ((d << shift) & 0x3FFFFFFF) | carry);\n            carry = d >>> (30 - shift);\n        }\n        if (addDigit > 0) {\n            result.__setDigit(n, carry);\n        }\n        return result;\n    }\n    static __leftShiftByAbsolute(x, y) {\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            throw new RangeError('BigInt too big');\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        const length = x.length;\n        const grow = bitsShift !== 0 &&\n            (x.__digit(length - 1) >>> (30 - bitsShift)) !== 0;\n        const resultLength = length + digitShift + (grow ? 1 : 0);\n        const result = new JSBI(resultLength, x.sign);\n        if (bitsShift === 0) {\n            let i = 0;\n            for (; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (; i < resultLength; i++) {\n                result.__setDigit(i, x.__digit(i - digitShift));\n            }\n        }\n        else {\n            let carry = 0;\n            for (let i = 0; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (let i = 0; i < length; i++) {\n                const d = x.__digit(i);\n                result.__setDigit(i + digitShift, ((d << bitsShift) & 0x3FFFFFFF) | carry);\n                carry = d >>> (30 - bitsShift);\n            }\n            if (grow) {\n                result.__setDigit(length + digitShift, carry);\n            }\n            else {\n                if (carry !== 0)\n                    throw new Error('implementation bug');\n            }\n        }\n        return result.__trim();\n    }\n    static __rightShiftByAbsolute(x, y) {\n        const length = x.length;\n        const sign = x.sign;\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        let resultLength = length - digitShift;\n        if (resultLength <= 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        // For negative numbers, round down if any bit was shifted out (so that\n        // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen\n        // and whether itc an cause overflow into a new digit. If we allocate the\n        // result large enough up front, it avoids having to do grow it later.\n        let mustRoundDown = false;\n        if (sign) {\n            const mask = (1 << bitsShift) - 1;\n            if ((x.__digit(digitShift) & mask) !== 0) {\n                mustRoundDown = true;\n            }\n            else {\n                for (let i = 0; i < digitShift; i++) {\n                    if (x.__digit(i) !== 0) {\n                        mustRoundDown = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // If bitsShift is non-zero, it frees up bits, preventing overflow.\n        if (mustRoundDown && bitsShift === 0) {\n            // Overflow cannot happen if the most significant digit has unset bits.\n            const msd = x.__digit(length - 1);\n            const roundingCanOverflow = ~msd === 0;\n            if (roundingCanOverflow)\n                resultLength++;\n        }\n        let result = new JSBI(resultLength, sign);\n        if (bitsShift === 0) {\n            // Zero out any overflow digit (see \"roundingCanOverflow\" above).\n            result.__setDigit(resultLength - 1, 0);\n            for (let i = digitShift; i < length; i++) {\n                result.__setDigit(i - digitShift, x.__digit(i));\n            }\n        }\n        else {\n            let carry = x.__digit(digitShift) >>> bitsShift;\n            const last = length - digitShift - 1;\n            for (let i = 0; i < last; i++) {\n                const d = x.__digit(i + digitShift + 1);\n                result.__setDigit(i, ((d << (30 - bitsShift)) & 0x3FFFFFFF) | carry);\n                carry = d >>> bitsShift;\n            }\n            result.__setDigit(last, carry);\n        }\n        if (mustRoundDown) {\n            // Since the result is negative, rounding down means adding one to its\n            // absolute value. This cannot overflow.\n            result = JSBI.__absoluteAddOne(result, true, result);\n        }\n        return result.__trim();\n    }\n    static __rightShiftByMaximum(sign) {\n        if (sign) {\n            return JSBI.__oneDigit(1, true);\n        }\n        return JSBI.__zero();\n    }\n    static __toShiftAmount(x) {\n        if (x.length > 1)\n            return -1;\n        const value = x.__unsignedDigit(0);\n        if (value > JSBI.__kMaxLengthBits)\n            return -1;\n        return value;\n    }\n    static __toPrimitive(obj, hint = 'default') {\n        if (typeof obj !== 'object')\n            return obj;\n        if (obj.constructor === JSBI)\n            return obj;\n        if (typeof Symbol !== 'undefined' &&\n            typeof Symbol.toPrimitive === 'symbol') {\n            const exoticToPrim = obj[Symbol.toPrimitive];\n            if (exoticToPrim) {\n                const primitive = exoticToPrim(hint);\n                if (typeof primitive !== 'object')\n                    return primitive;\n                throw new TypeError('Cannot convert object to primitive value');\n            }\n        }\n        const valueOf = obj.valueOf;\n        if (valueOf) {\n            const primitive = valueOf.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        const toString = obj.toString;\n        if (toString) {\n            const primitive = toString.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        throw new TypeError('Cannot convert object to primitive value');\n    }\n    static __toNumeric(value) {\n        if (JSBI.__isBigInt(value))\n            return value;\n        return +value;\n    }\n    static __isBigInt(value) {\n        return typeof value === 'object' && value !== null &&\n            value.constructor === JSBI;\n    }\n    static __truncateToNBits(n, x) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, x.sign);\n        const last = neededDigits - 1;\n        for (let i = 0; i < last; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        let msd = x.__digit(last);\n        if ((n % 30) !== 0) {\n            const drop = 32 - (n % 30);\n            msd = (msd << drop) >>> drop;\n        }\n        result.__setDigit(last, msd);\n        return result.__trim();\n    }\n    static __truncateAndSubFromPowerOfTwo(n, x, resultSign) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, resultSign);\n        let i = 0;\n        const last = neededDigits - 1;\n        let borrow = 0;\n        const limit = Math.min(last, x.length);\n        for (; i < limit; i++) {\n            const r = 0 - x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < last; i++) {\n            result.__setDigit(i, (-borrow & 0x3FFFFFFF) | 0);\n        }\n        let msd = last < x.length ? x.__digit(last) : 0;\n        const msdBitsConsumed = n % 30;\n        let resultMsd;\n        if (msdBitsConsumed === 0) {\n            resultMsd = 0 - msd - borrow;\n            resultMsd &= 0x3FFFFFFF;\n        }\n        else {\n            const drop = 32 - msdBitsConsumed;\n            msd = (msd << drop) >>> drop;\n            const minuendMsd = 1 << (32 - drop);\n            resultMsd = minuendMsd - msd - borrow;\n            resultMsd &= (minuendMsd - 1);\n        }\n        result.__setDigit(last, resultMsd);\n        return result.__trim();\n    }\n    // Digit helpers.\n    __digit(i) {\n        return this[i];\n    }\n    __unsignedDigit(i) {\n        return this[i] >>> 0;\n    }\n    __setDigit(i, digit) {\n        this[i] = digit | 0;\n    }\n    __setDigitGrow(i, digit) {\n        this[i] = digit | 0;\n    }\n    __halfDigitLength() {\n        const len = this.length;\n        if (this.__unsignedDigit(len - 1) <= 0x7FFF)\n            return len * 2 - 1;\n        return len * 2;\n    }\n    __halfDigit(i) {\n        return (this[i >>> 1] >>> ((i & 1) * 15)) & 0x7FFF;\n    }\n    __setHalfDigit(i, value) {\n        const digitIndex = i >>> 1;\n        const previous = this.__digit(digitIndex);\n        const updated = (i & 1) ? (previous & 0x7FFF) | (value << 15)\n            : (previous & 0x3FFF8000) | (value & 0x7FFF);\n        this.__setDigit(digitIndex, updated);\n    }\n    static __digitPow(base, exponent) {\n        let result = 1;\n        while (exponent > 0) {\n            if (exponent & 1)\n                result *= base;\n            exponent >>>= 1;\n            base *= base;\n        }\n        return result;\n    }\n    static __isOneDigitInt(x) {\n        return (x & 0x3FFFFFFF) === x;\n    }\n}\nJSBI.__kMaxLength = 1 << 25;\nJSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5;\n// Lookup table for the maximum number of bits required per character of a\n// base-N string representation of a number. To increase accuracy, the array\n// value is the actual value multiplied by 32. To generate this table:\n//\n// for (let i = 0; i <= 36; i++) {\n//   console.log(Math.ceil(Math.log2(i) * 32) + ',');\n// }\nJSBI.__kMaxBitsPerChar = [\n    0, 0, 32, 51, 64, 75, 83, 90, 96,\n    102, 107, 111, 115, 119, 122, 126, 128,\n    131, 134, 136, 139, 141, 143, 145, 147,\n    149, 151, 153, 154, 156, 158, 159, 160,\n    162, 163, 165, 166, // 33..36\n];\nJSBI.__kBitsPerCharTableShift = 5;\nJSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift;\nJSBI.__kConversionChars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');\nJSBI.__kBitConversionBuffer = new ArrayBuffer(8);\nJSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer);\nJSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);\n// For IE11 compatibility.\n// Note that the custom replacements are tailored for JSBI's needs, and as\n// such are not reusable as general-purpose polyfills.\nJSBI.__clz30 = Math.clz32 ? function (x) {\n    return Math.clz32(x) - 2;\n} : function (x) {\n    if (x === 0)\n        return 30;\n    return 29 - (Math.log(x >>> 0) / Math.LN2 | 0) | 0;\n};\nJSBI.__imul = Math.imul || function (a, b) {\n    return (a * b) | 0;\n};\nexport default JSBI;\n//# sourceMappingURL=jsbi.js.map", "import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\n\nimport { DEBUG } from './debug';\n\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\n\ntype TemporalIntrinsics = Omit<typeof Temporal, 'Now' | 'Instant' | 'ZonedDateTime'> & {\n  Instant: OmitConstructor<Temporal.Instant> &\n    (new (epochNanoseconds: JSBI) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\n  ZonedDateTime: OmitConstructor<Temporal.ZonedDateTime> &\n    (new (\n      epochNanoseconds: JSBI,\n      timeZone: string | Temporal.TimeZoneProtocol,\n      calendar?: string | Temporal.CalendarProtocol\n    ) => Temporal.ZonedDateTime) & {\n      prototype: typeof Temporal.ZonedDateTime.prototype;\n      from: typeof Temporal.ZonedDateTime.from;\n      compare: typeof Temporal.ZonedDateTime.compare;\n    };\n};\ntype TemporalIntrinsicRegistrations = {\n  [key in keyof TemporalIntrinsics as `Temporal.${key}`]: TemporalIntrinsics[key];\n};\ntype TemporalIntrinsicPrototypeRegistrations = {\n  [key in keyof TemporalIntrinsics as `Temporal.${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\n};\ntype TemporalIntrinsicRegisteredKeys = {\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\n};\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\n};\n\ntype CalendarPrototypeKeys = keyof Omit<Temporal.Calendar, typeof Symbol.toStringTag>;\ntype TemporalCalendarIntrinsicRegistrations = {\n  [key in CalendarPrototypeKeys as `Temporal.Calendar.prototype.${key}`]: Temporal.Calendar[key];\n} & {\n  'Temporal.Calendar.from': typeof Temporal.Calendar.from;\n};\ntype TemporalCalendarIntrinsicRegisteredKeys = {\n  [key in keyof TemporalCalendarIntrinsicRegistrations as `%${key}%`]: TemporalCalendarIntrinsicRegistrations[key];\n};\n\ntype TimeZonePrototypeKeys = 'getOffsetNanosecondsFor' | 'getPossibleInstantsFor';\ntype TemporalTimeZoneIntrinsicRegistrations = {\n  [key in TimeZonePrototypeKeys as `Temporal.TimeZone.prototype.${key}`]: Temporal.TimeZone[key];\n} & {\n  'Temporal.TimeZone.from': typeof Temporal.TimeZone.from;\n};\ntype TemporalTimeZoneIntrinsicRegisteredKeys = {\n  [key in keyof TemporalTimeZoneIntrinsicRegistrations as `%${key}%`]: TemporalTimeZoneIntrinsicRegistrations[key];\n};\n\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\n  TemporalIntrinsicPrototypeRegisteredKeys &\n  TemporalTimeZoneIntrinsicRegisteredKeys &\n  TemporalCalendarIntrinsicRegisteredKeys;\n\ntype customFormatFunction<T> = (\n  this: T,\n  depth: number,\n  options: { stylize: (value: unknown, type: 'number' | 'special') => string }\n) => string;\nconst customUtilInspectFormatters: Partial<{\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\n    InstanceType<TemporalIntrinsicRegistrations[key]>\n  >;\n}> = {\n  ['Temporal.Duration'](depth, options) {\n    const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n    if (depth < 1) return descr;\n    const entries = [];\n    for (const prop of [\n      'years',\n      'months',\n      'weeks',\n      'days',\n      'hours',\n      'minutes',\n      'seconds',\n      'milliseconds',\n      'microseconds',\n      'nanoseconds'\n    ] as const) {\n      if (this[prop] !== 0) entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n    }\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n  }\n};\n\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\n  return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\n\nexport function MakeIntrinsicClass(\n  Class: TemporalIntrinsicRegistrations[typeof name],\n  name: keyof TemporalIntrinsicRegistrations\n) {\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  if (DEBUG) {\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  for (const prop of Object.getOwnPropertyNames(Class)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class, prop, desc);\n  }\n  for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class.prototype, prop, desc);\n  }\n\n  DefineIntrinsic(name, Class);\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\n\ntype IntrinsicDefinitionKeys =\n  | keyof TemporalIntrinsicRegistrations\n  | keyof TemporalIntrinsicPrototypeRegistrations\n  | keyof TemporalCalendarIntrinsicRegistrations\n  | keyof TemporalTimeZoneIntrinsicRegistrations;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalCalendarIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalCalendarIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalTimeZoneIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalTimeZoneIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\n  INTRINSICS[key] = value;\n}\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): typeof INTRINSICS[KeyT] {\n  return INTRINSICS[intrinsic];\n}\n", "import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { BuiltinCalendarId, AnyTemporalType, CalendarSlot, TimeZoneSlot } from './internaltypes';\n\n// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n\n// TimeZone\nexport const TIMEZONE_ID = 'slot-timezone-identifier';\n\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_YEAR = 'slot-year';\nexport const ISO_MONTH = 'slot-month';\nexport const ISO_DAY = 'slot-day';\nexport const ISO_HOUR = 'slot-hour';\nexport const ISO_MINUTE = 'slot-minute';\nexport const ISO_SECOND = 'slot-second';\nexport const ISO_MILLISECOND = 'slot-millisecond';\nexport const ISO_MICROSECOND = 'slot-microsecond';\nexport const ISO_NANOSECOND = 'slot-nanosecond';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n\n// ZonedDateTime\nexport const INSTANT = 'slot-cached-instant';\nexport const TIME_ZONE = 'slot-time-zone';\n\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n\n// Calendar\nexport const CALENDAR_ID = 'slot-calendar-identifier';\n\ninterface SlotInfo<ValueType, UsedByType extends AnyTemporalType> {\n  value: ValueType;\n  usedBy: UsedByType;\n}\n\ninterface SlotInfoRecord {\n  [k: string]: SlotInfo<unknown, AnyTemporalType>;\n}\n\ninterface Slots extends SlotInfoRecord {\n  // Instant\n  [EPOCHNANOSECONDS]: SlotInfo<JSBI, Temporal.Instant | Temporal.ZonedDateTime>; // number? JSBI?\n\n  // TimeZone\n  [TIMEZONE_ID]: SlotInfo<string, Temporal.TimeZone>;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_YEAR]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MONTH]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_DAY]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_HOUR]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MINUTE]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_SECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MILLISECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_MICROSECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [ISO_NANOSECOND]: SlotInfo<number, TypesWithCalendarUnits>;\n  [CALENDAR]: SlotInfo<CalendarSlot, TypesWithCalendarUnits>;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\n\n  // ZonedDateTime\n  [INSTANT]: SlotInfo<Temporal.Instant, Temporal.ZonedDateTime>;\n  [TIME_ZONE]: SlotInfo<TimeZoneSlot, Temporal.ZonedDateTime>;\n\n  // Duration\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\n\n  // Calendar\n  [CALENDAR_ID]: SlotInfo<BuiltinCalendarId, Temporal.Calendar>;\n}\n\ntype TypesWithCalendarUnits =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime;\n\ninterface SlotsToTypes {\n  // Instant\n  [EPOCHNANOSECONDS]: Temporal.Instant;\n\n  // TimeZone\n  [TIMEZONE_ID]: Temporal.TimeZone;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_YEAR]: TypesWithCalendarUnits;\n  [ISO_MONTH]: TypesWithCalendarUnits;\n  [ISO_DAY]: TypesWithCalendarUnits;\n  [ISO_HOUR]: TypesWithCalendarUnits;\n  [ISO_MINUTE]: TypesWithCalendarUnits;\n  [ISO_SECOND]: TypesWithCalendarUnits;\n  [ISO_MILLISECOND]: TypesWithCalendarUnits;\n  [ISO_MICROSECOND]: TypesWithCalendarUnits;\n  [ISO_NANOSECOND]: TypesWithCalendarUnits;\n  [CALENDAR]: TypesWithCalendarUnits;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: Temporal.PlainDate;\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\n\n  // ZonedDateTime\n  [INSTANT]: Temporal.ZonedDateTime;\n  [TIME_ZONE]: Temporal.ZonedDateTime;\n\n  // Duration\n  [YEARS]: Temporal.Duration;\n  [MONTHS]: Temporal.Duration;\n  [WEEKS]: Temporal.Duration;\n  [DAYS]: Temporal.Duration;\n  [HOURS]: Temporal.Duration;\n  [MINUTES]: Temporal.Duration;\n  [SECONDS]: Temporal.Duration;\n  [MILLISECONDS]: Temporal.Duration;\n  [MICROSECONDS]: Temporal.Duration;\n  [NANOSECONDS]: Temporal.Duration;\n\n  // Calendar\n  [CALENDAR_ID]: Temporal.Calendar;\n}\n\ntype SlotKey = keyof SlotsToTypes;\n\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\n\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\n  return globalSlots.get(container);\n}\n\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\n\n// expose GetSlots to avoid dual package hazards\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\n\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\n\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\n  globalSlots.set(container, Object.create(null));\n}\n\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\n\n// expose CreateSlots to avoid dual package hazards\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\n\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\n\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\n// guard that takes a variable number of parameters?\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey,\n  ID9 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8,\n  id9: ID9\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\n  if (!container || 'object' !== typeof container) return false;\n  const myslots = GetSlots(container as AnyTemporalType);\n  return !!myslots && ids.every((id) => id in myslots);\n}\nexport function GetSlot<KeyT extends keyof Slots>(\n  container: Slots[typeof id]['usedBy'],\n  id: KeyT\n): Slots[KeyT]['value'] {\n  const value = GetSlots(container)?.[id];\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\n  return value;\n}\nexport function SetSlot<KeyT extends SlotKey>(\n  container: Slots[KeyT]['usedBy'],\n  id: KeyT,\n  value: Slots[KeyT]['value']\n): void {\n  const slots = GetSlots(container);\n\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\n\n  const existingSlot = slots[id];\n\n  if (existingSlot) throw new TypeError(`${id} already has set`);\n\n  slots[id] = value;\n}\n", "const tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nexport const timeZoneID = new RegExp(\n  '(?:' +\n    [\n      `(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*`,\n      'Etc/GMT(?:0|[-+]\\\\d{1,2})',\n      'GMT[-+]?0',\n      'EST5EDT',\n      'CST6CDT',\n      'MST7MDT',\n      'PST8PDT',\n      offsetNoCapture.source\n    ].join('|') +\n    ')'\n);\n\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\n);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\n\nexport const zoneddatetime = new RegExp(\n  [\n    `^${datesplit.source}`,\n    `(?:(?:T|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join(''),\n  'i'\n);\n\nexport const time = new RegExp(\n  [\n    `^T?${timesplit.source}`,\n    `(?:${offsetpart.source})?`,\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join(''),\n  'i'\n);\n\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\n// annotations are still allowed, and will throw if the calendar annotation is\n// not ISO.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\n// UTC offsets are not allowed, because they are not allowed with any date-only\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\nexport const yearmonth = new RegExp(\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\nexport const monthday = new RegExp(\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\n\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\n\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n", "const ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nconst ReflectApply = Reflect.apply;\nconst ReflectOwnKeys = Reflect.ownKeys;\n\nimport { DEBUG } from './debug';\nimport JSBI from 'jsbi';\n\nimport type { Temporal } from '..';\nimport type {\n  AnyTemporalLikeType,\n  UnitSmallerThanOrEqualTo,\n  CalendarProtocolParams,\n  TimeZoneProtocolParams,\n  InstantParams,\n  PlainMonthDayParams,\n  ZonedDateTimeParams,\n  CalendarParams,\n  TimeZoneParams,\n  PlainDateParams,\n  PlainTimeParams,\n  DurationParams,\n  PlainDateTimeParams,\n  PlainYearMonthParams,\n  PrimitiveFieldsOf,\n  BuiltinCalendarId,\n  Keys,\n  AnyTemporalKey,\n  CalendarSlot,\n  TimeZoneSlot\n} from './internaltypes';\nimport { GetIntrinsic } from './intrinsicclass';\nimport {\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot,\n  EPOCHNANOSECONDS,\n  TIMEZONE_ID,\n  CALENDAR_ID,\n  INSTANT,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  DATE_BRAND,\n  YEAR_MONTH_BRAND,\n  MONTH_DAY_BRAND,\n  TIME_ZONE,\n  CALENDAR,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS\n} from './slots';\n\nexport const ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst SIXTY = JSBI.BigInt(60);\nconst TWENTY_FOUR = JSBI.BigInt(24);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst NEGATIVE_ONE = JSBI.BigInt(-1);\nconst HOUR_SECONDS = 3600;\nexport const HOUR_NANOS = JSBI.multiply(JSBI.BigInt(HOUR_SECONDS), BILLION);\nconst MINUTE_NANOS = JSBI.multiply(SIXTY, BILLION);\nconst DAY_NANOS = JSBI.multiply(HOUR_NANOS, TWENTY_FOUR);\nconst NS_MIN = JSBI.multiply(JSBI.BigInt(-86400), JSBI.BigInt(1e17));\nconst NS_MAX = JSBI.multiply(JSBI.BigInt(86400), JSBI.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = JSBI.multiply(JSBI.BigInt(-388152), JSBI.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(2 * 7));\n\nconst BUILTIN_CALENDAR_IDS = [\n  'iso8601',\n  'hebrew',\n  'islamic',\n  'islamic-umalqura',\n  'islamic-tbla',\n  'islamic-civil',\n  'islamic-rgsa',\n  'islamicc',\n  'persian',\n  'ethiopic',\n  'ethioaa',\n  'coptic',\n  'chinese',\n  'dangi',\n  'roc',\n  'indian',\n  'buddhist',\n  'japanese',\n  'gregory'\n];\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\n/**\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\n * the type parameter. This should only be used to help TS understand when variables change types,\n * but TS can't or won't infer this automatically. They should be used sparingly, because\n * if used incorrectly can lead to difficult-to-diagnose problems.\n * */\nexport function uncheckedAssertNarrowedType<T = unknown>(\n  arg: unknown,\n  justification: string\n): asserts arg is T extends typeof arg ? T : never {}\n/* eslint-enable */\n\ntype ArrayElement<ArrayType> = ArrayType extends readonly (infer ElementType)[] ? ElementType : never;\ntype ArrayWithNewKeys<T, Keys> = Array<ArrayElement<T> | Keys>;\n\n/**\n * In debug builds, this function verifies that the given argument \"exists\" (is not\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\n * @param arg\n */\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\n  if (DEBUG) {\n    if (arg != null) {\n      throw new Error('Expected arg to be set.');\n    }\n  }\n}\n\nfunction isZero(value: JSBI): boolean {\n  return JSBI.equal(value, ZERO);\n}\n\ntype Stringless<T> = Exclude<T, string>;\n\nfunction GetMethod<T extends { [s in M]?: (...args: any[]) => unknown }, M extends string & keyof T>(\n  obj: T,\n  methodName: M\n): T[M];\nfunction GetMethod<\n  T extends string | { [s in M]?: (...args: any[]) => unknown },\n  M extends string & keyof Stringless<T>\n>(obj: T, methodName: M): Stringless<T>[M] | undefined;\nfunction GetMethod<\n  T extends string | { [s in M]?: undefined | ((...args: any[]) => unknown) },\n  M extends string & keyof T\n>(obj: T, methodName: M): T[M] | undefined {\n  const result = obj[methodName];\n  if (result === undefined) return undefined;\n  if (DEBUG) {\n    if (typeof result !== 'function') throw new TypeError(`'${methodName}' must be a function`);\n  }\n  return result;\n}\n\nexport function Call<T, A extends readonly any[], R>(\n  target: (this: T, ...args: A) => R,\n  thisArgument: T,\n  argumentsList: Readonly<A>\n): R {\n  const args = arguments.length > 2 ? argumentsList : [];\n  if (DEBUG) {\n    if (!Array.isArray(argumentsList)) {\n      throw new TypeError('Assertion failed: optional `argumentsList`, if provided, must be an array');\n    }\n  }\n  return ReflectApply(target, thisArgument, args);\n}\n\n// For unknown values, this narrows the result to a Record. But for union types\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\n// leaving the object type(s) unchanged.\nexport function IsObject<T>(\n  value: T\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\n\nexport function ToNumber(value: unknown): number {\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\n  // we'll leave ToNumber as-is.\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\n  return NumberCtor(value);\n}\n\nfunction ToIntegerOrInfinity(value: unknown) {\n  const number = ToNumber(value);\n  if (NumberIsNaN(number) || number === 0) {\n    return 0;\n  }\n  if (!NumberIsFinite(number)) {\n    return number;\n  }\n  const integer = MathFloor(MathAbs(number));\n  if (integer === 0) {\n    return 0;\n  }\n  return MathSign(number) * integer;\n}\n\nfunction IsIntegralNumber(argument: unknown) {\n  if (typeof argument !== 'number' || NumberIsNaN(argument) || !NumberIsFinite(argument)) {\n    return false;\n  }\n  const absValue = MathAbs(argument);\n  return MathFloor(absValue) === absValue;\n}\n\nexport function ToString(value: unknown): string {\n  if (typeof value === 'symbol') {\n    throw new TypeError('Cannot convert a Symbol value to a String');\n  }\n  return StringCtor(value);\n}\n\nexport function ToIntegerWithTruncation(value: unknown): number {\n  const number = ToNumber(value);\n  if (number === 0) return 0;\n  if (NumberIsNaN(number) || !NumberIsFinite(number)) {\n    throw new RangeError('invalid number value');\n  }\n  const integer = MathTrunc(number);\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return integer;\n}\n\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\n  const integer = ToIntegerWithTruncation(valueParam);\n  if (integer <= 0) {\n    if (property !== undefined) {\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\n    }\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\n  }\n  return integer;\n}\n\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\n  const number = ToNumber(valueParam);\n  if (!NumberIsFinite(number)) throw new RangeError('infinity is out of range');\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return number;\n}\n\nfunction divmod(x: JSBI, y: JSBI): { quotient: JSBI; remainder: JSBI } {\n  const quotient = JSBI.divide(x, y);\n  const remainder = JSBI.remainder(x, y);\n  return { quotient, remainder };\n}\n\nfunction isNegativeJSBI(value: JSBI): boolean {\n  return JSBI.lessThan(value, ZERO);\n}\n\nfunction signJSBI(value: JSBI): 1 | 0 | -1 {\n  if (isZero(value)) return 0;\n  if (isNegativeJSBI(value)) return -1;\n  return 1;\n}\nfunction abs(x: JSBI): JSBI {\n  if (JSBI.lessThan(x, ZERO)) return JSBI.multiply(x, NEGATIVE_ONE);\n  return x;\n}\n\ntype BuiltinCastFunction = (v: unknown) => string | number;\nconst BUILTIN_CASTS = new Map<AnyTemporalKey, BuiltinCastFunction>([\n  ['year', ToIntegerWithTruncation],\n  ['month', ToPositiveIntegerWithTruncation],\n  ['monthCode', ToString],\n  ['day', ToPositiveIntegerWithTruncation],\n  ['hour', ToIntegerWithTruncation],\n  ['minute', ToIntegerWithTruncation],\n  ['second', ToIntegerWithTruncation],\n  ['millisecond', ToIntegerWithTruncation],\n  ['microsecond', ToIntegerWithTruncation],\n  ['nanosecond', ToIntegerWithTruncation],\n  ['years', ToIntegerIfIntegral],\n  ['months', ToIntegerIfIntegral],\n  ['weeks', ToIntegerIfIntegral],\n  ['days', ToIntegerIfIntegral],\n  ['hours', ToIntegerIfIntegral],\n  ['minutes', ToIntegerIfIntegral],\n  ['seconds', ToIntegerIfIntegral],\n  ['milliseconds', ToIntegerIfIntegral],\n  ['microseconds', ToIntegerIfIntegral],\n  ['nanoseconds', ToIntegerIfIntegral],\n  ['era', ToString],\n  ['eraYear', ToIntegerOrInfinity],\n  ['offset', ToString]\n]);\n\nconst BUILTIN_DEFAULTS = new Map([\n  ['hour', 0],\n  ['minute', 0],\n  ['second', 0],\n  ['millisecond', 0],\n  ['microsecond', 0],\n  ['nanosecond', 0]\n]);\n\n// each item is [plural, singular, category]\nconst SINGULAR_PLURAL_UNITS = [\n  ['years', 'year', 'date'],\n  ['months', 'month', 'date'],\n  ['weeks', 'week', 'date'],\n  ['days', 'day', 'date'],\n  ['hours', 'hour', 'time'],\n  ['minutes', 'minute', 'time'],\n  ['seconds', 'second', 'time'],\n  ['milliseconds', 'millisecond', 'time'],\n  ['microseconds', 'microsecond', 'time'],\n  ['nanoseconds', 'nanosecond', 'time']\n] as const;\nconst SINGULAR_FOR = new Map(SINGULAR_PLURAL_UNITS.map((e) => [e[0], e[1]] as const));\nconst PLURAL_FOR = new Map(SINGULAR_PLURAL_UNITS.map(([p, s]) => [s, p]));\nconst UNITS_DESCENDING = SINGULAR_PLURAL_UNITS.map(([, s]) => s);\n\nconst DURATION_FIELDS = Array.from(SINGULAR_FOR.keys()).sort();\n\nimport * as PARSE from './regex';\n\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\n\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\n  let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n  if (instance === undefined) {\n    instance = new IntlDateTimeFormat('en-us', {\n      timeZone: StringCtor(timeZoneIdentifier),\n      hour12: false,\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n  }\n  return instance;\n}\n\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : object {\n  if (typeof value === 'undefined' || value === null) {\n    throw new TypeError(`Expected object not ${value}`);\n  }\n  return Object(value);\n}\n\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\nexport function CopyDataProperties<K extends string | symbol, T extends Record<K, unknown>>(\n  target: T,\n  source: T | undefined,\n  excludedKeys: K[],\n  excludedValues?: unknown[]\n) {\n  if (typeof source === 'undefined' || source === null) return;\n\n  const keys = ReflectOwnKeys(source) as (keyof T)[];\n  for (const nextKey of keys) {\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\n      const propValue = source[nextKey];\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\n\n      target[nextKey] = propValue;\n    }\n  }\n}\n\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\n\nexport function IsTemporalTimeZone(item: unknown): item is Temporal.TimeZone {\n  return HasSlot(item, TIMEZONE_ID);\n}\nexport function IsTemporalCalendar(item: unknown): item is Temporal.Calendar {\n  return HasSlot(item, CALENDAR_ID);\n}\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\n  return HasSlot(item, DATE_BRAND);\n}\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\n  return (\n    HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n    !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY)\n  );\n}\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\n  return HasSlot(\n    item,\n    ISO_YEAR,\n    ISO_MONTH,\n    ISO_DAY,\n    ISO_HOUR,\n    ISO_MINUTE,\n    ISO_SECOND,\n    ISO_MILLISECOND,\n    ISO_MICROSECOND,\n    ISO_NANOSECOND\n  );\n}\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\n  return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\n  return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n    throw new TypeError('with() does not support a calendar or timeZone property');\n  }\n  if (IsTemporalTime(item)) {\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\n  }\n  if ((item as { calendar: unknown }).calendar !== undefined) {\n    throw new TypeError('with() does not support a calendar property');\n  }\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\n    throw new TypeError('with() does not support a timeZone property');\n  }\n}\nfunction ParseTemporalTimeZone(stringIdent: string) {\n  const { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n  if (ianaName) return GetCanonicalTimeZoneIdentifier(ianaName);\n  if (z) return 'UTC';\n  // if !ianaName && !z then offset must be present\n  assertExists(offset);\n  const offsetNs = ParseTimeZoneOffsetString(offset);\n  return FormatTimeZoneOffsetString(offsetNs);\n}\n\nfunction MaybeFormatCalendarAnnotation(\n  calendar: CalendarSlot,\n  showCalendar: Temporal.ShowCalendarOption['calendarName']\n): string {\n  if (showCalendar === 'never') return '';\n  return FormatCalendarAnnotation(ToTemporalCalendarIdentifier(calendar), showCalendar);\n}\n\nfunction FormatCalendarAnnotation(id: string, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\n  if (showCalendar === 'never') return '';\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\n  const flag = showCalendar === 'critical' ? '!' : '';\n  return `[${flag}u-ca=${id}]`;\n}\n\nfunction ParseISODateTime(isoString: string) {\n  // ZDT is the superset of fields for every other Temporal type\n  const match = PARSE.zoneddatetime.exec(isoString);\n  if (!match) throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  let yearString = match[1];\n  if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n  if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  const year = ToIntegerOrInfinity(yearString);\n  const month = ToIntegerOrInfinity(match[2] || match[4]);\n  const day = ToIntegerOrInfinity(match[3] || match[5]);\n  const hour = ToIntegerOrInfinity(match[6]);\n  const hasTime = match[6] !== undefined;\n  const minute = ToIntegerOrInfinity(match[7] || match[10]);\n  let second = ToIntegerOrInfinity(match[8] || match[11]);\n  if (second === 60) second = 59;\n  const fraction = (match[9] || match[12]) + '000000000';\n  const millisecond = ToIntegerOrInfinity(fraction.slice(0, 3));\n  const microsecond = ToIntegerOrInfinity(fraction.slice(3, 6));\n  const nanosecond = ToIntegerOrInfinity(fraction.slice(6, 9));\n  let offset;\n  let z = false;\n  if (match[13]) {\n    offset = undefined;\n    z = true;\n  } else if (match[14] && match[15]) {\n    const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n    const offsetHours = match[15] || '00';\n    const offsetMinutes = match[16] || '00';\n    const offsetSeconds = match[17] || '00';\n    let offsetFraction = match[18] || '0';\n    offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n    if (+offsetFraction) {\n      while (offsetFraction.endsWith('0')) offsetFraction = offsetFraction.slice(0, -1);\n      offset += `:${offsetSeconds}.${offsetFraction}`;\n    } else if (+offsetSeconds) {\n      offset += `:${offsetSeconds}`;\n    }\n    if (offset === '-00:00') offset = '+00:00';\n  }\n  const ianaName = match[19];\n  const annotations = match[20];\n  let calendar;\n  for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n    if (key === 'u-ca') {\n      if (calendar === undefined) calendar = value;\n    } else if (critical === '!') {\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n    }\n  }\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  return {\n    year,\n    month,\n    day,\n    hasTime,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    ianaName,\n    offset,\n    z,\n    calendar\n  };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstantString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.ianaName) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateTimeString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeString(isoString: string) {\n  const match = PARSE.time.exec(isoString);\n  let hour, minute, second, millisecond, microsecond, nanosecond, annotations;\n  if (match) {\n    hour = ToIntegerOrInfinity(match[1]);\n    minute = ToIntegerOrInfinity(match[2] || match[5]);\n    second = ToIntegerOrInfinity(match[3] || match[6]);\n    if (second === 60) second = 59;\n    const fraction = (match[4] || match[7]) + '000000000';\n    millisecond = ToIntegerOrInfinity(fraction.slice(0, 3));\n    microsecond = ToIntegerOrInfinity(fraction.slice(3, 6));\n    nanosecond = ToIntegerOrInfinity(fraction.slice(6, 9));\n    annotations = match[14];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key !== 'u-ca' && critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\n  } else {\n    let z, hasTime;\n    ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, z } = ParseISODateTime(isoString));\n    if (!hasTime) throw new RangeError(`time is missing in string: ${isoString}`);\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\n  }\n  // if it's a date-time string, OK\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n  }\n  try {\n    const { month, day } = ParseTemporalMonthDayString(isoString);\n    RejectISODate(1972, month, day);\n  } catch {\n    try {\n      const { year, month } = ParseTemporalYearMonthString(isoString);\n      RejectISODate(year, month, 1);\n    } catch {\n      return { hour, minute, second, millisecond, microsecond, nanosecond };\n    }\n  }\n  throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalYearMonthString(isoString: string) {\n  const match = PARSE.yearmonth.exec(isoString);\n  let year, month, calendar, referenceISODay;\n  if (match) {\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    year = ToIntegerOrInfinity(yearString);\n    month = ToIntegerOrInfinity(match[2]);\n    const annotations = match[3];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key === 'u-ca') {\n        if (calendar === undefined) calendar = value;\n      } else if (critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\n  }\n  return { year, month, calendar, referenceISODay };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalMonthDayString(isoString: string) {\n  const match = PARSE.monthday.exec(isoString);\n  let month, day, calendar, referenceISOYear;\n  if (match) {\n    month = ToIntegerOrInfinity(match[1]);\n    day = ToIntegerOrInfinity(match[2]);\n    const annotations = match[3];\n    for (const [, critical, key, value] of annotations.matchAll(PARSE.annotation)) {\n      if (key === 'u-ca') {\n        if (calendar === undefined) calendar = value;\n      } else if (critical === '!') {\n        throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n      }\n    }\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\n  }\n  return { month, day, calendar, referenceISOYear };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeZoneString(stringIdent: string): Partial<{\n  ianaName: string | undefined;\n  offset: string | undefined;\n  z: boolean | undefined;\n}> {\n  const bareID = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\n  if (bareID.test(stringIdent)) return { ianaName: stringIdent };\n  try {\n    // Try parsing ISO string instead\n    const result = ParseISODateTime(stringIdent);\n    if (result.z || result.offset || result.ianaName) {\n      return result;\n    }\n  } catch {\n    // fall through\n  }\n  throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDurationString(isoString: string) {\n  const match = PARSE.duration.exec(isoString);\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\n  if (match.slice(2).every((element) => element === undefined)) {\n    throw new RangeError(`invalid duration: ${isoString}`);\n  }\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\n  const fHours = match[7];\n  const minutesStr = match[8];\n  const fMinutes = match[9];\n  const secondsStr = match[10];\n  const fSeconds = match[11];\n  let minutes = 0;\n  let seconds = 0;\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\n  let excessNanoseconds = 0;\n\n  if (fHours !== undefined) {\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\n      throw new RangeError('only the smallest unit can be fractional');\n    }\n    excessNanoseconds = ToIntegerOrInfinity((fHours + '000000000').slice(0, 9)) * 3600 * sign;\n  } else {\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\n    if (fMinutes !== undefined) {\n      if (secondsStr ?? fSeconds ?? false) {\n        throw new RangeError('only the smallest unit can be fractional');\n      }\n      excessNanoseconds = ToIntegerOrInfinity((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\n    } else {\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\n      if (fSeconds !== undefined) {\n        excessNanoseconds = ToIntegerOrInfinity((fSeconds + '000000000').slice(0, 9)) * sign;\n      }\n    }\n  }\n\n  const nanoseconds = excessNanoseconds % 1000;\n  const microseconds = MathTrunc(excessNanoseconds / 1000) % 1000;\n  const milliseconds = MathTrunc(excessNanoseconds / 1e6) % 1000;\n  seconds += MathTrunc(excessNanoseconds / 1e9) % 60;\n  minutes += MathTrunc(excessNanoseconds / 6e10);\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstant(isoString: string) {\n  let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } =\n    ParseTemporalInstantString(isoString);\n\n  if (!z && !offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  // At least one of z or offset is defined, but TS doesn't seem to understand\n  // that we only use offset if z is not defined (and thus offset must be defined).\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-type-assertion\n  const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset!);\n  ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond - offsetNs\n  ));\n\n  const epochNs = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n  return epochNs;\n}\n\nexport function RegulateISODate(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, day);\n      break;\n    case 'constrain':\n      ({ year, month, day } = ConstrainISODate(year, month, day));\n      break;\n  }\n  return { year, month, day };\n}\n\nexport function RegulateTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  switch (overflow) {\n    case 'reject':\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n      break;\n    case 'constrain':\n      ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n      ));\n      break;\n  }\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RegulateISOYearMonth(\n  yearParam: number,\n  monthParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  const referenceISODay = 1;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, referenceISODay);\n      break;\n    case 'constrain':\n      ({ year, month } = ConstrainISODate(year, month));\n      break;\n  }\n  return { year, month };\n}\n\nfunction ToTemporalDurationRecord(item: Temporal.DurationLike | string) {\n  if (!IsObject(item)) {\n    return ParseTemporalDurationString(ToString(item));\n  }\n  if (IsTemporalDuration(item)) {\n    return {\n      years: GetSlot(item, YEARS),\n      months: GetSlot(item, MONTHS),\n      weeks: GetSlot(item, WEEKS),\n      days: GetSlot(item, DAYS),\n      hours: GetSlot(item, HOURS),\n      minutes: GetSlot(item, MINUTES),\n      seconds: GetSlot(item, SECONDS),\n      milliseconds: GetSlot(item, MILLISECONDS),\n      microseconds: GetSlot(item, MICROSECONDS),\n      nanoseconds: GetSlot(item, NANOSECONDS)\n    };\n  }\n  const result = {\n    years: 0,\n    months: 0,\n    weeks: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n    microseconds: 0,\n    nanoseconds: 0\n  };\n  let partial = ToTemporalPartialDurationRecord(item);\n  for (const property of DURATION_FIELDS) {\n    const value = partial[property];\n    if (value !== undefined) {\n      result[property] = value;\n    }\n  }\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = result;\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\n  if (!IsObject(temporalDurationLike)) {\n    throw new TypeError('invalid duration-like');\n  }\n  const result: Record<typeof DURATION_FIELDS[number], number | undefined> = {\n    years: undefined,\n    months: undefined,\n    weeks: undefined,\n    days: undefined,\n    hours: undefined,\n    minutes: undefined,\n    seconds: undefined,\n    milliseconds: undefined,\n    microseconds: undefined,\n    nanoseconds: undefined\n  };\n  let any = false;\n  for (const property of DURATION_FIELDS) {\n    const value = temporalDurationLike[property];\n    if (value !== undefined) {\n      any = true;\n      result[property] = ToIntegerIfIntegral(value);\n    }\n  }\n  if (!any) {\n    throw new TypeError('invalid duration-like');\n  }\n  return result;\n}\n\nfunction ToLimitedTemporalDuration(\n  item: Temporal.DurationLike | string,\n  disallowedProperties: (keyof Temporal.DurationLike)[]\n) {\n  let record = ToTemporalDurationRecord(item);\n  for (const property of disallowedProperties) {\n    if (record[property] !== 0) {\n      throw new RangeError(\n        `Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\n      );\n    }\n  }\n  return record;\n}\n\nexport function ToTemporalOverflow(options: Temporal.AssignmentOptions | undefined) {\n  if (options === undefined) return 'constrain';\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\n\nexport function ToTemporalDisambiguation(options: Temporal.ToInstantOptions | undefined) {\n  if (options === undefined) return 'compatible';\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\n\nexport function ToTemporalRoundingMode(\n  options: { roundingMode?: Temporal.RoundingMode },\n  fallback: Temporal.RoundingMode\n) {\n  return GetOption(\n    options,\n    'roundingMode',\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\n    fallback\n  );\n}\n\nfunction NegateTemporalRoundingMode(roundingMode: Temporal.RoundingMode) {\n  switch (roundingMode) {\n    case 'ceil':\n      return 'floor';\n    case 'floor':\n      return 'ceil';\n    case 'halfCeil':\n      return 'halfFloor';\n    case 'halfFloor':\n      return 'halfCeil';\n    default:\n      return roundingMode;\n  }\n}\n\nexport function ToTemporalOffset(\n  options: Temporal.OffsetDisambiguationOptions | undefined,\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\n) {\n  if (options === undefined) return fallback;\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\n\nexport function ToCalendarNameOption(options: Temporal.ShowCalendarOption) {\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\n}\n\nexport function ToTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\n}\n\nexport function ToShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\n\nexport function ToTemporalRoundingIncrement(options: { roundingIncrement?: number }) {\n  let increment = options.roundingIncrement;\n  if (increment === undefined) return 1;\n  increment = ToNumber(increment);\n  if (!NumberIsFinite(increment)) {\n    throw new RangeError('roundingIncrement must be finite');\n  }\n  const integerIncrement = MathTrunc(increment);\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\n  }\n  return integerIncrement;\n}\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\n  const maximum = inclusive ? dividend : dividend - 1;\n  if (increment > maximum) {\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\n  }\n  if (dividend % increment !== 0) {\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n  }\n}\n\nexport function ToFractionalSecondDigits(\n  normalizedOptions: Temporal.ToStringPrecisionOptions\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\n  if (digitsValue === undefined) return 'auto';\n  if (typeof digitsValue !== 'number') {\n    if (ToString(digitsValue) !== 'auto') {\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n    }\n    return 'auto';\n  }\n  const digitCount = MathFloor(digitsValue);\n  if (!NumberIsFinite(digitCount) || digitCount < 0 || digitCount > 9) {\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n  }\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\n}\n\nexport function ToSecondsStringPrecisionRecord(\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\n): {\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\n  increment: number;\n} {\n  switch (smallestUnit) {\n    case 'minute':\n      return { precision: 'minute', unit: 'minute', increment: 1 };\n    case 'second':\n      return { precision: 0, unit: 'second', increment: 1 };\n    case 'millisecond':\n      return { precision: 3, unit: 'millisecond', increment: 1 };\n    case 'microsecond':\n      return { precision: 6, unit: 'microsecond', increment: 1 };\n    case 'nanosecond':\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\n    default: // fall through if option not given\n  }\n  switch (precision) {\n    case 'auto':\n      return { precision, unit: 'nanosecond', increment: 1 };\n    case 0:\n      return { precision, unit: 'second', increment: 1 };\n    case 1:\n    case 2:\n    case 3:\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n    case 4:\n    case 5:\n    case 6:\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n    case 7:\n    case 8:\n    case 9:\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n    default:\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\n  }\n}\n\nexport const REQUIRED = Symbol('~required~');\n\ninterface TemporalUnitOptionsBag {\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n}\ntype UnitTypeMapping = {\n  date: Temporal.DateUnit;\n  time: Temporal.TimeUnit;\n  datetime: Temporal.DateTimeUnit;\n};\n// This type specifies the allowed defaults for each unit key type.\ntype AllowedGetTemporalUnitDefaultValues = {\n  smallestUnit: undefined;\n  largestUnit: 'auto' | undefined;\n  unit: undefined;\n};\n\nexport function GetTemporalUnit<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\nexport function GetTemporalUnit<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\n// This signature of the function is NOT used in type-checking, so restricting\n// the default value via generic binding like the other overloads isn't\n// necessary.\nexport function GetTemporalUnit<\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(\n  options: TemporalUnitOptionsBag,\n  key: keyof typeof options,\n  unitGroup: T,\n  requiredOrDefault: D,\n  extraValues: ReadonlyArray<E> | never[] = []\n): R {\n  const allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\n  for (const [, singular, category] of SINGULAR_PLURAL_UNITS) {\n    if (unitGroup === 'datetime' || unitGroup === category) {\n      allowedSingular.push(singular);\n    }\n  }\n  allowedSingular.push(...extraValues);\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\n  if (defaultVal === REQUIRED) {\n    defaultVal = undefined;\n  } else if (defaultVal !== undefined) {\n    allowedSingular.push(defaultVal);\n  }\n  const allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [\n    ...allowedSingular\n  ];\n  for (const singular of allowedSingular) {\n    const plural = PLURAL_FOR.get(singular as Parameters<typeof PLURAL_FOR.get>[0]);\n    if (plural !== undefined) allowedValues.push(plural);\n  }\n  let retval = GetOption(options, key, allowedValues, defaultVal);\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\n    throw new RangeError(`${key} is required`);\n  }\n  // Coerce any plural units into their singular form\n  if (SINGULAR_FOR.has(retval as Temporal.PluralUnit<Temporal.DateTimeUnit>)) {\n    // We just has-checked this, but tsc doesn't understand that.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return SINGULAR_FOR.get(retval as Temporal.PluralUnit<Temporal.DateTimeUnit>)! as R;\n  }\n  return retval as R;\n}\n\nexport function ToRelativeTemporalObject(options: {\n  relativeTo?:\n    | Temporal.ZonedDateTime\n    | Temporal.PlainDateTime\n    | Temporal.ZonedDateTimeLike\n    | Temporal.PlainDateTimeLike\n    | string\n    | undefined;\n}): Temporal.ZonedDateTime | Temporal.PlainDate | undefined {\n  const relativeTo = options.relativeTo;\n  if (relativeTo === undefined) return relativeTo;\n\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  let matchMinutes = false;\n  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n  if (IsObject(relativeTo)) {\n    if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo)) return relativeTo;\n    if (IsTemporalDateTime(relativeTo)) return TemporalDateTimeToDate(relativeTo);\n    calendar = GetTemporalCalendarSlotValueWithISODefault(relativeTo);\n    const fieldNames = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    type FieldNamesWithTimeZoneAndOffset = ArrayWithNewKeys<typeof fieldNames, 'timeZone' | 'offset'>;\n    (fieldNames as FieldNamesWithTimeZoneAndOffset).push('timeZone', 'offset');\n    const fields = PrepareTemporalFields(relativeTo, fieldNames, []);\n    const dateOptions = ObjectCreate(null) as Temporal.AssignmentOptions;\n    dateOptions.overflow = 'constrain';\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      dateOptions\n    ));\n    offset = fields.offset;\n    if (offset === undefined) offsetBehaviour = 'wall';\n    timeZone = fields.timeZone;\n    if (timeZone !== undefined) timeZone = ToTemporalTimeZoneSlotValue(timeZone);\n  } else {\n    let ianaName, z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n      ParseISODateTime(ToString(relativeTo)));\n    if (ianaName) {\n      timeZone = ToTemporalTimeZoneSlotValue(ianaName);\n      if (z) {\n        offsetBehaviour = 'exact';\n      } else if (!offset) {\n        offsetBehaviour = 'wall';\n      }\n      matchMinutes = true;\n    } else if (z) {\n      throw new RangeError(\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\n      );\n    }\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n  }\n  if (timeZone === undefined) return CreateTemporalDate(year, month, day, calendar);\n  // If offset is missing here, then offsetBehavior will never be be 'option'.\n  assertExists(offset);\n  const offsetNs = offsetBehaviour === 'option' ? ParseTimeZoneOffsetString(offset) : 0;\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    'compatible',\n    'reject',\n    matchMinutes\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function DefaultTemporalLargestUnit(\n  years: number,\n  months: number,\n  weeks: number,\n  days: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number\n): Temporal.DateTimeUnit {\n  for (const [prop, v] of [\n    ['years', years],\n    ['months', months],\n    ['weeks', weeks],\n    ['days', days],\n    ['hours', hours],\n    ['minutes', minutes],\n    ['seconds', seconds],\n    ['milliseconds', milliseconds],\n    ['microseconds', microseconds],\n    ['nanoseconds', nanoseconds]\n  ] as const) {\n    if (v !== 0) {\n      // All the above keys are definitely in SINGULAR_FOR\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return SINGULAR_FOR.get(prop)!;\n    }\n  }\n  return 'nanosecond';\n}\n\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\n  unit1: T1,\n  unit2: T2\n) {\n  if (UNITS_DESCENDING.indexOf(unit1) > UNITS_DESCENDING.indexOf(unit2)) return unit2;\n  return unit1;\n}\n\ntype FieldCompleteness = 'complete' | 'partial';\ninterface FieldPrepareOptions {\n  emptySourceErrorMessage: string;\n}\n\n// Returns all potential owners from all Temporal Like-types for a given union\n// of keys in K.\n// e.g.\n// Owner<'nanosecond'> => PlainDateTimeLike | ZonedDateTimeLike | PlainDateTimeLike | ZonedDateTimeLike\n// Owner<'nanoseconds'> => Duration (the only type with plural keys)\ntype Owner<K extends AnyTemporalKey> =\n  // Conditional typing maps over all of the types given in AnyTemporalLikeType\n  // union\n  K extends unknown ? OwnerOf<K, AnyTemporalLikeType> : 'ThisShouldNeverHappen';\n\n// Returns T iff T has K as all of the key(s) (even if those keys are optional\n// in T), never otherwise. This is a private type for use only in the Owner type\n// above.\ntype OwnerOf<K extends AnyTemporalKey, T> =\n  // Distribute the union before passing to Required\n  // Without distributing, this is\n  // Required<ZonedDateTimeLike | DurationLike> extends Record\n  // vs (with distribution)\n  // Required<ZonedDateTimeLike> extends Record<....> | Required<DurationLike> extends Record<....>\n  T extends unknown\n    ? // All the keys in the Like-types are optional, so in order for them to\n      // 'extend Record<K,...>', where K indicates the required fields, we pass T\n      // through Required to make all the keys non-optional.\n      // Note this doesn't work the other way around: using Partial<Record<K, ..>>\n      // will always be extended by any object (as all the keys are optional).\n      Required<T> extends Record<K, unknown>\n      ? T\n      : // never is the 'identity' type for unions - nothing will be added or\n        // removed from the union.\n        never\n    : 'ThisShouldNeverHappen';\n\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\n\n// Resolve copies the keys and values of a given object type so that TS will\n// stop using type names in error messages / autocomplete. Generally, those\n// names can be more useful, but sometimes having the primitive object shape is\n// significantly easier to reason about (e.g. deeply-nested types).\n// Resolve is an identity function for function types.\ntype Resolve<T> =\n  // Re-mapping doesn't work very well for functions, so exclude them\n  T extends (...args: never[]) => unknown\n    ? T\n    : // Re-map all the keys in T to the same value. This forces TS into no longer\n      // using type aliases, etc.\n      { [K in keyof T]: T[K] };\n\ntype FieldObjectFromOwners<OwnerT, FieldKeys extends AnyTemporalKey> = Resolve<\n  // The resulting object type contains:\n  // - All keys in FieldKeys, which are required properties and their values\n  //   don't include undefined.\n  // - All the other keys in OwnerT that aren't in FieldKeys, which are optional\n  //   properties and their value types explicitly include undefined.\n  {\n    -readonly [k in FieldKeys]: Exclude<Prop<OwnerT, k>, undefined>;\n  } & {\n    -readonly [k in Exclude<Keys<OwnerT>, FieldKeys>]?: Prop<OwnerT, k> | undefined;\n  }\n>;\n\ntype PrepareTemporalFieldsReturn<\n  FieldKeys extends AnyTemporalKey,\n  RequiredFieldsOpt extends ReadonlyArray<FieldKeys> | FieldCompleteness,\n  OwnerT extends Owner<FieldKeys>\n> = RequiredFieldsOpt extends 'partial' ? Partial<OwnerT> : FieldObjectFromOwners<OwnerT, FieldKeys>;\nexport function PrepareTemporalFields<\n  FieldKeys extends AnyTemporalKey,\n  // Constrains the Required keys to be a subset of the given field keys\n  // This could have been written directly into the parameter type, but that\n  // causes an unintended effect where the required fields are added to the list\n  // of field keys, even if that key isn't present in 'fields'.\n  // RequiredFieldKeys extends FieldKeys,\n  RequiredFields extends ReadonlyArray<FieldKeys> | FieldCompleteness\n>(\n  bag: Partial<Record<FieldKeys, unknown>>,\n  fields: Array<FieldKeys>,\n  requiredFields: RequiredFields,\n  { emptySourceErrorMessage }: FieldPrepareOptions = { emptySourceErrorMessage: 'no supported properties found' }\n): PrepareTemporalFieldsReturn<FieldKeys, RequiredFields, Owner<FieldKeys>> {\n  const result: Partial<Record<AnyTemporalKey, unknown>> = ObjectCreate(null);\n  let any = false;\n  fields.sort();\n  for (const property of fields) {\n    let value = bag[property];\n    if (value !== undefined) {\n      any = true;\n      if (BUILTIN_CASTS.has(property)) {\n        // We just has-checked this map access, so there will definitely be a\n        // value.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        value = BUILTIN_CASTS.get(property)!(value);\n      }\n      result[property] = value;\n    } else if (requiredFields !== 'partial') {\n      // TODO: using .call in this way is not correctly type-checked by tsc.\n      // We might need a type-safe Call wrapper?\n      if (ArrayIncludes.call(requiredFields, property)) {\n        throw new TypeError(`required property '${property}' missing or undefined`);\n      }\n      value = BUILTIN_DEFAULTS.get(property);\n      result[property] = value;\n    }\n  }\n  if (requiredFields === 'partial' && !any) {\n    throw new TypeError(emptySourceErrorMessage);\n  }\n  return result as unknown as PrepareTemporalFieldsReturn<FieldKeys, RequiredFields, Owner<FieldKeys>>;\n}\n\ninterface TimeRecord {\n  hour?: number;\n  minute?: number;\n  second?: number;\n  microsecond?: number;\n  millisecond?: number;\n  nanosecond?: number;\n}\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): Required<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: 'partial'\n): Partial<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\n  completeness: 'complete'\n): Required<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: FieldCompleteness = 'complete'\n): Partial<TimeRecord> {\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\n  const partial = PrepareTemporalFields(bag, fields, 'partial', { emptySourceErrorMessage: 'invalid time-like' });\n  const result: Partial<TimeRecord> = {};\n  for (const field of fields) {\n    const valueDesc = ObjectGetOwnPropertyDescriptor(partial, field);\n    if (valueDesc !== undefined) {\n      result[field] = valueDesc.value;\n    } else if (completeness === 'complete') {\n      result[field] = 0;\n    }\n  }\n  return result;\n}\n\nexport function ToTemporalDate(\n  itemParam: PlainDateParams['from'][0],\n  options?: PlainDateParams['from'][1]\n): Temporal.PlainDate {\n  let item = itemParam;\n  if (IsObject(item)) {\n    if (IsTemporalDate(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      item = GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return CreateTemporalDate(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    const calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    return CalendarDateFromFields(calendar, fields, options);\n  }\n  ToTemporalOverflow(options); // validate and ignore\n  let { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\n  if (!calendar) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n  return CreateTemporalDate(year, month, day, calendar);\n}\n\nexport function InterpretTemporalDateTimeFields(\n  calendar: CalendarSlot,\n  fields: PrimitiveFieldsOf<Temporal.PlainDateTimeLike> & Parameters<typeof CalendarDateFromFields>[1],\n  options?: Temporal.AssignmentOptions\n) {\n  let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n  const overflow = ToTemporalOverflow(options);\n  const date = CalendarDateFromFields(calendar, fields, options);\n  const year = GetSlot(date, ISO_YEAR);\n  const month = GetSlot(date, ISO_MONTH);\n  const day = GetSlot(date, ISO_DAY);\n  ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    overflow\n  ));\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\n  let year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    millisecond: number,\n    microsecond: number,\n    nanosecond: number,\n    calendar;\n  if (IsObject(item)) {\n    if (IsTemporalDateTime(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDate(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n      return CreateTemporalDateTime(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        GetSlot(item, CALENDAR)\n      );\n    }\n\n    calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      options\n    ));\n  } else {\n    ToTemporalOverflow(options); // validate and ignore\n    let z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n      ParseTemporalDateTimeString(ToString(item)));\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\n    RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n  }\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\n  if (IsTemporalDuration(item)) return item;\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(item);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n}\n\nexport function ToTemporalInstant(item: InstantParams['from'][0]) {\n  if (IsTemporalInstant(item)) return item;\n  if (IsTemporalZonedDateTime(item)) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n  }\n  const ns = ParseTemporalInstant(ToString(item));\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  return new TemporalInstant(ns);\n}\n\nexport function ToTemporalMonthDay(\n  itemParam: PlainMonthDayParams['from'][0],\n  options?: PlainMonthDayParams['from'][1]\n) {\n  let item = itemParam;\n  if (IsObject(item)) {\n    if (IsTemporalMonthDay(item)) return item;\n    let calendar: CalendarSlot, calendarAbsent: boolean;\n    if (HasSlot(item, CALENDAR)) {\n      calendar = GetSlot(item, CALENDAR);\n      calendarAbsent = false;\n    } else {\n      let calendarFromItem = item.calendar;\n      calendarAbsent = calendarFromItem === undefined;\n      if (calendarFromItem === undefined) calendarFromItem = 'iso8601';\n      calendar = ToTemporalCalendarSlotValue(calendarFromItem);\n    }\n    // HasSlot above adjusts the type of 'item' to include\n    // TypesWithCalendarUnits, which causes type-inference failures below.\n    // This is probably indicative of problems with HasSlot's typing.\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    // Callers who omit the calendar are not writing calendar-independent\n    // code. In that case, `monthCode`/`year` can be omitted; `month` and\n    // `day` are sufficient. Add a `year` to satisfy calendar validation.\n    if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n      fields.year = 1972;\n    }\n    return CalendarMonthDayFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(ToString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n\n  if (referenceISOYear === undefined) {\n    RejectISODate(1972, month, day);\n    return CreateTemporalMonthDay(month, day, calendar);\n  }\n  const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n  return CalendarMonthDayFromFields(calendar, result);\n}\n\nexport function ToTemporalTime(\n  itemParam: PlainTimeParams['from'][0],\n  overflow: NonNullable<PlainTimeParams['from'][1]>['overflow'] = 'constrain'\n) {\n  let item = itemParam;\n  let hour, minute, second, millisecond, microsecond, nanosecond;\n  if (IsObject(item)) {\n    if (IsTemporalTime(item)) return item;\n    if (IsTemporalZonedDateTime(item)) {\n      item = GetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n      return new TemporalPlainTime(\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND)\n      );\n    }\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n  } else {\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ParseTemporalTimeString(ToString(item)));\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function ToTemporalYearMonth(\n  item: PlainYearMonthParams['from'][0],\n  options?: PlainYearMonthParams['from'][1]\n): Temporal.PlainYearMonth {\n  if (IsObject(item)) {\n    if (IsTemporalYearMonth(item)) return item;\n    const calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year'] as const);\n    const fields = PrepareTemporalFields(item, fieldNames, []);\n    return CalendarYearMonthFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(ToString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  calendar = ASCIILowercase(calendar);\n\n  if (referenceISODay === undefined) {\n    RejectISODate(year, month, 1);\n    return CreateTemporalYearMonth(year, month, calendar);\n  }\n  const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n  return CalendarYearMonthFromFields(calendar, result);\n}\n\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\n\nexport function InterpretISODateTimeOffset(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  offsetBehaviour: OffsetBehaviour,\n  offsetNs: number,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\n  matchMinute: boolean\n) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\n    // the offset), so just convert DateTime to Instant in the given time zone\n    const instant = GetInstantFor(timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n  }\n\n  // The caller wants the offset to always win ('use') OR the caller is OK\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\n  // for this timezone and date/time.\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n    // Calculate the instant for the input's date/time and offset\n    const epochNs = GetUTCEpochNanoseconds(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    );\n    if (epochNs === null) throw new RangeError('ZonedDateTime outside of supported range');\n    return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n  }\n\n  // \"prefer\" or \"reject\"\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n  for (const candidate of possibleInstants) {\n    const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n    const roundedCandidateOffset = JSBI.toNumber(\n      RoundNumberToIncrement(JSBI.BigInt(candidateOffset), MINUTE_NANOS, 'halfExpand')\n    );\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n      return GetSlot(candidate, EPOCHNANOSECONDS);\n    }\n  }\n\n  // the user-provided offset doesn't match any instants for this time\n  // zone and date/time.\n  if (offsetOpt === 'reject') {\n    const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n    const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n    // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n    // toString (which is invoked by Node when using template literals directly).\n    // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n  }\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\n  // so fall back to use the time zone instead.\n  const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n  return GetSlot(instant, EPOCHNANOSECONDS);\n}\n\nexport function ToTemporalZonedDateTime(\n  item: ZonedDateTimeParams['from'][0],\n  options?: ZonedDateTimeParams['from'][1]\n) {\n  let year: number,\n    month: number,\n    day: number,\n    hour: number,\n    minute: number,\n    second: number,\n    millisecond: number,\n    microsecond: number,\n    nanosecond: number,\n    timeZone,\n    offset: string | undefined,\n    calendar: string | Temporal.CalendarProtocol | undefined;\n  let disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>;\n  let offsetOpt: NonNullable<Temporal.OffsetDisambiguationOptions['offset']>;\n  let matchMinute = false;\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  if (IsObject(item)) {\n    if (IsTemporalZonedDateTime(item)) return item;\n    calendar = GetTemporalCalendarSlotValueWithISODefault(item);\n    const fieldNames: (keyof Temporal.ZonedDateTimeLike)[] = CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    fieldNames.push('timeZone', 'offset');\n    const fields = PrepareTemporalFields(item, fieldNames, ['timeZone']);\n    timeZone = ToTemporalTimeZoneSlotValue(fields.timeZone);\n    offset = fields.offset;\n    if (offset === undefined) {\n      offsetBehaviour = 'wall';\n    }\n    disambiguation = ToTemporalDisambiguation(options);\n    offsetOpt = ToTemporalOffset(options, 'reject');\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(\n      calendar,\n      fields,\n      options\n    ));\n  } else {\n    let ianaName, z;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n      ParseTemporalZonedDateTimeString(ToString(item)));\n    timeZone = ToTemporalTimeZoneSlotValue(ianaName);\n    if (z) {\n      offsetBehaviour = 'exact';\n    } else if (!offset) {\n      offsetBehaviour = 'wall';\n    }\n    if (!calendar) calendar = 'iso8601';\n    if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n    calendar = ASCIILowercase(calendar);\n    matchMinute = true; // ISO strings may specify offset with less precision\n    disambiguation = ToTemporalDisambiguation(options);\n    offsetOpt = ToTemporalOffset(options, 'reject');\n    ToTemporalOverflow(options); // validate and ignore\n  }\n  let offsetNs = 0;\n  // The code above guarantees that if offsetBehaviour === 'option', then\n  // `offset` is not undefined.\n  if (offsetBehaviour === 'option') offsetNs = ParseTimeZoneOffsetString(offset as string);\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    disambiguation,\n    offsetOpt,\n    matchMinute\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function CreateTemporalDateSlots(\n  result: Temporal.PlainDate,\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot\n) {\n  RejectISODate(isoYear, isoMonth, isoDay);\n  RejectDateRange(isoYear, isoMonth, isoDay);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, DATE_BRAND, true);\n\n  if (DEBUG) {\n    ObjectDefineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDate(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n  const result = ObjectCreate(TemporalPlainDate.prototype);\n  CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n  return result;\n}\n\nexport function CreateTemporalDateTimeSlots(\n  result: Temporal.PlainDateTime,\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number,\n  calendar: CalendarSlot\n) {\n  RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n  RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_HOUR, h);\n  SetSlot(result, ISO_MINUTE, min);\n  SetSlot(result, ISO_SECOND, s);\n  SetSlot(result, ISO_MILLISECOND, ms);\n  SetSlot(result, ISO_MICROSECOND, µs);\n  SetSlot(result, ISO_NANOSECOND, ns);\n  SetSlot(result, CALENDAR, calendar);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDateTime(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const result = ObjectCreate(TemporalPlainDateTime.prototype);\n  CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar);\n  return result as Temporal.PlainDateTime;\n}\n\nexport function CreateTemporalMonthDaySlots(\n  result: Temporal.PlainMonthDay,\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot,\n  referenceISOYear: number\n) {\n  RejectISODate(referenceISOYear, isoMonth, isoDay);\n  RejectDateRange(referenceISOYear, isoMonth, isoDay);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_YEAR, referenceISOYear);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, MONTH_DAY_BRAND, true);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalMonthDay(\n  isoMonth: number,\n  isoDay: number,\n  calendar: CalendarSlot = 'iso8601',\n  referenceISOYear = 1972\n) {\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n  const result = ObjectCreate(TemporalPlainMonthDay.prototype);\n  CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n  return result;\n}\n\nexport function CreateTemporalYearMonthSlots(\n  result: Temporal.PlainYearMonth,\n  isoYear: number,\n  isoMonth: number,\n  calendar: CalendarSlot,\n  referenceISODay: number\n) {\n  RejectISODate(isoYear, isoMonth, referenceISODay);\n  RejectYearMonthRange(isoYear, isoMonth);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, referenceISODay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, YEAR_MONTH_BRAND, true);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalYearMonth(\n  isoYear: number,\n  isoMonth: number,\n  calendar: CalendarSlot = 'iso8601',\n  referenceISODay = 1\n) {\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n  const result = ObjectCreate(TemporalPlainYearMonth.prototype);\n  CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n  return result;\n}\n\nexport function CreateTemporalZonedDateTimeSlots(\n  result: Temporal.ZonedDateTime,\n  epochNanoseconds: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot\n) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n  SetSlot(result, TIME_ZONE, timeZone);\n  SetSlot(result, CALENDAR, calendar);\n\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n  SetSlot(result, INSTANT, instant);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalZonedDateTime(\n  epochNanoseconds: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot = 'iso8601'\n) {\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n  const result = ObjectCreate(TemporalZonedDateTime.prototype);\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n  return result;\n}\n\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nexport function CalendarFields<K extends AnyTemporalKey>(calendar: CalendarSlot, fieldNamesParam: ReadonlyArray<K>) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.fields%'), calendarObj, [fieldNamesParam]) as K[];\n  }\n  const fields = GetMethod(calendar, 'fields');\n  const fieldNames = Call(fields, calendar, [fieldNamesParam]);\n  const result: K[] = [];\n  for (const name of fieldNames) {\n    if (typeof name !== 'string') throw new TypeError('bad return from calendar.fields()');\n    ArrayPrototypePush.call(result, name);\n  }\n  return result;\n}\n\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\n  calendar: CalendarSlot,\n  fields: Base,\n  additionalFields: ToAdd\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.mergeFields%'), calendarObj, [\n      fields,\n      additionalFields\n    ]) as Base & ToAdd;\n  }\n  const mergeFields = GetMethod(calendar, 'mergeFields');\n  const result = Call(mergeFields, calendar, [fields, additionalFields]);\n  if (!IsObject(result)) throw new TypeError('bad return from calendar.mergeFields()');\n  return result as Base & ToAdd;\n}\n\nexport function CalendarDateAdd(\n  calendar: CalendarSlot,\n  date: CalendarProtocolParams['dateAdd'][0],\n  duration: CalendarProtocolParams['dateAdd'][1],\n  options: CalendarProtocolParams['dateAdd'][2],\n  dateAddParam?: Temporal.CalendarProtocol['dateAdd'] | undefined\n) {\n  let dateAdd = dateAddParam;\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateAdd%'), calendarObj, [date, duration, options]);\n  }\n  if (dateAdd === undefined) {\n    dateAdd = GetMethod(calendar, 'dateAdd');\n  }\n  const result = ReflectApply(dateAdd, calendar, [date, duration, options]);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction CalendarDateUntil(\n  calendar: CalendarSlot,\n  date: CalendarProtocolParams['dateUntil'][0],\n  otherDate: CalendarProtocolParams['dateUntil'][1],\n  options: CalendarProtocolParams['dateUntil'][2],\n  dateUntilParam?: Temporal.CalendarProtocol['dateUntil'] | undefined\n) {\n  let dateUntil = dateUntilParam;\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateUntil%'), calendarObj, [date, otherDate, options]);\n  }\n  if (dateUntil === undefined) {\n    dateUntil = GetMethod(calendar, 'dateUntil');\n  }\n  const result = ReflectApply(dateUntil, calendar, [date, otherDate, options]);\n  if (!IsTemporalDuration(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['year'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.year%'), calendarObj, [dateLike]);\n  }\n  const year = GetMethod(calendar, 'year');\n  let result = Call(year, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar year result must be an integer');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar year result must be an integer');\n  }\n  return result;\n}\n\nexport function CalendarMonth(calendar: CalendarSlot, dateLike: CalendarProtocolParams['month'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.month%'), calendarObj, [dateLike]);\n  }\n  const month = GetMethod(calendar, 'month');\n  let result = Call(month, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar month result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar month result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarMonthCode(calendar: CalendarSlot, dateLike: CalendarProtocolParams['monthCode'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthCode%'), calendarObj, [dateLike]);\n  }\n  const monthCode = GetMethod(calendar, 'monthCode');\n  let result = Call(monthCode, calendar, [dateLike]);\n  if (typeof result !== 'string') {\n    throw new TypeError('calendar monthCode result must be a string');\n  }\n  return result;\n}\n\nexport function CalendarDay(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.day%'), calendarObj, [dateLike]);\n  }\n  const day = GetMethod(calendar, 'day');\n  const result = Call(day, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar day result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar day result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarEra(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.era%'), calendarObj, [dateLike]);\n  }\n  const era = GetMethod(calendar, 'era');\n  let result = Call(era, calendar, [dateLike]);\n  if (result === undefined) {\n    return result;\n  }\n  if (typeof result !== 'string') {\n    throw new TypeError('calendar era result must be a string or undefined');\n  }\n  return result;\n}\n\nexport function CalendarEraYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.eraYear%'), calendarObj, [dateLike]);\n  }\n  const eraYear = GetMethod(calendar, 'eraYear');\n  let result = Call(eraYear, calendar, [dateLike]);\n  if (result === undefined) {\n    return result;\n  }\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar eraYear result must be an integer or undefined');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar eraYear result must be an integer or undefined');\n  }\n  return result;\n}\n\nexport function CalendarDayOfWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dayOfWeek%'), calendarObj, [dateLike]);\n  }\n  const dayOfWeek = GetMethod(calendar, 'dayOfWeek');\n  const result = Call(dayOfWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar dayOfWeek result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar dayOfWeek result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDayOfYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dayOfYear%'), calendarObj, [dateLike]);\n  }\n  const dayOfYear = GetMethod(calendar, 'dayOfYear');\n  const result = Call(dayOfYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar dayOfYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar dayOfYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarWeekOfYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.weekOfYear%'), calendarObj, [dateLike]);\n  }\n  const weekOfYear = GetMethod(calendar, 'weekOfYear');\n  const result = Call(weekOfYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar weekOfYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar weekOfYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarYearOfWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.yearOfWeek%'), calendarObj, [dateLike]);\n  }\n  const yearOfWeek = GetMethod(calendar, 'yearOfWeek');\n  const result = Call(yearOfWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar yearOfWeek result must be an integer');\n  }\n  if (!IsIntegralNumber(result)) {\n    throw new RangeError('calendar yearOfWeek result must be an integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInWeek(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInWeek%'), calendarObj, [dateLike]);\n  }\n  const daysInWeek = GetMethod(calendar, 'daysInWeek');\n  const result = Call(daysInWeek, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInWeek result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInWeek result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInMonth(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInMonth%'), calendarObj, [dateLike]);\n  }\n  const daysInMonth = GetMethod(calendar, 'daysInMonth');\n  const result = Call(daysInMonth, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInMonth result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInMonth result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarDaysInYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.daysInYear%'), calendarObj, [dateLike]);\n  }\n  const daysInYear = GetMethod(calendar, 'daysInYear');\n  const result = Call(daysInYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar daysInYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar daysInYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarMonthsInYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthsInYear%'), calendarObj, [dateLike]);\n  }\n  const monthsInYear = GetMethod(calendar, 'monthsInYear');\n  const result = Call(monthsInYear, calendar, [dateLike]);\n  if (typeof result !== 'number') {\n    throw new TypeError('calendar monthsInYear result must be a positive integer');\n  }\n  if (!IsIntegralNumber(result) || result < 1) {\n    throw new RangeError('calendar monthsInYear result must be a positive integer');\n  }\n  return result;\n}\n\nexport function CalendarInLeapYear(calendar: CalendarSlot, dateLike: CalendarProtocolParams['era'][0]) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.inLeapYear%'), calendarObj, [dateLike]);\n  }\n  const inLeapYear = GetMethod(calendar, 'inLeapYear');\n  const result = Call(inLeapYear, calendar, [dateLike]);\n  if (typeof result !== 'boolean') {\n    throw new TypeError('calendar inLeapYear result must be a boolean');\n  }\n  return result;\n}\n\ntype MaybeCalendarProtocol = Partial<Omit<Temporal.CalendarProtocol, 'toString' | 'toJSON'>>;\nfunction ObjectImplementsTemporalCalendarProtocol(object: MaybeCalendarProtocol) {\n  if (IsTemporalCalendar(object)) return true;\n  return (\n    'dateAdd' in object &&\n    'dateFromFields' in object &&\n    'dateUntil' in object &&\n    'day' in object &&\n    'dayOfWeek' in object &&\n    'dayOfYear' in object &&\n    'daysInMonth' in object &&\n    'daysInWeek' in object &&\n    'daysInYear' in object &&\n    'fields' in object &&\n    'id' in object &&\n    'inLeapYear' in object &&\n    'mergeFields' in object &&\n    'month' in object &&\n    'monthCode' in object &&\n    'monthDayFromFields' in object &&\n    'monthsInYear' in object &&\n    'weekOfYear' in object &&\n    'year' in object &&\n    'yearMonthFromFields' in object &&\n    'yearOfWeek' in object\n  );\n}\n\nexport function ToTemporalCalendarSlotValue(calendarLike: string): string;\nexport function ToTemporalCalendarSlotValue(calendarLike: Temporal.CalendarProtocol): Temporal.CalendarProtocol;\nexport function ToTemporalCalendarSlotValue(calendarLike: Temporal.CalendarLike): string | Temporal.CalendarProtocol;\nexport function ToTemporalCalendarSlotValue(calendarLike: CalendarParams['from'][0]) {\n  if (IsObject(calendarLike)) {\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\n    if (!ObjectImplementsTemporalCalendarProtocol(calendarLike)) {\n      throw new TypeError('expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol');\n    }\n    return calendarLike;\n  }\n  const identifier = ToString(calendarLike);\n  if (IsBuiltinCalendar(identifier)) return ASCIILowercase(identifier);\n  let calendar;\n  try {\n    ({ calendar } = ParseISODateTime(identifier));\n  } catch {\n    try {\n      ({ calendar } = ParseTemporalYearMonthString(identifier));\n    } catch {\n      ({ calendar } = ParseTemporalMonthDayString(identifier));\n    }\n  }\n  if (!calendar) calendar = 'iso8601';\n  if (!IsBuiltinCalendar(calendar)) throw new RangeError(`invalid calendar identifier ${calendar}`);\n  return ASCIILowercase(calendar);\n}\n\nfunction GetTemporalCalendarSlotValueWithISODefault(item: { calendar?: Temporal.CalendarLike }): CalendarSlot {\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\n  const { calendar } = item;\n  if (calendar === undefined) return 'iso8601';\n  return ToTemporalCalendarSlotValue(calendar);\n}\n\nexport function ToTemporalCalendarIdentifier(slotValue: CalendarSlot) {\n  if (typeof slotValue === 'string') return slotValue;\n  const result = slotValue.id;\n  if (typeof result !== 'string') throw new TypeError('calendar.id should be a string');\n  return result;\n}\n\nexport function ToTemporalCalendarObject(slotValue: CalendarSlot) {\n  if (IsObject(slotValue)) return slotValue;\n  const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n  return new TemporalCalendar(slotValue);\n}\n\nexport function CalendarEquals(one: CalendarSlot, two: CalendarSlot) {\n  if (one === two) return true;\n  const cal1 = ToTemporalCalendarIdentifier(one);\n  const cal2 = ToTemporalCalendarIdentifier(two);\n  return cal1 === cal2;\n}\n\n// This operation is not in the spec, it implements the following:\n// \"If ? CalendarEquals(one, two) is false, throw a RangeError exception.\"\n// This is so that we can build an informative error message without\n// re-getting the .id properties.\nfunction ThrowIfCalendarsNotEqual(one: CalendarSlot, two: CalendarSlot, errorMessageAction: string) {\n  if (one === two) return;\n  const cal1 = ToTemporalCalendarIdentifier(one);\n  const cal2 = ToTemporalCalendarIdentifier(two);\n  if (cal1 !== cal2) {\n    throw new RangeError(`cannot ${errorMessageAction} of ${cal1} and ${cal2} calendars`);\n  }\n}\n\nexport function ConsolidateCalendars(one: CalendarSlot, two: CalendarSlot) {\n  if (one === two) return two;\n  const sOne = ToTemporalCalendarIdentifier(one);\n  const sTwo = ToTemporalCalendarIdentifier(two);\n  if (sOne === sTwo || sOne === 'iso8601') {\n    return two;\n  } else if (sTwo === 'iso8601') {\n    return one;\n  } else {\n    throw new RangeError('irreconcilable calendars');\n  }\n}\n\nexport function CalendarDateFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['dateFromFields'][0],\n  options?: Partial<CalendarProtocolParams['dateFromFields'][1]>,\n  dateFromFieldsParam?: Temporal.CalendarProtocol['dateFromFields']\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.dateFromFields%'), calendarObj, [fields, options]);\n  }\n  const dateFromFields = dateFromFieldsParam ?? GetMethod(calendar, 'dateFromFields');\n  const result = Call(dateFromFields, calendar, [fields, options]);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarYearMonthFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['yearMonthFromFields'][0],\n  options?: CalendarProtocolParams['yearMonthFromFields'][1]\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.yearMonthFromFields%'), calendarObj, [fields, options]);\n  }\n  const yearMonthFromFields = GetMethod(calendar, 'yearMonthFromFields');\n  let result = Call(yearMonthFromFields, calendar, [fields, options]);\n  if (!IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nexport function CalendarMonthDayFromFields(\n  calendar: CalendarSlot,\n  fields: CalendarProtocolParams['monthDayFromFields'][0],\n  options?: CalendarProtocolParams['monthDayFromFields'][1]\n) {\n  if (typeof calendar === 'string') {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    const calendarObj = new TemporalCalendar(calendar);\n    return Call(GetIntrinsic('%Temporal.Calendar.prototype.monthDayFromFields%'), calendarObj, [fields, options]);\n  }\n  const monthDayFromFields = GetMethod(calendar, 'monthDayFromFields');\n  let result = Call(monthDayFromFields, calendar, [fields, options]);\n  if (!IsTemporalMonthDay(result)) throw new TypeError('invalid result');\n  return result;\n}\n\ntype MaybeTimeZoneProtocol = Partial<\n  Pick<Temporal.TimeZoneProtocol, 'getOffsetNanosecondsFor' | 'getPossibleInstantsFor'>\n>;\nfunction ObjectImplementsTemporalTimeZoneProtocol(object: MaybeTimeZoneProtocol) {\n  if (IsTemporalTimeZone(object)) return true;\n  return 'getOffsetNanosecondsFor' in object && 'getPossibleInstantsFor' in object && 'id' in object;\n}\n\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: string): string;\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: Temporal.TimeZoneProtocol): Temporal.TimeZoneProtocol;\nexport function ToTemporalTimeZoneSlotValue(\n  temporalTimeZoneLike: Temporal.TimeZoneLike\n): string | Temporal.TimeZoneProtocol;\nexport function ToTemporalTimeZoneSlotValue(temporalTimeZoneLike: TimeZoneParams['from'][0]) {\n  if (IsObject(temporalTimeZoneLike)) {\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n    if (!ObjectImplementsTemporalTimeZoneProtocol(temporalTimeZoneLike)) {\n      throw new TypeError('expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol');\n    }\n    return temporalTimeZoneLike;\n  }\n  const identifier = ToString(temporalTimeZoneLike);\n  return ParseTemporalTimeZone(identifier);\n}\n\nexport function ToTemporalTimeZoneIdentifier(slotValue: TimeZoneSlot) {\n  if (typeof slotValue === 'string') return slotValue;\n  const result = slotValue.id;\n  if (typeof result !== 'string') throw new TypeError('timeZone.id should be a string');\n  return result;\n}\n\nexport function ToTemporalTimeZoneObject(slotValue: TimeZoneSlot) {\n  if (IsObject(slotValue)) return slotValue;\n  const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n  return new TemporalTimeZone(slotValue);\n}\n\nexport function TimeZoneEquals(one: string | Temporal.TimeZoneProtocol, two: string | Temporal.TimeZoneProtocol) {\n  if (one === two) return true;\n  const tz1 = ToTemporalTimeZoneIdentifier(one);\n  const tz2 = ToTemporalTimeZoneIdentifier(two);\n  return tz1 === tz2;\n}\n\nexport function TemporalDateTimeToDate(dateTime: Temporal.PlainDateTime) {\n  return CreateTemporalDate(\n    GetSlot(dateTime, ISO_YEAR),\n    GetSlot(dateTime, ISO_MONTH),\n    GetSlot(dateTime, ISO_DAY),\n    GetSlot(dateTime, CALENDAR)\n  );\n}\n\nexport function TemporalDateTimeToTime(dateTime: Temporal.PlainDateTime) {\n  const Time = GetIntrinsic('%Temporal.PlainTime%');\n  return new Time(\n    GetSlot(dateTime, ISO_HOUR),\n    GetSlot(dateTime, ISO_MINUTE),\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND)\n  );\n}\n\nexport function GetOffsetNanosecondsFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  instant: TimeZoneProtocolParams['getOffsetNanosecondsFor'][0],\n  getOffsetNanosecondsForParam?: Temporal.TimeZoneProtocol['getOffsetNanosecondsFor']\n) {\n  if (typeof timeZone === 'string') {\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    const timeZoneObject = new TemporalTimeZone(timeZone);\n    return Call(GetIntrinsic('%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%'), timeZoneObject, [instant]);\n  }\n  const getOffsetNanosecondsFor = getOffsetNanosecondsForParam ?? GetMethod(timeZone, 'getOffsetNanosecondsFor');\n  const offsetNs = Call(getOffsetNanosecondsFor, timeZone, [instant]);\n  if (typeof offsetNs !== 'number') {\n    throw new TypeError('bad return from getOffsetNanosecondsFor');\n  }\n  if (!IsIntegralNumber(offsetNs) || MathAbs(offsetNs) >= 86400e9) {\n    throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n  }\n  return offsetNs;\n}\n\nexport function GetOffsetStringFor(timeZone: string | Temporal.TimeZoneProtocol, instant: Temporal.Instant) {\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  return FormatTimeZoneOffsetString(offsetNs);\n}\n\nexport function GetPlainDateTimeFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  instant: Temporal.Instant,\n  calendar: CalendarSlot\n) {\n  const ns = GetSlot(instant, EPOCHNANOSECONDS);\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n  ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond + offsetNs\n  ));\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function GetInstantFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: Temporal.PlainDateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n  return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\n\nfunction DisambiguatePossibleInstants(\n  possibleInstants: Temporal.Instant[],\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: Temporal.PlainDateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  const numInstants = possibleInstants.length;\n\n  if (numInstants === 1) return possibleInstants[0];\n  if (numInstants) {\n    switch (disambiguation) {\n      case 'compatible':\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n      case 'earlier':\n        return possibleInstants[0];\n      case 'later':\n        return possibleInstants[numInstants - 1];\n      case 'reject': {\n        throw new RangeError('multiple instants found');\n      }\n    }\n  }\n\n  const year = GetSlot(dateTime, ISO_YEAR);\n  const month = GetSlot(dateTime, ISO_MONTH);\n  const day = GetSlot(dateTime, ISO_DAY);\n  const hour = GetSlot(dateTime, ISO_HOUR);\n  const minute = GetSlot(dateTime, ISO_MINUTE);\n  const second = GetSlot(dateTime, ISO_SECOND);\n  const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n  const utcns = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (utcns === null) throw new RangeError('DateTime outside of supported range');\n  const dayBefore = new Instant(JSBI.subtract(utcns, DAY_NANOS));\n  const dayAfter = new Instant(JSBI.add(utcns, DAY_NANOS));\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n  const nanoseconds = offsetAfter - offsetBefore;\n  switch (disambiguation) {\n    case 'earlier': {\n      const calendar = GetSlot(dateTime, CALENDAR);\n      const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n      const earlier = AddDateTime(\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        calendar,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        -nanoseconds,\n        undefined\n      );\n      const earlierPlainDateTime = new PlainDateTime(\n        earlier.year,\n        earlier.month,\n        earlier.day,\n        earlier.hour,\n        earlier.minute,\n        earlier.second,\n        earlier.millisecond,\n        earlier.microsecond,\n        earlier.nanosecond,\n        calendar\n      );\n      return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n    }\n    case 'compatible':\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n    case 'later': {\n      const calendar = GetSlot(dateTime, CALENDAR);\n      const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n      const later = AddDateTime(\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        calendar,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        nanoseconds,\n        undefined\n      );\n      const laterPlainDateTime = new PlainDateTime(\n        later.year,\n        later.month,\n        later.day,\n        later.hour,\n        later.minute,\n        later.second,\n        later.millisecond,\n        later.microsecond,\n        later.nanosecond,\n        calendar\n      );\n      const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n      return possible[possible.length - 1];\n    }\n    case 'reject': {\n      throw new RangeError('no such instant found');\n    }\n  }\n}\n\nfunction GetPossibleInstantsFor(\n  timeZone: string | Temporal.TimeZoneProtocol,\n  dateTime: TimeZoneProtocolParams['getPossibleInstantsFor'][0],\n  getPossibleInstantsForParam?: Temporal.TimeZoneProtocol['getPossibleInstantsFor']\n) {\n  if (typeof timeZone === 'string') {\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    const timeZoneObject = new TemporalTimeZone(timeZone);\n    return Call(GetIntrinsic('%Temporal.TimeZone.prototype.getPossibleInstantsFor%'), timeZoneObject, [dateTime]);\n  }\n  const getPossibleInstantsFor = getPossibleInstantsForParam ?? GetMethod(timeZone, 'getPossibleInstantsFor');\n  const possibleInstants = Call(getPossibleInstantsFor, timeZone, [dateTime]);\n  const result: Temporal.Instant[] = [];\n  for (const instant of possibleInstants) {\n    if (!IsTemporalInstant(instant)) {\n      throw new TypeError('bad return from getPossibleInstantsFor');\n    }\n    ArrayPrototypePush.call(result, instant);\n  }\n  return result;\n}\n\nexport function ISOYearString(year: number) {\n  let yearString;\n  if (year < 0 || year > 9999) {\n    const sign = year < 0 ? '-' : '+';\n    const yearNumber = MathAbs(year);\n    yearString = sign + `000000${yearNumber}`.slice(-6);\n  } else {\n    yearString = `0000${year}`.slice(-4);\n  }\n  return yearString;\n}\n\nexport function ISODateTimePartString(part: number) {\n  return `00${part}`.slice(-2);\n}\nexport function FormatSecondsStringPart(\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision']\n) {\n  if (precision === 'minute') return '';\n\n  const secs = `:${ISODateTimePartString(second)}`;\n  let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  let fraction: string;\n\n  if (precision === 'auto') {\n    if (fractionNumber === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0');\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n  } else {\n    if (precision === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n  }\n  return `${secs}.${fraction}`;\n}\n\nexport function TemporalInstantToString(\n  instant: Temporal.Instant,\n  timeZone: string | Temporal.TimeZoneProtocol | undefined,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision']\n) {\n  let outputTimeZone = timeZone;\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\n  const dateTime = GetPlainDateTimeFor(outputTimeZone, instant, 'iso8601');\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    precision\n  );\n  let timeZoneString = 'Z';\n  if (timeZone !== undefined) {\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n    timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n  }\n  return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\n\ninterface ToStringOptions {\n  unit: ReturnType<typeof ToSecondsStringPrecisionRecord>['unit'];\n  increment: number;\n  roundingMode: ReturnType<typeof ToTemporalRoundingMode>;\n}\n\nexport function TemporalDurationToString(\n  duration: Temporal.Duration,\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  function formatNumber(num: number) {\n    if (num <= NumberMaxSafeInteger) return num.toString(10);\n    return JSBI.BigInt(num).toString(10);\n  }\n\n  const years = GetSlot(duration, YEARS);\n  const months = GetSlot(duration, MONTHS);\n  const weeks = GetSlot(duration, WEEKS);\n  const days = GetSlot(duration, DAYS);\n  const hours = GetSlot(duration, HOURS);\n  const minutes = GetSlot(duration, MINUTES);\n  let seconds = GetSlot(duration, SECONDS);\n  let ms = GetSlot(duration, MILLISECONDS);\n  let µs = GetSlot(duration, MICROSECONDS);\n  let ns = GetSlot(duration, NANOSECONDS);\n  const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, µs, ns);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({\n      seconds,\n      milliseconds: ms,\n      microseconds: µs,\n      nanoseconds: ns\n    } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, µs, ns, increment, unit, roundingMode));\n  }\n\n  const dateParts: string[] = [];\n  if (years) dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n  if (months) dateParts.push(`${formatNumber(MathAbs(months))}M`);\n  if (weeks) dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n  if (days) dateParts.push(`${formatNumber(MathAbs(days))}D`);\n\n  const timeParts: string[] = [];\n  if (hours) timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n  if (minutes) timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n\n  const secondParts: string[] = [];\n  let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, µs, ns, 0);\n  let nsBigInt: JSBI, µsBigInt: JSBI, msBigInt: JSBI, secondsBigInt: JSBI;\n  ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n  ({ quotient: total, remainder: µsBigInt } = divmod(total, THOUSAND));\n  ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n  const fraction =\n    MathAbs(JSBI.toNumber(msBigInt)) * 1e6 + MathAbs(JSBI.toNumber(µsBigInt)) * 1e3 + MathAbs(JSBI.toNumber(nsBigInt));\n  let decimalPart;\n  if (precision === 'auto') {\n    if (fraction !== 0) {\n      decimalPart = `${fraction}`.padStart(9, '0');\n      while (decimalPart[decimalPart.length - 1] === '0') {\n        decimalPart = decimalPart.slice(0, -1);\n      }\n    }\n  } else if (precision !== 0) {\n    decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n  }\n  if (decimalPart) secondParts.unshift('.', decimalPart);\n  if (!JSBI.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n    secondParts.unshift(abs(secondsBigInt).toString());\n  }\n  if (secondParts.length) timeParts.push(`${secondParts.join('')}S`);\n  if (timeParts.length) timeParts.unshift('T');\n  if (!dateParts.length && !timeParts.length) return 'PT0S';\n  return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\n\nexport function TemporalDateToString(\n  date: Temporal.PlainDate,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const year = ISOYearString(GetSlot(date, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n  const calendar = MaybeFormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\n  return `${year}-${month}-${day}${calendar}`;\n}\n\nexport function TemporalDateTimeToString(\n  dateTime: Temporal.PlainDateTime,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision'],\n  showCalendar: ReturnType<typeof ToCalendarNameOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let year = GetSlot(dateTime, ISO_YEAR);\n  let month = GetSlot(dateTime, ISO_MONTH);\n  let day = GetSlot(dateTime, ISO_DAY);\n  let hour = GetSlot(dateTime, ISO_HOUR);\n  let minute = GetSlot(dateTime, ISO_MINUTE);\n  let second = GetSlot(dateTime, ISO_SECOND);\n  let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      increment,\n      unit,\n      roundingMode\n    ));\n  }\n\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const hourString = ISODateTimePartString(hour);\n  const minuteString = ISODateTimePartString(minute);\n  const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  const calendar = MaybeFormatCalendarAnnotation(GetSlot(dateTime, CALENDAR), showCalendar);\n  return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\n\nexport function TemporalMonthDayToString(\n  monthDay: Temporal.PlainMonthDay,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n  let resultString = `${month}-${day}`;\n  const calendar = GetSlot(monthDay, CALENDAR);\n  const calendarID = ToTemporalCalendarIdentifier(calendar);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendarID !== 'iso8601') {\n    const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n    resultString = `${year}-${resultString}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalYearMonthToString(\n  yearMonth: Temporal.PlainYearMonth,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n  let resultString = `${year}-${month}`;\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const calendarID = ToTemporalCalendarIdentifier(calendar);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendarID !== 'iso8601') {\n    const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n    resultString += `-${day}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalZonedDateTimeToString(\n  zdt: Temporal.ZonedDateTime,\n  precision: ReturnType<typeof ToSecondsStringPrecisionRecord>['precision'],\n  showCalendar: ReturnType<typeof ToCalendarNameOption> = 'auto',\n  showTimeZone: ReturnType<typeof ToTimeZoneNameOption> = 'auto',\n  showOffset: ReturnType<typeof ToShowOffsetOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let instant = GetSlot(zdt, INSTANT);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    instant = new TemporalInstant(ns);\n  }\n\n  const tz = GetSlot(zdt, TIME_ZONE);\n  const dateTime = GetPlainDateTimeFor(tz, instant, 'iso8601');\n\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    precision\n  );\n  let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n  if (showOffset !== 'never') {\n    const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n    result += FormatISOTimeZoneOffsetString(offsetNs);\n  }\n  if (showTimeZone !== 'never') {\n    const identifier = ToTemporalTimeZoneIdentifier(tz);\n    const flag = showTimeZone === 'critical' ? '!' : '';\n    result += `[${flag}${identifier}]`;\n  }\n  result += MaybeFormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\n  return result;\n}\n\nexport function IsTimeZoneOffsetString(string: string) {\n  return OFFSET.test(StringCtor(string));\n}\n\nexport function ParseTimeZoneOffsetString(string: string): number {\n  const match = OFFSET.exec(StringCtor(string));\n  if (!match) {\n    throw new RangeError(`invalid time zone offset: ${string}`);\n  }\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n  const hours = +match[2];\n  const minutes = +(match[3] || 0);\n  const seconds = +(match[4] || 0);\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n  return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\n\nexport function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier: string): string {\n  if (IsTimeZoneOffsetString(timeZoneIdentifier)) {\n    const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n    return FormatTimeZoneOffsetString(offsetNs);\n  }\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n  return formatter.resolvedOptions().timeZone;\n}\n\nexport function GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: JSBI) {\n  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n    GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. To avoid overflowing at the edges of the range, we reduce the year\n  // to the remainder after dividing by 400, and then add back all the\n  // nanoseconds from the multiples of 400 years at the end.\n  const reducedYear = year % 400;\n  const yearCycles = (year - reducedYear) / 400;\n  const nsIn400YearCycle = JSBI.multiply(JSBI.BigInt(400 * 365 + 97), DAY_NANOS);\n\n  const reducedUTC = GetUTCEpochNanoseconds(\n    reducedYear,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  );\n  assertExists(reducedUTC);\n  const utc = JSBI.add(reducedUTC, JSBI.multiply(nsIn400YearCycle, JSBI.BigInt(yearCycles)));\n  return JSBI.toNumber(JSBI.subtract(utc, epochNanoseconds));\n}\n\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam: number): string {\n  const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n  const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n  const nanoseconds = offsetNanoseconds % 1e9;\n  const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n  const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  const secondString = ISODateTimePartString(seconds);\n  let post = '';\n  if (nanoseconds) {\n    let fraction = `${nanoseconds}`.padStart(9, '0');\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n    post = `:${secondString}.${fraction}`;\n  } else if (seconds) {\n    post = `:${secondString}`;\n  }\n  return `${sign}${hourString}:${minuteString}${post}`;\n}\n\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam: number): string {\n  let offsetNanoseconds = JSBI.toNumber(\n    RoundNumberToIncrement(JSBI.BigInt(offsetNanosecondsParam), MINUTE_NANOS, 'halfExpand')\n  );\n  const sign = offsetNanoseconds < 0 ? '-' : '+';\n  offsetNanoseconds = MathAbs(offsetNanoseconds);\n  const minutes = (offsetNanoseconds / 60e9) % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  return `${sign}${hourString}:${minuteString}`;\n}\nexport function GetUTCEpochNanoseconds(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  // Note: Date.UTC() interprets one and two-digit years as being in the\n  // 20th century, so don't use it\n  const legacyDate = new Date();\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\n  legacyDate.setUTCFullYear(year, month - 1, day);\n  const ms = legacyDate.getTime();\n  if (NumberIsNaN(ms)) return null;\n  let ns = JSBI.multiply(JSBI.BigInt(ms), MILLION);\n  ns = JSBI.add(ns, JSBI.multiply(JSBI.BigInt(microsecond), THOUSAND));\n  ns = JSBI.add(ns, JSBI.BigInt(nanosecond));\n  if (JSBI.lessThan(ns, NS_MIN) || JSBI.greaterThan(ns, NS_MAX)) return null;\n  return ns;\n}\n\nfunction GetISOPartsFromEpoch(epochNanoseconds: JSBI) {\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n  let epochMilliseconds = JSBI.toNumber(quotient);\n  let nanos = JSBI.toNumber(remainder);\n  if (nanos < 0) {\n    nanos += 1e6;\n    epochMilliseconds -= 1;\n  }\n  const microsecond = MathFloor(nanos / 1e3) % 1e3;\n  const nanosecond = nanos % 1e3;\n\n  const item = new Date(epochMilliseconds);\n  const year = item.getUTCFullYear();\n  const month = item.getUTCMonth() + 1;\n  const day = item.getUTCDate();\n  const hour = item.getUTCHours();\n  const minute = item.getUTCMinutes();\n  const second = item.getUTCSeconds();\n  const millisecond = item.getUTCMilliseconds();\n\n  return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: JSBI) {\n  const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction maxJSBI(one: JSBI, two: JSBI) {\n  return JSBI.lessThan(one, two) ? two : one;\n}\n\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n  return JSBI.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\n\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  if (JSBI.lessThan(epochNanoseconds, BEFORE_FIRST_OFFSET_TRANSITION)) {\n    return GetNamedTimeZoneNextTransition(id, BEFORE_FIRST_OFFSET_TRANSITION);\n  }\n  // Decide how far in the future after `epochNanoseconds` we'll look for an\n  // offset change. There are two cases:\n  // 1. If it's a past date (or a date in the near future) then it's possible\n  //    that the time zone may have newly added DST in the next few years. So\n  //    we'll have to look from the provided time until a few years after the\n  //    current system time. (Changes to DST policy are usually announced a few\n  //    years in the future.) Note that the first DST anywhere started in 1847,\n  //    so we'll start checks in 1847 instead of wasting cycles on years where\n  //    there will never be transitions.\n  // 2. If it's a future date beyond the next few years, then we'll just assume\n  //    that the latest DST policy in TZDB will still be in effect.  In this\n  //    case, we only need to look one year in the future to see if there are\n  //    any DST transitions.  We actually only need to look 9-10 months because\n  //    DST has two transitions per year, but we'll use a year just to be safe.\n  const oneYearLater = JSBI.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n  const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n  // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n  // start there if an earlier date is supplied.\n  let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n  const leftOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, leftNanos);\n  let rightNanos = leftNanos;\n  let rightOffsetNs = leftOffsetNs;\n  while (leftOffsetNs === rightOffsetNs && JSBI.lessThan(JSBI.BigInt(leftNanos), uppercap)) {\n    rightNanos = JSBI.add(leftNanos, TWO_WEEKS_NANOS);\n    if (JSBI.greaterThan(rightNanos, NS_MAX)) return null;\n    rightOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, rightNanos);\n    if (leftOffsetNs === rightOffsetNs) {\n      leftNanos = rightNanos;\n    }\n  }\n  if (leftOffsetNs === rightOffsetNs) return null;\n  const result = bisect(\n    (epochNs: JSBI) => GetNamedTimeZoneOffsetNanoseconds(id, epochNs),\n    leftNanos,\n    rightNanos,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return result;\n}\n\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n  // have to look back one year to find a transition. But if it doesn't use DST,\n  // then we need to look all the way back to 1847 (the earliest rule in the\n  // TZDB) to see if it had other offset transitions in the past. Looping back\n  // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n  // also unnecessary because DST rules aren't put into the TZDB more than a few\n  // years in the future because the political changes in time zones happen with\n  // only a few years' warning. Therefore, if a far-future date is provided,\n  // then we'll run the check in two parts:\n  // 1. First, we'll look back for up to one year to see if the latest TZDB\n  //    rules have DST.\n  // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n  //    current system time, and then look back to 1847. This reduces the\n  //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n  //    in worst-case perf.\n  const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n  const isFarFuture = JSBI.greaterThan(epochNanoseconds, afterLatestRule);\n  const lowercap = isFarFuture ? JSBI.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n\n  // TODO: proposal-temporal polyfill has different code for very similar\n  // optimizations as above, as well as in GetNamedTimeZonePreviousTransition.\n  // We should figure out if we should change one polyfill to match the other.\n\n  // We assume most time zones either have regular DST rules that extend\n  // indefinitely into the future, or they have no DST transitions between now\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\n  // that fit neither of these. Their irregular DST transitions are\n  // precomputed until 2087 in the current time zone database, so requesting\n  // the previous transition for an instant far in the future may take an\n  // extremely long time as it loops backward 2 weeks at a time.\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\n    const lastPrecomputed = GetSlot(ToTemporalInstant('2088-01-01T00Z'), EPOCHNANOSECONDS);\n    if (JSBI.lessThan(lastPrecomputed, epochNanoseconds)) {\n      return GetNamedTimeZonePreviousTransition(id, lastPrecomputed);\n    }\n  }\n\n  let rightNanos = JSBI.subtract(epochNanoseconds, ONE);\n  if (JSBI.lessThan(rightNanos, BEFORE_FIRST_OFFSET_TRANSITION)) return null;\n  const rightOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, rightNanos);\n  let leftNanos = rightNanos;\n  let leftOffsetNs = rightOffsetNs;\n  while (rightOffsetNs === leftOffsetNs && JSBI.greaterThan(rightNanos, lowercap)) {\n    leftNanos = JSBI.subtract(rightNanos, TWO_WEEKS_NANOS);\n    if (JSBI.lessThan(leftNanos, BEFORE_FIRST_OFFSET_TRANSITION)) return null;\n    leftOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, leftNanos);\n    if (rightOffsetNs === leftOffsetNs) {\n      rightNanos = leftNanos;\n    }\n  }\n  if (rightOffsetNs === leftOffsetNs) {\n    if (isFarFuture) {\n      // There was no DST after looking back one year, which means that the most\n      // recent TZDB rules don't have any recurring transitions. To check for\n      // transitions in older rules, back up to a few years after the current\n      // date and then look all the way back to 1847. Note that we move back one\n      // day from the latest possible rule so that when the recursion runs it\n      // won't consider the new time to be \"far future\" because the system clock\n      // has advanced in the meantime.\n      const newTimeToCheck = JSBI.subtract(afterLatestRule, DAY_NANOS);\n      return GetNamedTimeZonePreviousTransition(id, newTimeToCheck);\n    }\n    return null;\n  }\n  const result = bisect(\n    (epochNs: JSBI) => GetNamedTimeZoneOffsetNanoseconds(id, epochNs),\n    leftNanos,\n    rightNanos,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime: string) {\n  const parts = datetime.split(/[^\\w]+/);\n\n  if (parts.length !== 7) {\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\n  }\n\n  const month = +parts[0];\n  const day = +parts[1];\n  let year = +parts[2];\n  const era = parts[3].toUpperCase();\n  if (era === 'B' || era === 'BC') {\n    year = -year + 1;\n  } else if (era !== 'A' && era !== 'AD') {\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n  }\n  let hour = +parts[4];\n  if (hour === 24) {\n    // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n    hour = 0;\n  }\n  const minute = +parts[5];\n  const second = +parts[6];\n\n  if (\n    !NumberIsFinite(year) ||\n    !NumberIsFinite(month) ||\n    !NumberIsFinite(day) ||\n    !NumberIsFinite(hour) ||\n    !NumberIsFinite(minute) ||\n    !NumberIsFinite(second)\n  ) {\n    throw new RangeError(`Invalid number in \"${datetime}`);\n  }\n\n  return { year, month, day, hour, minute, second };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n  // Using `format` instead of `formatToParts` for compatibility with older clients\n  const datetime = formatter.format(new Date(epochMilliseconds));\n  return parseFromEnUsFormat(datetime);\n}\n\nexport function GetNamedTimeZoneEpochNanoseconds(\n  id: string,\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  const ns = GetUTCEpochNanoseconds(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (ns === null) throw new RangeError('DateTime outside of supported range');\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS);\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\n  let nsLater = JSBI.add(ns, DAY_NANOS);\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\n  const earliest = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\n  const latest = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\n  const found = earliest === latest ? [earliest] : [earliest, latest];\n  return found\n    .map((offsetNanoseconds) => {\n      const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n      const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n      if (\n        year !== parts.year ||\n        month !== parts.month ||\n        day !== parts.day ||\n        hour !== parts.hour ||\n        minute !== parts.minute ||\n        second !== parts.second ||\n        millisecond !== parts.millisecond ||\n        microsecond !== parts.microsecond ||\n        nanosecond !== parts.nanosecond\n      ) {\n        return undefined;\n      }\n      return epochNanoseconds;\n    })\n    .filter((x) => x !== undefined) as JSBI[];\n}\n\nexport function LeapYear(year: number) {\n  if (undefined === year) return false;\n  const isDiv4 = year % 4 === 0;\n  const isDiv100 = year % 100 === 0;\n  const isDiv400 = year % 400 === 0;\n  return isDiv4 && (!isDiv100 || isDiv400);\n}\n\nexport function ISODaysInMonth(year: number, month: number) {\n  const DoM = {\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  };\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\n\nexport function DayOfWeek(year: number, month: number, day: number) {\n  const m = month + (month < 3 ? 10 : -2);\n  const Y = year - (month < 3 ? 1 : 0);\n\n  const c = MathFloor(Y / 100);\n  const y = Y - c * 100;\n  const d = day;\n\n  const pD = d;\n  const pM = MathFloor(2.6 * m - 0.2);\n  const pY = y + MathFloor(y / 4);\n  const pC = MathFloor(c / 4) - 2 * c;\n\n  const dow = (pD + pM + pY + pC) % 7;\n\n  return dow + (dow <= 0 ? 7 : 0);\n}\n\nexport function DayOfYear(year: number, month: number, day: number) {\n  let days = day;\n  for (let m = month - 1; m > 0; m--) {\n    days += ISODaysInMonth(year, m);\n  }\n  return days;\n}\n\nexport function WeekOfYear(year: number, month: number, day: number) {\n  const doy = DayOfYear(year, month, day);\n  const dow = DayOfWeek(year, month, day) || 7;\n  const doj = DayOfWeek(year, 1, 1);\n\n  const week = MathFloor((doy - dow + 10) / 7);\n\n  if (week < 1) {\n    if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n      return { week: 53, year: year - 1 };\n    } else {\n      return { week: 52, year: year - 1 };\n    }\n  }\n  if (week === 53) {\n    if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n      return { week: 1, year: year + 1 };\n    }\n  }\n\n  return { week, year };\n}\n\nexport function DurationSign(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n  return 0;\n}\n\nfunction BalanceISOYearMonth(yearParam: number, monthParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  if (!NumberIsFinite(year) || !NumberIsFinite(month)) throw new RangeError('infinity is out of range');\n  month -= 1;\n  year += MathFloor(month / 12);\n  month %= 12;\n  if (month < 0) month += 12;\n  month += 1;\n  return { year, month };\n}\n\nfunction BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  if (!NumberIsFinite(day)) throw new RangeError('infinity is out of range');\n  ({ year, month } = BalanceISOYearMonth(year, month));\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. So if we have more than 400 years in days, there's no need to\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\n  // once.\n  const daysIn400YearCycle = 400 * 365 + 97;\n  if (MathAbs(day) > daysIn400YearCycle) {\n    const nCycles = MathTrunc(day / daysIn400YearCycle);\n    year += 400 * nCycles;\n    day -= nCycles * daysIn400YearCycle;\n  }\n\n  let daysInYear = 0;\n  let testYear = month > 2 ? year : year - 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n    year -= 1;\n    testYear -= 1;\n    day += daysInYear;\n  }\n  testYear += 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n    year += 1;\n    testYear += 1;\n    day -= daysInYear;\n  }\n\n  while (day < 1) {\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\n    day += ISODaysInMonth(year, month);\n  }\n  while (day > ISODaysInMonth(year, month)) {\n    day -= ISODaysInMonth(year, month);\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\n  }\n\n  return { year, month, day };\n}\n\nfunction BalanceISODateTime(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam\n  );\n  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nfunction BalanceTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  let hour = JSBI.BigInt(hourParam);\n  let minute = JSBI.BigInt(minuteParam);\n  let second = JSBI.BigInt(secondParam);\n  let millisecond = JSBI.BigInt(millisecondParam);\n  let microsecond = JSBI.BigInt(microsecondParam);\n  let nanosecond = JSBI.BigInt(nanosecondParam);\n  let quotient;\n\n  ({ quotient, remainder: nanosecond } = NonNegativeBigIntDivmod(nanosecond, THOUSAND));\n  microsecond = JSBI.add(microsecond, quotient);\n\n  ({ quotient, remainder: microsecond } = NonNegativeBigIntDivmod(microsecond, THOUSAND));\n  millisecond = JSBI.add(millisecond, quotient);\n\n  ({ quotient, remainder: millisecond } = NonNegativeBigIntDivmod(millisecond, THOUSAND));\n  second = JSBI.add(second, quotient);\n\n  ({ quotient, remainder: second } = NonNegativeBigIntDivmod(second, SIXTY));\n  minute = JSBI.add(minute, quotient);\n\n  ({ quotient, remainder: minute } = NonNegativeBigIntDivmod(minute, SIXTY));\n  hour = JSBI.add(hour, quotient);\n\n  ({ quotient, remainder: hour } = NonNegativeBigIntDivmod(hour, TWENTY_FOUR));\n\n  return {\n    deltaDays: JSBI.toNumber(quotient),\n    hour: JSBI.toNumber(hour),\n    minute: JSBI.toNumber(minute),\n    second: JSBI.toNumber(second),\n    millisecond: JSBI.toNumber(millisecond),\n    microsecond: JSBI.toNumber(microsecond),\n    nanosecond: JSBI.toNumber(nanosecond)\n  };\n}\n\nexport function TotalDurationNanoseconds(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  offsetShift: number\n) {\n  const days: JSBI = JSBI.BigInt(daysParam);\n  let nanoseconds: JSBI = JSBI.BigInt(nanosecondsParam);\n  if (daysParam !== 0) nanoseconds = JSBI.subtract(JSBI.BigInt(nanosecondsParam), JSBI.BigInt(offsetShift));\n  const hours = JSBI.add(JSBI.BigInt(hoursParam), JSBI.multiply(days, JSBI.BigInt(24)));\n  const minutes = JSBI.add(JSBI.BigInt(minutesParam), JSBI.multiply(hours, SIXTY));\n  const seconds = JSBI.add(JSBI.BigInt(secondsParam), JSBI.multiply(minutes, SIXTY));\n  const milliseconds = JSBI.add(JSBI.BigInt(millisecondsParam), JSBI.multiply(seconds, THOUSAND));\n  const microseconds = JSBI.add(JSBI.BigInt(microsecondsParam), JSBI.multiply(milliseconds, THOUSAND));\n  return JSBI.add(JSBI.BigInt(nanoseconds), JSBI.multiply(microseconds, THOUSAND));\n}\n\nfunction NanosecondsToDays(nanosecondsParam: JSBI, relativeTo: ReturnType<typeof ToRelativeTemporalObject>) {\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const sign = MathSign(JSBI.toNumber(nanosecondsParam));\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  let dayLengthNs = 86400e9;\n  if (sign === 0) return { days: 0, nanoseconds: ZERO, dayLengthNs };\n  if (!IsTemporalZonedDateTime(relativeTo)) {\n    let days: JSBI;\n    ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, JSBI.BigInt(dayLengthNs)));\n    return { days: JSBI.toNumber(days), nanoseconds, dayLengthNs };\n  }\n\n  const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n  const start = GetSlot(relativeTo, INSTANT);\n  const endNs = JSBI.add(startNs, nanoseconds);\n  const end = new TemporalInstant(endNs);\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n\n  // Find the difference in days only.\n  const dtStart = GetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = GetPlainDateTimeFor(timeZone, end, calendar);\n  let { days: daysNumber } = DifferenceISODateTime(\n    GetSlot(dtStart, ISO_YEAR),\n    GetSlot(dtStart, ISO_MONTH),\n    GetSlot(dtStart, ISO_DAY),\n    GetSlot(dtStart, ISO_HOUR),\n    GetSlot(dtStart, ISO_MINUTE),\n    GetSlot(dtStart, ISO_SECOND),\n    GetSlot(dtStart, ISO_MILLISECOND),\n    GetSlot(dtStart, ISO_MICROSECOND),\n    GetSlot(dtStart, ISO_NANOSECOND),\n    GetSlot(dtEnd, ISO_YEAR),\n    GetSlot(dtEnd, ISO_MONTH),\n    GetSlot(dtEnd, ISO_DAY),\n    GetSlot(dtEnd, ISO_HOUR),\n    GetSlot(dtEnd, ISO_MINUTE),\n    GetSlot(dtEnd, ISO_SECOND),\n    GetSlot(dtEnd, ISO_MILLISECOND),\n    GetSlot(dtEnd, ISO_MICROSECOND),\n    GetSlot(dtEnd, ISO_NANOSECOND),\n    calendar,\n    'day',\n    ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n  );\n  let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, daysNumber, 0, 0, 0, 0, 0, 0);\n  // may disambiguate\n\n  // If clock time after addition was in the middle of a skipped period, the\n  // endpoint was disambiguated to a later clock time. So it's possible that\n  // the resulting disambiguated result is later than endNs. If so, then back\n  // up one day and try again. Repeat if necessary (some transitions are\n  // > 24 hours) until either there's zero days left or the date duration is\n  // back inside the period where it belongs. Note that this case only can\n  // happen for positive durations because the only direction that\n  // `disambiguation: 'compatible'` can change clock time is forwards.\n  let daysBigInt = JSBI.BigInt(daysNumber);\n  if (sign === 1) {\n    while (JSBI.greaterThan(daysBigInt, ZERO) && JSBI.greaterThan(intermediateNs, endNs)) {\n      daysBigInt = JSBI.subtract(daysBigInt, ONE);\n      intermediateNs = AddZonedDateTime(\n        start,\n        timeZone,\n        calendar,\n        0,\n        0,\n        0,\n        JSBI.toNumber(daysBigInt),\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      );\n      // may do disambiguation\n    }\n  }\n  nanoseconds = JSBI.subtract(endNs, intermediateNs);\n\n  let isOverflow = false;\n  let relativeInstant = new TemporalInstant(intermediateNs);\n  do {\n    // calculate length of the next day (day that contains the time remainder)\n    const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n    const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n    dayLengthNs = JSBI.toNumber(JSBI.subtract(oneDayFartherNs, relativeNs));\n    isOverflow = JSBI.greaterThanOrEqual(\n      JSBI.multiply(JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs)), JSBI.BigInt(sign)),\n      ZERO\n    );\n    if (isOverflow) {\n      nanoseconds = JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs));\n      relativeInstant = new TemporalInstant(oneDayFartherNs);\n      daysBigInt = JSBI.add(daysBigInt, JSBI.BigInt(sign));\n    }\n  } while (isOverflow);\n  if (!isZero(daysBigInt) && signJSBI(daysBigInt) !== sign) {\n    throw new RangeError('Time zone or calendar converted nanoseconds into a number of days with the opposite sign');\n  }\n  if (!isZero(nanoseconds) && signJSBI(nanoseconds) !== sign) {\n    if (isNegativeJSBI(nanoseconds) && sign === 1) {\n      throw new Error('assert not reached');\n    }\n    throw new RangeError('Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign');\n  }\n  if (JSBI.greaterThanOrEqual(abs(nanoseconds), abs(JSBI.BigInt(dayLengthNs)))) {\n    throw new Error('assert not reached');\n  }\n  return { days: JSBI.toNumber(daysBigInt), nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\n\nexport function BalanceDuration(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let result = BalancePossiblyInfiniteDuration(\n    daysParam,\n    hoursParam,\n    minutesParam,\n    secondsParam,\n    millisecondsParam,\n    microsecondsParam,\n    nanosecondsParam,\n    largestUnit,\n    relativeTo\n  );\n  if (result === 'positive overflow' || result === 'negative overflow') {\n    throw new RangeError('Duration out of range');\n  } else {\n    return result;\n  }\n}\n\nexport function BalancePossiblyInfiniteDuration(\n  daysParam: number,\n  hoursParam: number | JSBI,\n  minutesParam: number | JSBI,\n  secondsParam: number | JSBI,\n  millisecondsParam: number | JSBI,\n  microsecondsParam: number | JSBI,\n  nanosecondsParam: number | JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let days = daysParam;\n  let nanosecondsBigInt: JSBI,\n    microsecondsBigInt: JSBI,\n    millisecondsBigInt: JSBI,\n    secondsBigInt: JSBI,\n    minutesBigInt: JSBI,\n    hoursBigInt: JSBI;\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const endNs = AddZonedDateTime(\n      GetSlot(relativeTo, INSTANT),\n      GetSlot(relativeTo, TIME_ZONE),\n      GetSlot(relativeTo, CALENDAR),\n      0,\n      0,\n      0,\n      days,\n      hoursParam,\n      minutesParam,\n      secondsParam,\n      millisecondsParam,\n      microsecondsParam,\n      nanosecondsParam\n    );\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    nanosecondsBigInt = JSBI.subtract(endNs, startNs);\n  } else {\n    nanosecondsBigInt = TotalDurationNanoseconds(\n      days,\n      hoursParam,\n      minutesParam,\n      secondsParam,\n      millisecondsParam,\n      microsecondsParam,\n      nanosecondsParam,\n      0\n    );\n  }\n  if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n    ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n  } else {\n    days = 0;\n  }\n\n  const sign = JSBI.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n  nanosecondsBigInt = abs(nanosecondsBigInt);\n  microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n\n  switch (largestUnit) {\n    case 'year':\n    case 'month':\n    case 'week':\n    case 'day':\n    case 'hour':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n      ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n      break;\n    case 'minute':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n      break;\n    case 'second':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n      break;\n    case 'millisecond':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n      break;\n    case 'microsecond':\n      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n      break;\n    case 'nanosecond':\n      break;\n    default:\n      throw new Error('assert not reached');\n  }\n\n  const hours = JSBI.toNumber(hoursBigInt) * sign;\n  const minutes = JSBI.toNumber(minutesBigInt) * sign;\n  const seconds = JSBI.toNumber(secondsBigInt) * sign;\n  const milliseconds = JSBI.toNumber(millisecondsBigInt) * sign;\n  const microseconds = JSBI.toNumber(microsecondsBigInt) * sign;\n  const nanoseconds = JSBI.toNumber(nanosecondsBigInt) * sign;\n\n  for (const prop of [days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n    if (!NumberIsFinite(prop)) {\n      if (sign === 1) {\n        return 'positive overflow' as const;\n      } else {\n        return 'negative overflow' as const;\n      }\n    }\n  }\n\n  return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nexport function UnbalanceDurationRelative(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject>\n): {\n  years: number;\n  months: number;\n  weeks: number;\n  days: number;\n} {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(yearsParam, monthsParam, weeksParam, daysParam, 0, 0, 0, 0, 0, 0);\n  if (sign === 0) return { years: yearsParam, months: monthsParam, weeks: weeksParam, days: daysParam };\n  const signBI = JSBI.BigInt(sign);\n\n  let years = JSBI.BigInt(yearsParam);\n  let months = JSBI.BigInt(monthsParam);\n  let weeks = JSBI.BigInt(weeksParam);\n  let days = JSBI.BigInt(daysParam);\n\n  let calendar;\n  let relativeTo: Temporal.PlainDate | undefined;\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year':\n      // no-op\n      break;\n    case 'month':\n      {\n        if (!calendar) throw new RangeError('a starting point is required for months balancing');\n        assertExists(relativeTo);\n        // balance years down to months\n        let dateAdd, dateUntil;\n        if (typeof calendar !== 'string') {\n          dateAdd = GetMethod(calendar, 'dateAdd');\n          dateUntil = GetMethod(calendar, 'dateUntil');\n        }\n        while (!isZero(years)) {\n          const newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n          const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<typeof largestUnit>;\n          untilOptions.largestUnit = 'month';\n          const untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n          const oneYearMonths = JSBI.BigInt(GetSlot(untilResult, MONTHS));\n          relativeTo = newRelativeTo;\n          months = JSBI.add(months, oneYearMonths);\n          years = JSBI.subtract(years, signBI);\n        }\n      }\n      break;\n    case 'week': {\n      if (!calendar) throw new RangeError('a starting point is required for weeks balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance years down to days\n      while (!isZero(years)) {\n        let oneYearDays;\n        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.subtract(years, signBI);\n      }\n\n      // balance months down to days\n      while (!isZero(months)) {\n        let oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.subtract(months, signBI);\n      }\n      break;\n    }\n    default: {\n      // balance years down to days\n      if (isZero(years) && isZero(months) && isZero(weeks)) break;\n      if (!calendar) throw new RangeError('a starting point is required for balancing calendar units');\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      while (!isZero(years)) {\n        assertExists(relativeTo);\n        let oneYearDays;\n        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.subtract(years, signBI);\n      }\n\n      // balance months down to days\n      while (!isZero(months)) {\n        assertExists(relativeTo);\n        let oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.subtract(months, signBI);\n      }\n\n      // balance weeks down to days\n      while (!isZero(weeks)) {\n        assertExists(relativeTo);\n        let oneWeekDays;\n        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n        days = JSBI.add(days, JSBI.BigInt(oneWeekDays));\n        weeks = JSBI.subtract(weeks, signBI);\n      }\n      break;\n    }\n  }\n\n  return {\n    years: JSBI.toNumber(years),\n    months: JSBI.toNumber(months),\n    weeks: JSBI.toNumber(weeks),\n    days: JSBI.toNumber(days)\n  };\n}\n\nexport function BalanceDurationRelative(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  largestUnit: Temporal.DateTimeUnit,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject>\n): {\n  years: number;\n  months: number;\n  weeks: number;\n  days: number;\n} {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(yearsParam, monthsParam, weeksParam, daysParam, 0, 0, 0, 0, 0, 0);\n  if (sign === 0) return { years: yearsParam, months: monthsParam, weeks: weeksParam, days: daysParam };\n  const signBI = JSBI.BigInt(sign);\n\n  let years = JSBI.BigInt(yearsParam);\n  let months = JSBI.BigInt(monthsParam);\n  let weeks = JSBI.BigInt(weeksParam);\n  let days = JSBI.BigInt(daysParam);\n\n  let calendar;\n  let relativeTo: Temporal.PlainDate | undefined;\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year': {\n      if (!calendar) throw new RangeError('a starting point is required for years balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to years\n      let newRelativeTo, oneYearDays;\n      ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneYearDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneYearDays));\n        years = JSBI.add(years, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd));\n      }\n\n      // balance days up to months\n      let oneMonthDays;\n      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneMonthDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.add(months, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n\n      // balance months up to years\n      newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n      const dateUntil = typeof calendar !== 'string' ? GetMethod(calendar, 'dateUntil') : undefined;\n      const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<'month'>;\n      untilOptions.largestUnit = 'month';\n      let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n      let oneYearMonths = GetSlot(untilResult, MONTHS);\n      while (JSBI.greaterThanOrEqual(abs(months), JSBI.BigInt(MathAbs(oneYearMonths)))) {\n        months = JSBI.subtract(months, JSBI.BigInt(oneYearMonths));\n        years = JSBI.add(years, signBI);\n        relativeTo = newRelativeTo;\n        newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n        const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<'month'>;\n        untilOptions.largestUnit = 'month';\n        untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n        oneYearMonths = GetSlot(untilResult, MONTHS);\n      }\n      break;\n    }\n    case 'month': {\n      if (!calendar) throw new RangeError('a starting point is required for months balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to months\n      let newRelativeTo, oneMonthDays;\n      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneMonthDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneMonthDays));\n        months = JSBI.add(months, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n      break;\n    }\n    case 'week': {\n      if (!calendar) throw new RangeError('a starting point is required for weeks balancing');\n      assertExists(relativeTo);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      // balance days up to weeks\n      let newRelativeTo, oneWeekDays;\n      ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      while (JSBI.greaterThanOrEqual(abs(days), JSBI.BigInt(MathAbs(oneWeekDays)))) {\n        days = JSBI.subtract(days, JSBI.BigInt(oneWeekDays));\n        weeks = JSBI.add(weeks, signBI);\n        relativeTo = newRelativeTo;\n        ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      }\n      break;\n    }\n    default:\n      // no-op\n      break;\n  }\n\n  return {\n    years: JSBI.toNumber(years),\n    months: JSBI.toNumber(months),\n    weeks: JSBI.toNumber(weeks),\n    days: JSBI.toNumber(days)\n  };\n}\n\nexport function CalculateOffsetShift(\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>,\n  y: number,\n  mon: number,\n  w: number,\n  d: number\n) {\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const instant = GetSlot(relativeTo, INSTANT);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n    const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instantAfter = new TemporalInstant(after);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n    return offsetAfter - offsetBefore;\n  }\n  return 0;\n}\n\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    -GetSlot(duration, YEARS),\n    -GetSlot(duration, MONTHS),\n    -GetSlot(duration, WEEKS),\n    -GetSlot(duration, DAYS),\n    -GetSlot(duration, HOURS),\n    -GetSlot(duration, MINUTES),\n    -GetSlot(duration, SECONDS),\n    -GetSlot(duration, MILLISECONDS),\n    -GetSlot(duration, MICROSECONDS),\n    -GetSlot(duration, NANOSECONDS)\n  );\n}\n\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\n  // used for optional params in the method below.\n  return MathMin(max, MathMax(min, value as number));\n}\nfunction ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\n  const month = ConstrainToRange(monthParam, 1, 12);\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n  return { year, month, day };\n}\n\nfunction ConstrainTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  const hour = ConstrainToRange(hourParam, 0, 23);\n  const minute = ConstrainToRange(minuteParam, 0, 59);\n  const second = ConstrainToRange(secondParam, 0, 59);\n  const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n  const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n  const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RejectToRange(value: number, min: number, max: number) {\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\n\nfunction RejectISODate(year: number, month: number, day: number) {\n  RejectToRange(month, 1, 12);\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\n\nfunction RejectDateRange(year: number, month: number, day: number) {\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\n  RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\n\nexport function RejectTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(hour, 0, 23);\n  RejectToRange(minute, 0, 59);\n  RejectToRange(second, 0, 59);\n  RejectToRange(millisecond, 0, 999);\n  RejectToRange(microsecond, 0, 999);\n  RejectToRange(nanosecond, 0, 999);\n}\n\nfunction RejectDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectISODate(year, month, day);\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction RejectDateTimeRange(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  // Reject any DateTime 24 hours or more outside the Instant range\n  if (\n    (year === YEAR_MIN &&\n      null ==\n        GetUTCEpochNanoseconds(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n    (year === YEAR_MAX &&\n      null ==\n        GetUTCEpochNanoseconds(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))\n  ) {\n    throw new RangeError('DateTime outside of supported range');\n  }\n}\n\nexport function ValidateEpochNanoseconds(epochNanoseconds: JSBI) {\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n    throw new RangeError('Instant outside of supported range');\n  }\n}\n\nfunction RejectYearMonthRange(year: number, month: number) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  if (year === YEAR_MIN) {\n    RejectToRange(month, 4, 12);\n  } else if (year === YEAR_MAX) {\n    RejectToRange(month, 1, 9);\n  }\n}\n\nexport function RejectDuration(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  const sign = DurationSign(y, mon, w, d, h, min, s, ms, µs, ns);\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (!NumberIsFinite(prop)) throw new RangeError('infinite values not allowed as duration fields');\n    const propSign = MathSign(prop);\n    if (propSign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\n  }\n}\n\nexport function DifferenceISODate<Allowed extends Temporal.DateTimeUnit>(\n  y1: number,\n  m1: number,\n  d1: number,\n  y2: number,\n  m2: number,\n  d2: number,\n  largestUnit: Allowed\n) {\n  switch (largestUnit) {\n    case 'year':\n    case 'month': {\n      const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n      if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\n\n      const start = { year: y1, month: m1, day: d1 };\n      const end = { year: y2, month: m2, day: d2 };\n\n      let years = end.year - start.year;\n      let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n      let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n      if (midSign === 0) {\n        return largestUnit === 'year'\n          ? { years, months: 0, weeks: 0, days: 0 }\n          : { years: 0, months: years * 12, weeks: 0, days: 0 };\n      }\n      let months = end.month - start.month;\n      if (midSign !== sign) {\n        years -= sign;\n        months += sign * 12;\n      }\n      mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n      midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n      if (midSign === 0) {\n        return largestUnit === 'year'\n          ? { years, months, weeks: 0, days: 0 }\n          : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n      }\n      if (midSign !== sign) {\n        // The end date is later in the month than mid date (or earlier for\n        // negative durations). Back up one month.\n        months -= sign;\n        if (months === -sign) {\n          years -= sign;\n          months = 11 * sign;\n        }\n        mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n      }\n\n      let days = 0;\n      // If we get here, months and years are correct (no overflow), and `mid`\n      // is within the range from `start` to `end`. To count the days between\n      // `mid` and `end`, there are 3 cases:\n      // 1) same month: use simple subtraction\n      // 2) end is previous month from intermediate (negative duration)\n      // 3) end is next month from intermediate (positive duration)\n      if (mid.month === end.month) {\n        // 1) same month: use simple subtraction\n        days = end.day - mid.day;\n      } else if (sign < 0) {\n        // 2) end is previous month from intermediate (negative duration)\n        // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n        days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n      } else {\n        // 3) end is next month from intermediate (positive duration)\n        // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n        days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n      }\n\n      if (largestUnit === 'month') {\n        months += years * 12;\n        years = 0;\n      }\n      return { years, months, weeks: 0, days };\n    }\n    case 'week':\n    case 'day': {\n      let larger, smaller, sign;\n      if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n        smaller = { year: y1, month: m1, day: d1 };\n        larger = { year: y2, month: m2, day: d2 };\n        sign = 1;\n      } else {\n        smaller = { year: y2, month: m2, day: d2 };\n        larger = { year: y1, month: m1, day: d1 };\n        sign = -1;\n      }\n      let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n      for (let year = smaller.year; year < larger.year; ++year) {\n        days += LeapYear(year) ? 366 : 365;\n      }\n      let weeks = 0;\n      if (largestUnit === 'week') {\n        weeks = MathFloor(days / 7);\n        days %= 7;\n      }\n      weeks *= sign;\n      days *= sign;\n      return { years: 0, months: 0, weeks, days };\n    }\n    default:\n      throw new Error('assert not reached');\n  }\n}\n\nfunction DifferenceTime(\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number\n) {\n  let hours = h2 - h1;\n  let minutes = min2 - min1;\n  let seconds = s2 - s1;\n  let milliseconds = ms2 - ms1;\n  let microseconds = µs2 - µs1;\n  let nanoseconds = ns2 - ns1;\n\n  const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n\n  let deltaDays = 0;\n  ({\n    deltaDays,\n    hour: hours,\n    minute: minutes,\n    second: seconds,\n    millisecond: milliseconds,\n    microsecond: microseconds,\n    nanosecond: nanoseconds\n  } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n\n  if (deltaDays != 0) throw new Error('assertion failure in DifferenceTime: _bt_.[[Days]] should be 0');\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n\n  return { hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction DifferenceInstant(\n  ns1: JSBI,\n  ns2: JSBI,\n  increment: number,\n  smallestUnit: keyof typeof nsPerTimeUnit,\n  largestUnit: keyof typeof nsPerTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  const diff = JSBI.subtract(ns2, ns1);\n\n  let hours = 0;\n  let minutes = 0;\n  let nanoseconds = JSBI.toNumber(JSBI.remainder(diff, THOUSAND));\n  let microseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(diff, THOUSAND), THOUSAND));\n  let milliseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(diff, MILLION), THOUSAND));\n  let seconds = JSBI.toNumber(JSBI.divide(diff, BILLION));\n\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    increment,\n    smallestUnit,\n    roundingMode\n  ));\n  return BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit);\n}\n\nfunction DifferenceISODateTime(\n  y1Param: number,\n  mon1Param: number,\n  d1Param: number,\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  y2: number,\n  mon2: number,\n  d2: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number,\n  calendar: CalendarSlot,\n  largestUnit: Temporal.DateTimeUnit,\n  options: Temporal.DifferenceOptions<Temporal.DateTimeUnit> | undefined\n) {\n  let y1 = y1Param;\n  let mon1 = mon1Param;\n  let d1 = d1Param;\n\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(\n    h1,\n    min1,\n    s1,\n    ms1,\n    µs1,\n    ns1,\n    h2,\n    min2,\n    s2,\n    ms2,\n    µs2,\n    ns2\n  );\n\n  const timeSign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n  if (dateSign === -timeSign) {\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      -timeSign,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      largestUnit\n    ));\n  }\n\n  const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n  const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n  const untilOptions = CopyOptions(options);\n  untilOptions.largestUnit = dateLargestUnit;\n  // TODO untilOptions doesn't want to compile as it seems that smallestUnit is not clamped?\n  // Type 'SmallestUnit<DateTimeUnit> | undefined' is not assignable to type\n  //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.\n  // Type '\"hour\"' is not assignable to type\n  //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.ts(2345)\n  let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions as any);\n  // Signs of date part and time part may not agree; balance them together\n  ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    largestUnit\n  ));\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction DifferenceZonedDateTime(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot,\n  largestUnit: Temporal.DateTimeUnit,\n  options: Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n) {\n  const nsDiff = JSBI.subtract(ns2, ns1);\n  if (JSBI.equal(nsDiff, ZERO)) {\n    return {\n      years: 0,\n      months: 0,\n      weeks: 0,\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0,\n      microseconds: 0,\n      nanoseconds: 0\n    };\n  }\n\n  // Find the difference in dates only.\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const start = new TemporalInstant(ns1);\n  const end = new TemporalInstant(ns2);\n  const dtStart = GetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = GetPlainDateTimeFor(timeZone, end, calendar);\n  let { years, months, weeks, days } = DifferenceISODateTime(\n    GetSlot(dtStart, ISO_YEAR),\n    GetSlot(dtStart, ISO_MONTH),\n    GetSlot(dtStart, ISO_DAY),\n    GetSlot(dtStart, ISO_HOUR),\n    GetSlot(dtStart, ISO_MINUTE),\n    GetSlot(dtStart, ISO_SECOND),\n    GetSlot(dtStart, ISO_MILLISECOND),\n    GetSlot(dtStart, ISO_MICROSECOND),\n    GetSlot(dtStart, ISO_NANOSECOND),\n    GetSlot(dtEnd, ISO_YEAR),\n    GetSlot(dtEnd, ISO_MONTH),\n    GetSlot(dtEnd, ISO_DAY),\n    GetSlot(dtEnd, ISO_HOUR),\n    GetSlot(dtEnd, ISO_MINUTE),\n    GetSlot(dtEnd, ISO_SECOND),\n    GetSlot(dtEnd, ISO_MILLISECOND),\n    GetSlot(dtEnd, ISO_MICROSECOND),\n    GetSlot(dtEnd, ISO_NANOSECOND),\n    calendar,\n    largestUnit,\n    options\n  );\n  const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n  // may disambiguate\n  let timeRemainderNs = JSBI.subtract(ns2, intermediateNs);\n  const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n  ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n\n  // Finally, merge the date and time durations and return the merged result.\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    JSBI.toNumber(timeRemainderNs),\n    'hour'\n  );\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\ntype DifferenceOperation = 'since' | 'until';\n\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\n  op: DifferenceOperation,\n  options: Temporal.DifferenceOptions<T>,\n  group: 'datetime' | 'date' | 'time',\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\n  fallbackSmallest: T,\n  smallestLargestDefaultUnit: T\n) {\n  const ALLOWED_UNITS = SINGULAR_PLURAL_UNITS.reduce((allowed, unitInfo) => {\n    const p = unitInfo[0];\n    const s = unitInfo[1];\n    const c = unitInfo[2];\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\n      allowed.push(s, p);\n    }\n    return allowed;\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\n\n  let largestUnit = GetTemporalUnit(options, 'largestUnit', group, 'auto');\n  if (disallowed.includes(largestUnit)) {\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\n  }\n\n  const roundingIncrement = ToTemporalRoundingIncrement(options);\n\n  let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n  if (op === 'since') roundingMode = NegateTemporalRoundingMode(roundingMode);\n\n  const smallestUnit = GetTemporalUnit(options, 'smallestUnit', group, fallbackSmallest);\n  if (disallowed.includes(smallestUnit)) {\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\n  }\n\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n  }\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n  };\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\n}\n\nexport function DifferenceTemporalInstant(\n  operation: DifferenceOperation,\n  instant: Temporal.Instant,\n  otherParam: InstantParams['until'][0],\n  options: InstantParams['until'][1] | undefined\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalInstant(otherParam);\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\n\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n    onens,\n    twons,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.largestUnit,\n    settings.roundingMode\n  );\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    0,\n    0,\n    0,\n    0,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainDate(\n  operation: DifferenceOperation,\n  plainDate: Temporal.PlainDate,\n  otherParam: PlainDateParams['until'][0],\n  options: PlainDateParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalDate(otherParam);\n  const calendar = GetSlot(plainDate, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  let { years, months, weeks, days } = CalendarDateUntil(calendar, plainDate, other, resolvedOptions);\n\n  if (settings.smallestUnit !== 'day' || settings.roundingIncrement !== 1) {\n    ({ years, months, weeks, days } = RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      plainDate\n    ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(sign * years, sign * months, sign * weeks, sign * days, 0, 0, 0, 0, 0, 0);\n}\n\nexport function DifferenceTemporalPlainDateTime(\n  operation: DifferenceOperation,\n  plainDateTime: Temporal.PlainDateTime,\n  otherParam: PlainDateTimeParams['until'][0],\n  options: PlainDateTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalDateTime(otherParam);\n  const calendar = GetSlot(plainDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\n\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    DifferenceISODateTime(\n      GetSlot(plainDateTime, ISO_YEAR),\n      GetSlot(plainDateTime, ISO_MONTH),\n      GetSlot(plainDateTime, ISO_DAY),\n      GetSlot(plainDateTime, ISO_HOUR),\n      GetSlot(plainDateTime, ISO_MINUTE),\n      GetSlot(plainDateTime, ISO_SECOND),\n      GetSlot(plainDateTime, ISO_MILLISECOND),\n      GetSlot(plainDateTime, ISO_MICROSECOND),\n      GetSlot(plainDateTime, ISO_NANOSECOND),\n      GetSlot(other, ISO_YEAR),\n      GetSlot(other, ISO_MONTH),\n      GetSlot(other, ISO_DAY),\n      GetSlot(other, ISO_HOUR),\n      GetSlot(other, ISO_MINUTE),\n      GetSlot(other, ISO_SECOND),\n      GetSlot(other, ISO_MILLISECOND),\n      GetSlot(other, ISO_MICROSECOND),\n      GetSlot(other, ISO_NANOSECOND),\n      calendar,\n      settings.largestUnit,\n      resolvedOptions\n    );\n\n  const relativeTo = TemporalDateTimeToDate(plainDateTime);\n  ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode,\n    relativeTo\n  ));\n  ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.largestUnit\n  ));\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainTime(\n  operation: DifferenceOperation,\n  plainTime: Temporal.PlainTime,\n  otherParam: PlainTimeParams['until'][0],\n  options: PlainTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalTime(otherParam);\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\n\n  let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(\n    GetSlot(plainTime, ISO_HOUR),\n    GetSlot(plainTime, ISO_MINUTE),\n    GetSlot(plainTime, ISO_SECOND),\n    GetSlot(plainTime, ISO_MILLISECOND),\n    GetSlot(plainTime, ISO_MICROSECOND),\n    GetSlot(plainTime, ISO_NANOSECOND),\n    GetSlot(other, ISO_HOUR),\n    GetSlot(other, ISO_MINUTE),\n    GetSlot(other, ISO_SECOND),\n    GetSlot(other, ISO_MILLISECOND),\n    GetSlot(other, ISO_MICROSECOND),\n    GetSlot(other, ISO_NANOSECOND)\n  );\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n    0,\n    0,\n    0,\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  ));\n  ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    settings.largestUnit\n  ));\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    0,\n    0,\n    0,\n    0,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function DifferenceTemporalPlainYearMonth(\n  operation: DifferenceOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  otherParam: PlainYearMonthParams['until'][0],\n  options: PlainYearMonthParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalYearMonth(otherParam);\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between months');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  const fieldNames = CalendarFields(calendar, ['monthCode', 'year']) as AnyTemporalKey[];\n  const thisFields = PrepareTemporalFields(yearMonth, fieldNames, []);\n  thisFields.day = 1;\n  const thisDate = CalendarDateFromFields(calendar, thisFields);\n  const otherFields = PrepareTemporalFields(other, fieldNames, []);\n  otherFields.day = 1;\n  const otherDate = CalendarDateFromFields(calendar, otherFields);\n\n  let { years, months } = CalendarDateUntil(calendar, thisDate, otherDate, resolvedOptions);\n\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\n    ({ years, months } = RoundDuration(\n      years,\n      months,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      thisDate\n    ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(sign * years, sign * months, 0, 0, 0, 0, 0, 0, 0, 0);\n}\n\nexport function DifferenceTemporalZonedDateTime(\n  operation: DifferenceOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  otherParam: ZonedDateTimeParams['until'][0],\n  options: ZonedDateTimeParams['until'][1]\n): Temporal.Duration {\n  const sign = operation === 'since' ? -1 : 1;\n  const other = ToTemporalZonedDateTime(otherParam);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  ThrowIfCalendarsNotEqual(calendar, otherCalendar, 'compute difference between dates');\n\n  const resolvedOptions = CopyOptions(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\n  resolvedOptions.largestUnit = settings.largestUnit;\n\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n  if (\n    settings.largestUnit !== 'year' &&\n    settings.largestUnit !== 'month' &&\n    settings.largestUnit !== 'week' &&\n    settings.largestUnit !== 'day'\n  ) {\n    // The user is only asking for a time difference, so return difference of instants.\n    years = 0;\n    months = 0;\n    weeks = 0;\n    days = 0;\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n      ns1,\n      ns2,\n      settings.roundingIncrement,\n      settings.smallestUnit as Temporal.TimeUnit,\n      settings.largestUnit as Temporal.TimeUnit,\n      settings.roundingMode\n    ));\n  } else {\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n      throw new RangeError(\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\n      );\n    }\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, settings.largestUnit, resolvedOptions));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode,\n      zonedDateTime\n    ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      AdjustRoundedDurationDays(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        settings.roundingIncrement,\n        settings.smallestUnit,\n        settings.roundingMode,\n        zonedDateTime\n      ));\n  }\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function AddISODate(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  overflow: Temporal.ArithmeticOptions['overflow']\n) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n\n  year += years;\n  month += months;\n  ({ year, month } = BalanceISOYearMonth(year, month));\n  ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n  days += 7 * weeks;\n  day += days;\n  ({ year, month, day } = BalanceISODate(year, month, day));\n  return { year, month, day };\n}\n\nfunction AddTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  hour += hours;\n  minute += minutes;\n  second += seconds;\n  millisecond += milliseconds;\n  microsecond += microseconds;\n  nanosecond += nanoseconds;\n  let deltaDays = 0;\n  ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  ));\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nfunction AddDuration(\n  y1: number,\n  mon1: number,\n  w1: number,\n  d1: number,\n  h1: number,\n  min1: number,\n  s1: number,\n  ms1: number,\n  µs1: number,\n  ns1: number,\n  y2: number,\n  mon2: number,\n  w2: number,\n  d2: number,\n  h2: number,\n  min2: number,\n  s2: number,\n  ms2: number,\n  µs2: number,\n  ns2: number,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>\n) {\n  const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n  const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n  if (!relativeTo) {\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n      throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n    }\n    years = months = weeks = 0;\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      d1 + d2,\n      JSBI.add(JSBI.BigInt(h1), JSBI.BigInt(h2)),\n      JSBI.add(JSBI.BigInt(min1), JSBI.BigInt(min2)),\n      JSBI.add(JSBI.BigInt(s1), JSBI.BigInt(s2)),\n      JSBI.add(JSBI.BigInt(ms1), JSBI.BigInt(ms2)),\n      JSBI.add(JSBI.BigInt(µs1), JSBI.BigInt(µs2)),\n      JSBI.add(JSBI.BigInt(ns1), JSBI.BigInt(ns2)),\n      largestUnit\n    ));\n  } else if (IsTemporalDate(relativeTo)) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const calendar = GetSlot(relativeTo, CALENDAR);\n\n    const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n    const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n    const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n    const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, undefined, dateAdd);\n    const end = CalendarDateAdd(calendar, intermediate, dateDuration2, undefined, dateAdd);\n\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\n    const differenceOptions = ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateUnit>;\n    differenceOptions.largestUnit = dateLargestUnit;\n    ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      days,\n      JSBI.add(JSBI.BigInt(h1), JSBI.BigInt(h2)),\n      JSBI.add(JSBI.BigInt(min1), JSBI.BigInt(min2)),\n      JSBI.add(JSBI.BigInt(s1), JSBI.BigInt(s2)),\n      JSBI.add(JSBI.BigInt(ms1), JSBI.BigInt(ms2)),\n      JSBI.add(JSBI.BigInt(µs1), JSBI.BigInt(µs2)),\n      JSBI.add(JSBI.BigInt(ns1), JSBI.BigInt(ns2)),\n      largestUnit\n    ));\n  } else {\n    // relativeTo is a ZonedDateTime\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(\n      GetSlot(relativeTo, INSTANT),\n      timeZone,\n      calendar,\n      y1,\n      mon1,\n      w1,\n      d1,\n      h1,\n      min1,\n      s1,\n      ms1,\n      µs1,\n      ns1\n    );\n    const endNs = AddZonedDateTime(\n      new TemporalInstant(intermediateNs),\n      timeZone,\n      calendar,\n      y2,\n      mon2,\n      w2,\n      d2,\n      h2,\n      min2,\n      s2,\n      ms2,\n      µs2,\n      ns2\n    );\n    if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n      // The user is only asking for a time difference, so return difference of instants.\n      years = 0;\n      months = 0;\n      weeks = 0;\n      days = 0;\n      ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(\n        GetSlot(relativeTo, EPOCHNANOSECONDS),\n        endNs,\n        1,\n        'nanosecond',\n        largestUnit,\n        'halfExpand'\n      ));\n    } else {\n      ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n        DifferenceZonedDateTime(\n          GetSlot(relativeTo, EPOCHNANOSECONDS),\n          endNs,\n          timeZone,\n          calendar,\n          largestUnit,\n          ObjectCreate(null) as Temporal.DifferenceOptions<Temporal.DateTimeUnit>\n        ));\n    }\n  }\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction AddInstant(\n  epochNanoseconds: JSBI,\n  h: number | JSBI,\n  min: number | JSBI,\n  s: number | JSBI,\n  ms: number | JSBI,\n  µs: number | JSBI,\n  ns: number | JSBI\n) {\n  let sum = ZERO;\n  sum = JSBI.add(sum, JSBI.BigInt(ns));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(µs), THOUSAND));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(ms), MILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(s), BILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(min), JSBI.BigInt(60 * 1e9)));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(60 * 60 * 1e9)));\n\n  const result = JSBI.add(epochNanoseconds, sum);\n  ValidateEpochNanoseconds(result);\n  return result;\n}\n\nfunction AddDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  calendar: CalendarSlot,\n  years: number,\n  months: number,\n  weeks: number,\n  daysParam: number,\n  hours: number,\n  minutes: number,\n  seconds: number,\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number,\n  options?: Temporal.ArithmeticOptions\n) {\n  let days = daysParam;\n  // Add the time part\n  let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n  days += deltaDays;\n\n  // Delegate the date part addition to the calendar\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const datePart = CreateTemporalDate(year, month, day, calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n\n  return {\n    year: GetSlot(addedDate, ISO_YEAR),\n    month: GetSlot(addedDate, ISO_MONTH),\n    day: GetSlot(addedDate, ISO_DAY),\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nexport function AddZonedDateTime(\n  instant: Temporal.Instant,\n  timeZone: string | Temporal.TimeZoneProtocol,\n  calendar: CalendarSlot,\n  years: number,\n  months: number,\n  weeks: number,\n  days: number,\n  h: number | JSBI,\n  min: number | JSBI,\n  s: number | JSBI,\n  ms: number | JSBI,\n  µs: number | JSBI,\n  ns: number | JSBI,\n  options?: Temporal.ArithmeticOptions\n) {\n  // If only time is to be added, then use Instant math. It's not OK to fall\n  // through to the date/time code below because compatible disambiguation in\n  // the PlainDateTime=>Instant conversion will change the offset of any\n  // ZonedDateTime in the repeated clock time after a backwards transition.\n  // When adding/subtracting time units and not dates, this disambiguation is\n  // not expected and so is avoided below via a fast path for time-only\n  // arithmetic.\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n    return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n  }\n\n  // RFC 5545 requires the date portion to be added in calendar days and the\n  // time portion to be added in exact time.\n  const dt = GetPlainDateTimeFor(timeZone, instant, calendar);\n  const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n  const dtIntermediate = CreateTemporalDateTime(\n    GetSlot(addedDate, ISO_YEAR),\n    GetSlot(addedDate, ISO_MONTH),\n    GetSlot(addedDate, ISO_DAY),\n    GetSlot(dt, ISO_HOUR),\n    GetSlot(dt, ISO_MINUTE),\n    GetSlot(dt, ISO_SECOND),\n    GetSlot(dt, ISO_MILLISECOND),\n    GetSlot(dt, ISO_MICROSECOND),\n    GetSlot(dt, ISO_NANOSECOND),\n    calendar\n  );\n\n  // Note that 'compatible' is used below because this disambiguation behavior\n  // is required by RFC 5545.\n  const instantIntermediate = GetInstantFor(timeZone, dtIntermediate, 'compatible');\n  return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n}\n\ntype AddSubtractOperation = 'add' | 'subtract';\n\nexport function AddDurationToOrSubtractDurationFromDuration(\n  operation: AddSubtractOperation,\n  duration: Temporal.Duration,\n  other: DurationParams['add'][0],\n  optionsParam: DurationParams['add'][1]\n): Temporal.Duration {\n  const sign = operation === 'subtract' ? -1 : 1;\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(other);\n  const options = GetOptionsObject(optionsParam);\n  const relativeTo = ToRelativeTemporalObject(options);\n  ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(\n    GetSlot(duration, YEARS),\n    GetSlot(duration, MONTHS),\n    GetSlot(duration, WEEKS),\n    GetSlot(duration, DAYS),\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS),\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    relativeTo\n  ));\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\n\nexport function AddDurationToOrSubtractDurationFromInstant(\n  operation: AddSubtractOperation,\n  instant: Temporal.Instant,\n  durationLike: InstantParams['add'][0]\n): Temporal.Instant {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(durationLike, [\n    'years',\n    'months',\n    'weeks',\n    'days'\n  ]);\n  const ns = AddInstant(\n    GetSlot(instant, EPOCHNANOSECONDS),\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  return new Instant(ns);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainDateTime(\n  operation: AddSubtractOperation,\n  dateTime: Temporal.PlainDateTime,\n  durationLike: PlainDateTimeParams['add'][0],\n  optionsParam: PlainDateTimeParams['add'][1]\n): Temporal.PlainDateTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(durationLike);\n  const options = GetOptionsObject(optionsParam);\n  const calendar = GetSlot(dateTime, CALENDAR);\n  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(\n    GetSlot(dateTime, ISO_YEAR),\n    GetSlot(dateTime, ISO_MONTH),\n    GetSlot(dateTime, ISO_DAY),\n    GetSlot(dateTime, ISO_HOUR),\n    GetSlot(dateTime, ISO_MINUTE),\n    GetSlot(dateTime, ISO_SECOND),\n    GetSlot(dateTime, ISO_MILLISECOND),\n    GetSlot(dateTime, ISO_MICROSECOND),\n    GetSlot(dateTime, ISO_NANOSECOND),\n    calendar,\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    options\n  );\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainTime(\n  operation: AddSubtractOperation,\n  temporalTime: Temporal.PlainTime,\n  durationLike: PlainTimeParams['add'][0]\n): Temporal.PlainTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(durationLike);\n  let { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    GetSlot(temporalTime, ISO_HOUR),\n    GetSlot(temporalTime, ISO_MINUTE),\n    GetSlot(temporalTime, ISO_SECOND),\n    GetSlot(temporalTime, ISO_MILLISECOND),\n    GetSlot(temporalTime, ISO_MICROSECOND),\n    GetSlot(temporalTime, ISO_NANOSECOND),\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n  ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    'reject'\n  ));\n  const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function AddDurationToOrSubtractDurationFromPlainYearMonth(\n  operation: AddSubtractOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  durationLike: PlainYearMonthParams['add'][0],\n  optionsParam: PlainYearMonthParams['add'][1]\n): Temporal.PlainYearMonth {\n  let duration = ToTemporalDurationRecord(durationLike);\n  if (operation === 'subtract') {\n    duration = {\n      years: -duration.years,\n      months: -duration.months,\n      weeks: -duration.weeks,\n      days: -duration.days,\n      hours: -duration.hours,\n      minutes: -duration.minutes,\n      seconds: -duration.seconds,\n      milliseconds: -duration.milliseconds,\n      microseconds: -duration.microseconds,\n      nanoseconds: -duration.nanoseconds\n    };\n  }\n  let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n  ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n\n  const options = GetOptionsObject(optionsParam);\n\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const fieldNames = CalendarFields(calendar, ['monthCode', 'year'] as const);\n  const fields = PrepareTemporalFields(yearMonth, fieldNames, []);\n  const fieldsCopy = ObjectCreate(null);\n  CopyDataProperties(fieldsCopy, fields, []);\n  fields.day = 1;\n  // PrepareTemporalFields returns a type where 'day' is potentially undefined,\n  // but TS doesn't narrow the type as a result of the assignment above.\n  uncheckedAssertNarrowedType<typeof fields & { day: number }>(fields, '`day` is guaranteed to be non-undefined');\n  let startDate = CalendarDateFromFields(calendar, fields);\n  const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const dateAdd = GetMethod(calendar, 'dateAdd');\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  if (sign < 0) {\n    const oneMonthDuration = new Duration(0, 1, 0, 0, 0, 0, 0, 0, 0, 0);\n    const nextMonth = CalendarDateAdd(calendar, startDate, oneMonthDuration, undefined, dateAdd);\n    const minusDayDuration = new Duration(0, 0, 0, -1, 0, 0, 0, 0, 0, 0);\n    const endOfMonth = CalendarDateAdd(calendar, nextMonth, minusDayDuration, undefined, dateAdd);\n    fieldsCopy.day = CalendarDay(calendar, endOfMonth);\n    startDate = CalendarDateFromFields(calendar, fieldsCopy);\n  }\n  const durationToAdd = new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const optionsCopy = CopyOptions(options);\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, options, dateAdd);\n  const addedDateFields = PrepareTemporalFields(addedDate, fieldNames, []);\n\n  return CalendarYearMonthFromFields(calendar, addedDateFields, optionsCopy);\n}\n\nexport function AddDurationToOrSubtractDurationFromZonedDateTime(\n  operation: AddSubtractOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  durationLike: ZonedDateTimeParams['add'][0],\n  optionsParam: ZonedDateTimeParams['add'][1]\n): Temporal.ZonedDateTime {\n  const sign = operation === 'subtract' ? -1 : 1;\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ToTemporalDurationRecord(durationLike);\n  const options = GetOptionsObject(optionsParam);\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const epochNanoseconds = AddZonedDateTime(\n    GetSlot(zonedDateTime, INSTANT),\n    timeZone,\n    calendar,\n    sign * years,\n    sign * months,\n    sign * weeks,\n    sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds,\n    options\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nfunction RoundNumberToIncrement(quantity: JSBI, increment: JSBI, mode: Temporal.RoundingMode) {\n  if (JSBI.equal(increment, ONE)) return quantity;\n  let { quotient, remainder } = divmod(quantity, increment);\n  if (JSBI.equal(remainder, ZERO)) return quantity;\n  const sign = JSBI.lessThan(remainder, ZERO) ? -1 : 1;\n  const tiebreaker = abs(JSBI.multiply(remainder, JSBI.BigInt(2)));\n  const tie = JSBI.equal(tiebreaker, increment);\n  const expandIsNearer = JSBI.greaterThan(tiebreaker, increment);\n  switch (mode) {\n    case 'ceil':\n      if (sign > 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'floor':\n      if (sign < 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'expand':\n      // always expand if there is a remainder\n      quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n    case 'trunc':\n      // no change needed, because divmod is a truncation\n      break;\n    case 'halfCeil':\n      if (expandIsNearer || (tie && sign > 0)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfFloor':\n      if (expandIsNearer || (tie && sign < 0)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfExpand':\n      // \"half up away from zero\"\n      if (expandIsNearer || tie) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfTrunc':\n      if (expandIsNearer) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n    case 'halfEven':\n      if (expandIsNearer || (tie && JSBI.toNumber(JSBI.remainder(abs(quotient), JSBI.BigInt(2))) === 1)) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n      break;\n  }\n  return JSBI.multiply(quotient, increment);\n}\n\nexport function RoundInstant(\n  epochNs: JSBI,\n  increment: number,\n  unit: keyof typeof nsPerTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  let { remainder } = NonNegativeBigIntDivmod(epochNs, DAY_NANOS);\n  const wholeDays = JSBI.subtract(epochNs, remainder);\n  const roundedRemainder = RoundNumberToIncrement(\n    remainder,\n    JSBI.BigInt(nsPerTimeUnit[unit] * increment),\n    roundingMode\n  );\n  return JSBI.add(wholeDays, roundedRemainder);\n}\n\nexport function RoundISODateTime(\n  yearParam: number,\n  monthParam: number,\n  dayParam: number,\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  increment: number,\n  unit: UnitSmallerThanOrEqualTo<'day'>,\n  roundingMode: Temporal.RoundingMode,\n  dayLengthNs = 86400e9\n) {\n  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(\n    hourParam,\n    minuteParam,\n    secondParam,\n    millisecondParam,\n    microsecondParam,\n    nanosecondParam,\n    increment,\n    unit,\n    roundingMode,\n    dayLengthNs\n  );\n  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function RoundTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number,\n  increment: number,\n  unit: keyof typeof nsPerTimeUnit | 'day',\n  roundingMode: Temporal.RoundingMode,\n  dayLengthNs = 86400e9\n) {\n  let quantity = ZERO;\n  switch (unit) {\n    case 'day':\n    case 'hour':\n      quantity = JSBI.BigInt(hour);\n    // fall through\n    case 'minute':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(minute));\n    // fall through\n    case 'second':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(second));\n    // fall through\n    case 'millisecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(millisecond));\n    // fall through\n    case 'microsecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(microsecond));\n    // fall through\n    case 'nanosecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(nanosecond));\n  }\n  const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n  const rounded = RoundNumberToIncrement(quantity, JSBI.BigInt(nsPerUnit * increment), roundingMode);\n  const result = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(nsPerUnit)));\n  switch (unit) {\n    case 'day':\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n    case 'hour':\n      return BalanceTime(result, 0, 0, 0, 0, 0);\n    case 'minute':\n      return BalanceTime(hour, result, 0, 0, 0, 0);\n    case 'second':\n      return BalanceTime(hour, minute, result, 0, 0, 0);\n    case 'millisecond':\n      return BalanceTime(hour, minute, second, result, 0, 0);\n    case 'microsecond':\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\n    case 'nanosecond':\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n    default:\n      throw new Error(`Invalid unit ${unit}`);\n  }\n}\n\nfunction DaysUntil(\n  earlier: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.ZonedDateTime,\n  later: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.ZonedDateTime\n) {\n  return DifferenceISODate(\n    GetSlot(earlier, ISO_YEAR),\n    GetSlot(earlier, ISO_MONTH),\n    GetSlot(earlier, ISO_DAY),\n    GetSlot(later, ISO_YEAR),\n    GetSlot(later, ISO_MONTH),\n    GetSlot(later, ISO_DAY),\n    'day'\n  ).days;\n}\n\nfunction MoveRelativeDate(\n  calendar: CalendarSlot,\n  relativeToParam: NonNullable<ReturnType<typeof ToRelativeTemporalObject>>,\n  duration: Temporal.Duration,\n  dateAdd: Temporal.CalendarProtocol['dateAdd'] | undefined\n) {\n  const later = CalendarDateAdd(calendar, relativeToParam, duration, undefined, dateAdd);\n  const days = DaysUntil(relativeToParam, later);\n  return { relativeTo: later, days };\n}\n\nexport function MoveRelativeZonedDateTime(\n  relativeTo: Temporal.ZonedDateTime,\n  years: number,\n  months: number,\n  weeks: number,\n  days: number\n) {\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const intermediateNs = AddZonedDateTime(\n    GetSlot(relativeTo, INSTANT),\n    timeZone,\n    calendar,\n    years,\n    months,\n    weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\n\nexport function AdjustRoundedDurationDays(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  hoursParam: number,\n  minutesParam: number,\n  secondsParam: number,\n  millisecondsParam: number,\n  microsecondsParam: number,\n  nanosecondsParam: number,\n  increment: number,\n  unit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode,\n  relativeTo: ReturnType<typeof ToRelativeTemporalObject>\n) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = nanosecondsParam;\n  if (\n    !IsTemporalZonedDateTime(relativeTo) ||\n    unit === 'year' ||\n    unit === 'month' ||\n    unit === 'week' ||\n    unit === 'day' ||\n    (unit === 'nanosecond' && increment === 1)\n  ) {\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n  }\n\n  // There's one more round of rounding possible: if relativeTo is a\n  // ZonedDateTime, the time units could have rounded up into enough hours\n  // to exceed the day length. If this happens, grow the date part by a\n  // single day and re-run exact time rounding on the smaller remainder. DO\n  // NOT RECURSE, because once the extra hours are sucked up into the date\n  // duration, there's no way for another full day to come from the next\n  // round of rounding. And if it were possible (e.g. contrived calendar\n  // with 30-minute-long \"days\") then it'd risk an infinite loop.\n  let timeRemainderNs = TotalDurationNanoseconds(\n    0,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds,\n    0\n  );\n  const direction = MathSign(JSBI.toNumber(timeRemainderNs));\n\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const dayStart = AddZonedDateTime(\n    GetSlot(relativeTo, INSTANT),\n    timeZone,\n    calendar,\n    years,\n    months,\n    weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const dayEnd = AddZonedDateTime(\n    new TemporalInstant(dayStart),\n    timeZone,\n    calendar,\n    0,\n    0,\n    0,\n    direction,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  const dayLengthNs = JSBI.subtract(dayEnd, dayStart);\n\n  if (\n    JSBI.greaterThanOrEqual(JSBI.multiply(JSBI.subtract(timeRemainderNs, dayLengthNs), JSBI.BigInt(direction)), ZERO)\n  ) {\n    ({ years, months, weeks, days } = AddDuration(\n      years,\n      months,\n      weeks,\n      days,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      direction,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      relativeTo\n    ));\n    timeRemainderNs = RoundInstant(JSBI.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      JSBI.toNumber(timeRemainderNs),\n      'hour'\n    ));\n  }\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nexport function RoundDuration(\n  yearsParam: number,\n  monthsParam: number,\n  weeksParam: number,\n  daysParam: number,\n  hoursParam: number,\n  minutesParam: number,\n  secondsParam: number,\n  millisecondsParam: number,\n  microsecondsParam: number,\n  nanosecondsParam: number,\n  increment: number,\n  unit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode,\n  relativeToParam: ReturnType<typeof ToRelativeTemporalObject> = undefined\n) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  let calendar, zdtRelative;\n  // A cast is used below because relativeTo will be either PlainDate or\n  // undefined for the rest of this long method (after any ZDT=>PlainDate\n  // conversion below), and TS isn't smart enough to know that the type has\n  // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n  let relativeTo = relativeToParam as Temporal.PlainDate | undefined;\n  if (relativeTo) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      zdtRelative = relativeTo;\n      relativeTo = ToTemporalDate(relativeTo);\n    } else if (!IsTemporalDate(relativeTo)) {\n      throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n    }\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  // First convert time units up to days, if rounding to days or higher units.\n  // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n  // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n  // larger. We'll cast away `undefined` when it's used lower down below.\n  let dayLengthNs: JSBI | undefined;\n  if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n    nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n    let intermediate;\n    if (zdtRelative) {\n      intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n    }\n    let deltaDays;\n    let dayLength: number;\n    ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n    dayLengthNs = JSBI.BigInt(dayLength);\n    days += deltaDays;\n    hours = minutes = seconds = milliseconds = microseconds = 0;\n  }\n\n  let total: number;\n  switch (unit) {\n    case 'year': {\n      if (!calendar) throw new RangeError('A starting point is required for years rounding');\n      assertExists(relativeTo);\n\n      // convert months and weeks to days by calculating difference(\n      // relativeTo + years, relativeTo + { years, months, weeks })\n      const yearsDuration = new TemporalDuration(years);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, undefined, dateAdd);\n      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n      const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n      const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n      relativeTo = yearsLater;\n      days += monthsWeeksInDays;\n\n      const wholeDays = new TemporalDuration(0, 0, 0, days);\n      const wholeDaysLater = CalendarDateAdd(calendar, relativeTo, wholeDays, undefined, dateAdd);\n      const untilOptions = ObjectCreate(null) as Temporal.DifferenceOptions<typeof unit>;\n      untilOptions.largestUnit = 'year';\n      const yearsPassed = CalendarDateUntil(calendar, relativeTo, wholeDaysLater, untilOptions).years;\n      years += yearsPassed;\n      const oldRelativeTo = relativeTo;\n      const yearsPassedDuration = new TemporalDuration(yearsPassed);\n      relativeTo = CalendarDateAdd(calendar, relativeTo, yearsPassedDuration, undefined, dateAdd);\n      const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n      days -= daysPassed;\n      const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n      let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear, dateAdd);\n\n      // Note that `nanoseconds` below (here and in similar code for months,\n      // weeks, and days further below) isn't actually nanoseconds for the\n      // full date range.  Instead, it's a BigInt representation of total\n      // days multiplied by the number of nanoseconds in the last day of\n      // the duration. This lets us do days-or-larger rounding using BigInt\n      // math which reduces precision loss.\n      oneYearDays = MathAbs(oneYearDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneYearDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(years)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      years = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      months = weeks = days = 0;\n      break;\n    }\n    case 'month': {\n      if (!calendar) throw new RangeError('A starting point is required for months rounding');\n      assertExists(relativeTo);\n\n      // convert weeks to days by calculating difference(relativeTo +\n      //   { years, months }, relativeTo + { years, months, weeks })\n      const yearsMonths = new TemporalDuration(years, months);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, undefined, dateAdd);\n      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n      const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n      const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n      relativeTo = yearsMonthsLater;\n      days += weeksInDays;\n\n      // Months may be different lengths of days depending on the calendar,\n      // convert days to months in a loop as described above under 'years'.\n      const sign = MathSign(days);\n      const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n      let oneMonthDays: number;\n      ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n        months += sign;\n        days -= oneMonthDays;\n        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth, dateAdd));\n      }\n      oneMonthDays = MathAbs(oneMonthDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneMonthDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(months)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      months = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      weeks = days = 0;\n      break;\n    }\n    case 'week': {\n      if (!calendar) throw new RangeError('A starting point is required for weeks rounding');\n      assertExists(relativeTo);\n\n      // Weeks may be different lengths of days depending on the calendar,\n      // convert days to weeks in a loop as described above under 'years'.\n      const sign = MathSign(days);\n      const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n      const dateAdd = typeof calendar !== 'string' ? GetMethod(calendar, 'dateAdd') : undefined;\n      let oneWeekDays;\n      ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n        weeks += sign;\n        days -= oneWeekDays;\n        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek, dateAdd));\n      }\n      oneWeekDays = MathAbs(oneWeekDays);\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = JSBI.multiply(JSBI.BigInt(oneWeekDays), dayLengthNs);\n      nanoseconds = JSBI.add(\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(weeks)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)),\n        nanoseconds\n      );\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      weeks = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      days = 0;\n      break;\n    }\n    case 'day': {\n      // dayLengthNs is never undefined if unit is `day` or larger.\n      assertExists(dayLengthNs);\n      const divisor = dayLengthNs;\n      nanoseconds = JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(days)), nanoseconds);\n      const rounded = RoundNumberToIncrement(nanoseconds, JSBI.multiply(divisor, JSBI.BigInt(increment)), roundingMode);\n      total = BigIntDivideToNumber(nanoseconds, divisor);\n      days = JSBI.toNumber(JSBI.divide(rounded, divisor));\n      nanoseconds = ZERO;\n      break;\n    }\n    case 'hour': {\n      const divisor = 3600e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(hours), JSBI.BigInt(3600e9));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9)));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      hours = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      minutes = seconds = milliseconds = microseconds = 0;\n      break;\n    }\n    case 'minute': {\n      const divisor = 60e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      minutes = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      seconds = milliseconds = microseconds = 0;\n      break;\n    }\n    case 'second': {\n      const divisor = 1e9;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(seconds), BILLION);\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      seconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      milliseconds = microseconds = 0;\n      break;\n    }\n    case 'millisecond': {\n      const divisor = 1e6;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(milliseconds), MILLION);\n      allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      milliseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      microseconds = 0;\n      break;\n    }\n    case 'microsecond': {\n      const divisor = 1e3;\n      let allNanoseconds = JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND);\n      allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n      total = BigIntDivideToNumber(allNanoseconds, JSBI.BigInt(divisor));\n      const rounded = RoundNumberToIncrement(allNanoseconds, JSBI.BigInt(divisor * increment), roundingMode);\n      microseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n      nanoseconds = ZERO;\n      break;\n    }\n    case 'nanosecond': {\n      total = JSBI.toNumber(nanoseconds);\n      nanoseconds = RoundNumberToIncrement(JSBI.BigInt(nanoseconds), JSBI.BigInt(increment), roundingMode);\n      break;\n    }\n  }\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds: JSBI.toNumber(nanoseconds),\n    total\n  };\n}\n\nexport function CompareISODate(y1: number, m1: number, d1: number, y2: number, m2: number, d2: number) {\n  for (const [x, y] of [\n    [y1, y2],\n    [m1, m2],\n    [d1, d2]\n  ]) {\n    if (x !== y) return ComparisonResult(x - y);\n  }\n  return 0;\n}\n\n// Not abstract operations from the spec\n\nfunction NonNegativeBigIntDivmod(x: JSBI, y: JSBI) {\n  let { quotient, remainder } = divmod(x, y);\n  if (JSBI.lessThan(remainder, ZERO)) {\n    quotient = JSBI.subtract(quotient, ONE);\n    remainder = JSBI.add(remainder, y);\n  }\n  return { quotient, remainder };\n}\n\nexport function BigIntFloorDiv(left: JSBI, right: JSBI) {\n  const { quotient, remainder } = divmod(left, right);\n  if (!isZero(remainder) && !isNegativeJSBI(left) != !isNegativeJSBI(right)) {\n    return JSBI.subtract(quotient, ONE);\n  }\n  return quotient;\n}\n\n/** Divide two JSBIs, and return the result as a Number, including the remainder. */\nexport function BigIntDivideToNumber(dividend: JSBI, divisor: JSBI) {\n  const { quotient, remainder } = divmod(dividend, divisor);\n  const result = JSBI.toNumber(quotient) + JSBI.toNumber(remainder) / JSBI.toNumber(divisor);\n  return result;\n}\n\n// Defaults to native bigint, or something \"native bigint-like\".\n// For users of Temporal that are running in environments without native BigInt,\n// the only guarantee we should give is that the returned object's toString will\n// return a string containing an accurate base 10 value of this bigint. This\n// form factor should correctly interop with other bigint compat libraries\n// easily.\ntype ExternalBigInt = bigint;\n\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\n  const jsbiBI = ToBigInt(arg);\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\n  return jsbiBI as unknown as ExternalBigInt;\n}\n\nexport function ToBigInt(arg: unknown): JSBI {\n  let prim = arg;\n  if (typeof arg === 'object') {\n    const toPrimFn = (arg as { [Symbol.toPrimitive]: unknown })[Symbol.toPrimitive];\n    if (toPrimFn && typeof toPrimFn === 'function') {\n      prim = ReflectApply(toPrimFn, arg, ['number']);\n    }\n  }\n\n  // The AO ToBigInt throws on numbers because it does not allow implicit\n  // conversion between number and bigint (unlike the bigint constructor).\n  if (typeof prim === 'number') {\n    throw new TypeError('cannot convert number to bigint');\n  }\n  if (typeof prim === 'bigint') {\n    // JSBI doesn't know anything about the bigint type, and intentionally\n    // assumes it doesn't exist. Passing one to the BigInt function will throw\n    // an error.\n    return JSBI.BigInt(prim.toString(10));\n  }\n  // JSBI will properly coerce types into a BigInt the same as the native BigInt\n  // constructor will, with the exception of native bigint which is handled\n  // above.\n  // As of 2023-04-07, the only runtime type that neither of those can handle is\n  // 'symbol', and both native bigint and the JSBI.BigInt function will throw an\n  // error if they are given a Symbol.\n  return JSBI.BigInt(prim as string | boolean | object);\n}\n\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds: () => JSBI = (() => {\n  let ns = JSBI.BigInt(Date.now() % 1e6);\n  return () => {\n    const ms = JSBI.BigInt(Date.now());\n    const result = JSBI.add(JSBI.multiply(ms, MILLION), ns);\n    ns = JSBI.remainder(ms, MILLION);\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\n    return result;\n  };\n})();\n\nexport function DefaultTimeZone() {\n  return new IntlDateTimeFormat().resolvedOptions().timeZone;\n}\n\nexport function ComparisonResult(value: number) {\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\n}\n\nexport function GetOptionsObject<T>(options: T) {\n  if (options === undefined) return ObjectCreate(null) as NonNullable<T>;\n  if (IsObject(options) && options !== null) return options;\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\n\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\n  const o = ObjectCreate(null);\n  o[propName] = propValue;\n  return o;\n}\n\nfunction CopyOptions<T extends { [s in K]?: unknown }, K extends string & keyof T>(options: T | undefined) {\n  const optionsCopy = ObjectCreate(null) as T;\n  CopyDataProperties(optionsCopy, GetOptionsObject(options), []);\n  return optionsCopy;\n}\n\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: undefined\n): O[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: Fallback\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: O[P]\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\n  let value = options[property];\n  if (value !== undefined) {\n    value = ToString(value) as O[P];\n    if (!allowedValues.includes(value)) {\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n    }\n    return value;\n  }\n  return fallback;\n}\n\nexport function IsBuiltinCalendar(id: string): id is BuiltinCalendarId {\n  return BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id));\n}\n\nexport function ASCIILowercase<T extends string>(str: T): T {\n  // The spec defines this operation distinct from String.prototype.lowercase,\n  // so we'll follow the spec here. Note that nasty security issues that can\n  // happen for some use cases if you're comparing case-modified non-ASCII\n  // values. For example, Turkish's \"I\" character was the source of a security\n  // issue involving \"file://\" URLs. See\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\n  return str.replace(/[A-Z]/g, (l) => {\n    const code = l.charCodeAt(0);\n    return String.fromCharCode(code + 0x20);\n  }) as T;\n}\n\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\n\nfunction bisect(\n  getState: (epochNs: JSBI) => number,\n  leftParam: JSBI,\n  rightParam: JSBI,\n  lstateParam: number = getState(leftParam),\n  rstateParam: number = getState(rightParam)\n) {\n  // This doesn't make much sense - why do these get converted unnecessarily?\n  let left = JSBI.BigInt(leftParam);\n  let right = JSBI.BigInt(rightParam);\n  let lstate = lstateParam;\n  let rstate = rstateParam;\n  while (JSBI.greaterThan(JSBI.subtract(right, left), ONE)) {\n    const middle = JSBI.divide(JSBI.add(left, right), JSBI.BigInt(2));\n    const mstate = getState(middle);\n    if (mstate === lstate) {\n      left = middle;\n      lstate = mstate;\n    } else if (mstate === rstate) {\n      right = middle;\n      rstate = mstate;\n    } else {\n      throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n    }\n  }\n  return right;\n}\n\nconst nsPerTimeUnit = {\n  hour: 3600e9,\n  minute: 60e9,\n  second: 1e9,\n  millisecond: 1e6,\n  microsecond: 1e3,\n  nanosecond: 1\n};\n", "import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport {\n  GetSlot,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR\n} from './slots';\nimport type { Temporal, Intl } from '..';\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\n\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\n\nconst descriptor = <T extends (...args: any[]) => any>(value: T) => {\n  return {\n    value,\n    enumerable: true,\n    writable: false,\n    configurable: true\n  };\n};\n\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n\ninterface CustomFormatters {\n  [DATE]: typeof dateAmend | globalThis.Intl.DateTimeFormat;\n  [YM]: typeof yearMonthAmend | typeof globalThis.Intl.DateTimeFormat;\n  [MD]: typeof monthDayAmend | typeof globalThis.Intl.DateTimeFormat;\n  [TIME]: typeof timeAmend | typeof globalThis.Intl.DateTimeFormat;\n  [DATETIME]: typeof datetimeAmend | typeof globalThis.Intl.DateTimeFormat;\n  [INST]: typeof instantAmend | typeof globalThis.Intl.DateTimeFormat;\n}\n\ninterface PrivateProps extends CustomFormatters {\n  [ORIGINAL]: globalThis.Intl.DateTimeFormat;\n  [TZ_RESOLVED]: string | Temporal.TimeZoneProtocol;\n  [CAL_ID]: globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'];\n  [LOCALE]: globalThis.Intl.ResolvedDateTimeFormatOptions['locale'];\n  [OPTIONS]: Intl.DateTimeFormatOptions;\n}\n\ntype OptionsAmenderFunction = (options: Intl.DateTimeFormatOptions) => globalThis.Intl.DateTimeFormatOptions;\ntype FormatterOrAmender = globalThis.Intl.DateTimeFormat | OptionsAmenderFunction;\n\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy<T extends PrivateProps, P extends keyof CustomFormatters>(\n  obj: T,\n  prop: P\n): globalThis.Intl.DateTimeFormat {\n  let val = obj[prop] as FormatterOrAmender;\n  if (typeof val === 'function') {\n    // If we get here, `val` is an \"amender function\". It will take the user's\n    // options and transform them into suitable options to be passed into the\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n    // will vary depending on the Temporal type, so that's why we store separate\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\n    // The efficiency happens because we don't create an (expensive) formatter\n    // until the user calls toLocaleString for that Temporal type.\n    val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n    // TODO: can this be typed more cleanly?\n    (obj[prop] as globalThis.Intl.DateTimeFormat) = val;\n  }\n  return val;\n}\n\ntype DateTimeFormatImpl = Intl.DateTimeFormat & PrivateProps;\n\nfunction DateTimeFormatImpl(\n  this: Intl.DateTimeFormat & PrivateProps,\n  locale: Params['constructor'][0] = undefined,\n  optionsParam: Params['constructor'][1] = {}\n) {\n  if (!(this instanceof DateTimeFormatImpl)) {\n    type Construct = new (\n      locale: Params['constructor'][0],\n      optionsParam: Params['constructor'][1]\n    ) => Intl.DateTimeFormat;\n    return new (DateTimeFormatImpl as unknown as Construct)(locale, optionsParam);\n  }\n  const hasOptions = typeof optionsParam !== 'undefined';\n  const options = hasOptions ? ObjectAssign({}, optionsParam) : {};\n  // TODO: remove type assertion after Temporal types land in TS lib types\n  const original = new IntlDateTimeFormat(locale, options as globalThis.Intl.DateTimeFormatOptions);\n  const ro = original.resolvedOptions();\n\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\n  // be lazily created only when needed, using the locale and options provided.\n  // But it's possible for callers to mutate those inputs before lazy creation\n  // happens. For this reason, we clone the inputs instead of caching the\n  // original objects. To avoid the complexity of deep cloning any inputs that\n  // are themselves objects (e.g. the locales array, or options property values\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\n  // options as-is because our options-amending logic adds additional fields if\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\n  // Therefore, we limit the properties in the clone to properties that were\n  // present in the original input.\n  if (hasOptions) {\n    const clonedResolved = ObjectAssign({}, ro);\n    for (const prop in clonedResolved) {\n      if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n        delete clonedResolved[prop as keyof typeof clonedResolved];\n      }\n    }\n    this[OPTIONS] = clonedResolved as Intl.DateTimeFormatOptions;\n  } else {\n    this[OPTIONS] = options;\n  }\n\n  this[LOCALE] = ro.locale;\n  this[ORIGINAL] = original;\n  this[TZ_RESOLVED] = ro.timeZone;\n  this[CAL_ID] = ro.calendar;\n  this[DATE] = dateAmend;\n  this[YM] = yearMonthAmend;\n  this[MD] = monthDayAmend;\n  this[TIME] = timeAmend;\n  this[DATETIME] = datetimeAmend;\n  this[INST] = instantAmend;\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\n\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n  writable: true,\n  value: 'DateTimeFormat'\n});\n\nDateTimeFormatImpl.supportedLocalesOf = function (\n  locales: Params['supportedLocalesOf'][0],\n  options: Params['supportedLocalesOf'][1]\n) {\n  return IntlDateTimeFormat.supportedLocalesOf(locales, options as globalThis.Intl.DateTimeFormatOptions);\n};\n\nconst propertyDescriptors: Partial<Record<keyof Intl.DateTimeFormat, PropertyDescriptor>> = {\n  resolvedOptions: descriptor(resolvedOptions),\n  format: descriptor(format),\n  formatRange: descriptor(formatRange)\n};\n\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n  propertyDescriptors.formatToParts = descriptor(formatToParts);\n}\n\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n  propertyDescriptors.formatRangeToParts = descriptor(formatRangeToParts);\n}\n\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, propertyDescriptors);\n\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nexport const DateTimeFormat = DateTimeFormatImpl as unknown as typeof Intl.DateTimeFormat;\n\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\n  return this[ORIGINAL].resolvedOptions();\n}\n\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['format'][0],\n  ...rest: P\n): Return['format'] {\n  let { instant, formatter } = extractOverrides(datetime, this);\n  if (instant && formatter) {\n    return formatter.format(instant.epochMilliseconds);\n  }\n  // Support spreading additional args for future expansion of this Intl method\n  type AllowExtraParams = (datetime: Parameters<Intl.DateTimeFormat['format']>[0], ...rest: P) => Return['format'];\n  return (this[ORIGINAL].format as unknown as AllowExtraParams)(datetime, ...rest);\n}\n\nfunction formatToParts<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['formatToParts'][0],\n  ...rest: P\n): Return['formatToParts'] {\n  let { instant, formatter } = extractOverrides(datetime, this);\n  if (instant && formatter) {\n    return formatter.formatToParts(instant.epochMilliseconds);\n  }\n  // Support spreading additional args for future expansion of this Intl method\n  type AllowExtraParams = (\n    datetime: Parameters<Intl.DateTimeFormat['formatToParts']>[0],\n    ...rest: P\n  ) => Return['formatToParts'];\n  return (this[ORIGINAL].formatToParts as unknown as AllowExtraParams)(datetime, ...rest);\n}\n\nfunction formatRange(this: DateTimeFormatImpl, a: Params['formatRange'][0], b: Params['formatRange'][1]) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n    }\n    const { instant: aa, formatter: aformatter } = extractOverrides(a as unknown as TypesWithToLocaleString, this);\n    const { instant: bb, formatter: bformatter } = extractOverrides(b as unknown as TypesWithToLocaleString, this);\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      // TODO: Remove type assertion after this method lands in TS lib types\n      return (aformatter as Intl.DateTimeFormat).formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  }\n  // TODO: Remove type assertion after this method lands in TS lib types\n  return (this[ORIGINAL] as Intl.DateTimeFormat).formatRange(a, b);\n}\n\nfunction formatRangeToParts(\n  this: DateTimeFormatImpl,\n  a: Params['formatRangeToParts'][0],\n  b: Params['formatRangeToParts'][1]\n) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n    }\n    const { instant: aa, formatter: aformatter } = extractOverrides(a, this);\n    const { instant: bb, formatter: bformatter } = extractOverrides(b, this);\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      // TODO: Remove type assertion after this method lands in TS lib types\n      return (aformatter as Intl.DateTimeFormat).formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  }\n  // TODO: Remove type assertion after this method lands in TS lib types\n  return (this[ORIGINAL] as Intl.DateTimeFormat).formatRangeToParts(a, b);\n}\n\n// \"false\" is a signal to delete this option\ntype MaybeFalseOptions = {\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\n};\n\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\n  const options = ObjectAssign({}, optionsParam);\n  for (const opt of [\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'weekday',\n    'dayPeriod',\n    'timeZoneName',\n    'dateStyle',\n    'timeStyle'\n  ] as const) {\n    // TODO: can this be typed more cleanly?\n    type OptionMaybeFalse = typeof options[typeof opt] | false;\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\n  }\n  return options as globalThis.Intl.DateTimeFormatOptions;\n}\n\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\n\nfunction timeAmend(optionsParam: OptionsType<Temporal.PlainTime>) {\n  let options = amend(optionsParam, {\n    year: false,\n    month: false,\n    day: false,\n    weekday: false,\n    timeZoneName: false,\n    dateStyle: false\n  });\n  if (!hasTimeOptions(options)) {\n    options = ObjectAssign({}, options, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction yearMonthAmend(optionsParam: OptionsType<Temporal.PlainYearMonth>) {\n  let options = amend(optionsParam, {\n    day: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n  if (!('year' in options || 'month' in options)) {\n    options = ObjectAssign(options, { year: 'numeric', month: 'numeric' });\n  }\n  return options;\n}\n\nfunction monthDayAmend(optionsParam: OptionsType<Temporal.PlainMonthDay>) {\n  let options = amend(optionsParam, {\n    year: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n  if (!('month' in options || 'day' in options)) {\n    options = ObjectAssign({}, options, { month: 'numeric', day: 'numeric' });\n  }\n  return options;\n}\n\nfunction dateAmend(optionsParam: OptionsType<Temporal.PlainDate>) {\n  let options = amend(optionsParam, {\n    hour: false,\n    minute: false,\n    second: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if (!hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction datetimeAmend(optionsParam: OptionsType<Temporal.PlainDateTime>) {\n  let options = amend(optionsParam, { timeZoneName: false });\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\n  let options = optionsParam;\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\n\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return (\n    'hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options\n  );\n}\n\nfunction isTemporalObject(\n  obj: unknown\n): obj is\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainDateTime\n  | Temporal.ZonedDateTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.Instant {\n  return (\n    ES.IsTemporalDate(obj) ||\n    ES.IsTemporalTime(obj) ||\n    ES.IsTemporalDateTime(obj) ||\n    ES.IsTemporalZonedDateTime(obj) ||\n    ES.IsTemporalYearMonth(obj) ||\n    ES.IsTemporalMonthDay(obj) ||\n    ES.IsTemporalInstant(obj)\n  );\n}\n\nfunction sameTemporalType(x: unknown, y: unknown) {\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\n  return true;\n}\n\ntype TypesWithToLocaleString =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime\n  | Temporal.Instant;\n\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n\n  if (ES.IsTemporalTime(temporalObj)) {\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, TIME)\n    };\n  }\n\n  if (ES.IsTemporalYearMonth(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, YM)\n    };\n  }\n\n  if (ES.IsTemporalMonthDay(temporalObj)) {\n    const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, MD)\n    };\n  }\n\n  if (ES.IsTemporalDate(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n    const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, DATE)\n    };\n  }\n\n  if (ES.IsTemporalDateTime(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const calendar = ES.ToTemporalCalendarIdentifier(GetSlot(temporalObj, CALENDAR));\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`\n      );\n    }\n    let datetime = temporalObj;\n    if (calendar === 'iso8601') {\n      datetime = new DateTime(\n        isoYear,\n        isoMonth,\n        isoDay,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        main[CAL_ID]\n      );\n    }\n    return {\n      instant: ES.GetInstantFor(main[TZ_RESOLVED], datetime, 'compatible'),\n      formatter: getPropLazy(main, DATETIME)\n    };\n  }\n\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\n    throw new TypeError(\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\n    );\n  }\n\n  if (ES.IsTemporalInstant(temporalObj)) {\n    return {\n      instant: temporalObj,\n      formatter: getPropLazy(main, INST)\n    };\n  }\n\n  return {};\n}\n", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND } from './ecmascript';\n\nexport class Instant implements Temporal.Instant {\n  constructor(epochNanoseconds: bigint | JSBI) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n\n    const ns = ES.ToBigInt(epochNanoseconds);\n    ES.ValidateEpochNanoseconds(ns);\n    CreateSlots(this);\n    SetSlot(this, EPOCHNANOSECONDS, ns);\n\n    if (DEBUG) {\n      const repr = ES.TemporalInstantToString(this, undefined, 'auto');\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${repr}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get epochSeconds(): Return['epochSeconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, BILLION));\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, MILLION));\n  }\n  get epochMicroseconds(): Return['epochMicroseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return ES.ToBigIntExternal(ES.BigIntFloorDiv(value, THOUSAND));\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromInstant('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromInstant('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalInstant('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalInstant('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const maximumIncrements = {\n      hour: 24,\n      minute: 1440,\n      second: 86400,\n      millisecond: 86400e3,\n      microsecond: 86400e6,\n      nanosecond: 86400e9\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n    return new Instant(roundedNs);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalInstant(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    let timeZone = options.timeZone;\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneSlotValue(timeZone);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundInstant(ns, increment, unit, roundingMode);\n    const roundedInstant = new Instant(roundedNs);\n    return ES.TemporalInstantToString(roundedInstant, timeZone as Temporal.TimeZoneProtocol, precision);\n  }\n  toJSON(): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalInstantToString(this, undefined, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) {\n      throw new TypeError('invalid argument in toZonedDateTime');\n    }\n    const calendarLike = item.calendar;\n    if (calendarLike === undefined) {\n      throw new TypeError('missing calendar property in toZonedDateTime');\n    }\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n    const temporalTimeZoneLike = item.timeZone;\n    if (temporalTimeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property in toZonedDateTime');\n    }\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\n    if (!ES.IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\n  }\n\n  static fromEpochSeconds(epochSecondsParam: Params['fromEpochSeconds'][0]): Return['fromEpochSeconds'] {\n    const epochSeconds = ES.ToNumber(epochSecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochSeconds), BILLION);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochMilliseconds(\n    epochMillisecondsParam: Params['fromEpochMilliseconds'][0]\n  ): Return['fromEpochMilliseconds'] {\n    const epochMilliseconds = ES.ToNumber(epochMillisecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochMicroseconds(\n    epochMicrosecondsParam: Params['fromEpochMicroseconds'][0]\n  ): Return['fromEpochMicroseconds'] {\n    const epochMicroseconds = ES.ToBigInt(epochMicrosecondsParam);\n    const epochNanoseconds = JSBI.multiply(epochMicroseconds, THOUSAND);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static fromEpochNanoseconds(\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\n  ): Return['fromEpochNanoseconds'] {\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    ES.ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    if (ES.IsTemporalInstant(item)) {\n      return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    return ES.ToTemporalInstant(item);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalInstant(oneParam);\n    const two = ES.ToTemporalInstant(twoParam);\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.Instant';\n}\n\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass, DefineIntrinsic } from './intrinsicclass';\nimport {\n  CALENDAR_ID,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport type {\n  BuiltinCalendarId,\n  CalendarParams as Params,\n  CalendarReturn as Return,\n  AnyTemporalKey,\n  CalendarSlot\n} from './internaltypes';\n\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst ObjectCreate = Object.create;\nconst ObjectEntries = Object.entries;\nconst OriginalSet = Set;\nconst ReflectOwnKeys = Reflect.ownKeys;\nconst SetPrototypeAdd = Set.prototype.add;\nconst SetPrototypeValues = Set.prototype.values;\n\n/**\n * Shape of internal implementation of each built-in calendar. Note that\n * parameter types are simpler than CalendarProtocol because the `Calendar`\n * class performs validation and parameter normalization before handing control\n * over to CalendarImpl.\n *\n * There are two instances of this interface: one for the ISO calendar and\n * another that handles logic that's the same across all non-ISO calendars. The\n * latter is cloned for each non-ISO calendar at the end of this file.\n */\ninterface CalendarImpl {\n  year(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  month(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): number;\n  monthCode(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): string;\n  day(date: Temporal.PlainDate | Temporal.PlainMonthDay): number;\n  era(date: Temporal.PlainDate | Temporal.PlainYearMonth): string | undefined;\n  eraYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number | undefined;\n  dayOfWeek(date: Temporal.PlainDate): number;\n  dayOfYear(date: Temporal.PlainDate): number;\n  weekOfYear(date: Temporal.PlainDate): number;\n  yearOfWeek(date: Temporal.PlainDate): number;\n  daysInWeek(date: Temporal.PlainDate): number;\n  daysInMonth(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  daysInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  monthsInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number;\n  inLeapYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): boolean;\n  dateFromFields(\n    fields: Params['dateFromFields'][0],\n    options: NonNullable<Params['dateFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainDate;\n  yearMonthFromFields(\n    fields: Params['yearMonthFromFields'][0],\n    options: NonNullable<Params['yearMonthFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainYearMonth;\n  monthDayFromFields(\n    fields: Params['monthDayFromFields'][0],\n    options: NonNullable<Params['monthDayFromFields'][1]>,\n    calendar: string\n  ): Temporal.PlainMonthDay;\n  dateAdd(\n    date: Temporal.PlainDate,\n    years: number,\n    months: number,\n    weeks: number,\n    days: number,\n    overflow: Overflow,\n    calendar: string\n  ): Temporal.PlainDate;\n  dateUntil(\n    one: Temporal.PlainDate,\n    two: Temporal.PlainDate,\n    largestUnit: 'year' | 'month' | 'week' | 'day'\n  ): { years: number; months: number; weeks: number; days: number };\n  fields(fields: string[]): string[];\n  fieldKeysToIgnore(keys: string[]): string[];\n}\n\ntype CalendarImplementations = {\n  [k in BuiltinCalendarId]: CalendarImpl;\n};\n\n/**\n * Implementations for each calendar.\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\n * at the bottom of the file.\n */\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\n\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nexport class Calendar implements Temporal.Calendar {\n  constructor(idParam: Params['constructor'][0]) {\n    // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n    //       exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: id is required');\n    }\n\n    const id = ES.ToString(idParam);\n    if (!ES.IsBuiltinCalendar(id)) throw new RangeError(`invalid calendar identifier ${id}`);\n    CreateSlots(this);\n    SetSlot(this, CALENDAR_ID, ES.ASCIILowercase(id));\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${id}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get id(): Return['id'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  dateFromFields(\n    fields: Params['dateFromFields'][0],\n    optionsParam: Params['dateFromFields'][1] = undefined\n  ): Return['dateFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].dateFromFields(fields, options, id);\n  }\n  yearMonthFromFields(\n    fields: Params['yearMonthFromFields'][0],\n    optionsParam: Params['yearMonthFromFields'][1] = undefined\n  ): Return['yearMonthFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].yearMonthFromFields(fields, options, id);\n  }\n  monthDayFromFields(\n    fields: Params['monthDayFromFields'][0],\n    optionsParam: Params['monthDayFromFields'][1] = undefined\n  ): Return['monthDayFromFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(fields)) throw new TypeError('invalid fields');\n    const options = ES.GetOptionsObject(optionsParam);\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].monthDayFromFields(fields, options, id);\n  }\n  fields(fields: Params['fields'][0]): Return['fields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const fieldsArray = [] as string[];\n    const allowed = new Set([\n      'year',\n      'month',\n      'monthCode',\n      'day',\n      'hour',\n      'minute',\n      'second',\n      'millisecond',\n      'microsecond',\n      'nanosecond'\n    ]);\n    for (const name of fields) {\n      if (typeof name !== 'string') throw new TypeError('invalid fields');\n      if (!allowed.has(name)) throw new RangeError(`invalid field name ${name}`);\n      allowed.delete(name);\n      ArrayPrototypePush.call(fieldsArray, name);\n    }\n    return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n  }\n  mergeFields(\n    fieldsParam: Params['mergeFields'][0],\n    additionalFieldsParam: Params['mergeFields'][1]\n  ): Return['mergeFields'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const fields = ES.ToObject(fieldsParam);\n    const fieldsCopy = ObjectCreate(null);\n    ES.CopyDataProperties(fieldsCopy, fields, [], [undefined]);\n    const additionalFields = ES.ToObject(additionalFieldsParam);\n    const additionalFieldsCopy = ObjectCreate(null);\n    ES.CopyDataProperties(additionalFieldsCopy, additionalFields, [], [undefined]);\n    const additionalKeys = ReflectOwnKeys(additionalFieldsCopy) as (keyof typeof additionalFields)[];\n    const overriddenKeys = impl[GetSlot(this, CALENDAR_ID)].fieldKeysToIgnore(additionalKeys);\n    const merged = ObjectCreate(null);\n    const fieldsKeys = ReflectOwnKeys(fieldsCopy);\n    for (const key of fieldsKeys) {\n      let propValue = undefined;\n      if (ES.Call(ArrayIncludes, overriddenKeys, [key])) propValue = additionalFieldsCopy[key];\n      else propValue = fieldsCopy[key];\n      if (propValue !== undefined) merged[key] = propValue;\n    }\n    ES.CopyDataProperties(merged, additionalFieldsCopy, []);\n    return merged;\n  }\n  dateAdd(\n    dateParam: Params['dateAdd'][0],\n    durationParam: Params['dateAdd'][1],\n    optionsParam: Params['dateAdd'][2] = undefined\n  ): Return['dateAdd'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    const duration = ES.ToTemporalDuration(durationParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { days } = ES.BalanceDuration(\n      GetSlot(duration, DAYS),\n      GetSlot(duration, HOURS),\n      GetSlot(duration, MINUTES),\n      GetSlot(duration, SECONDS),\n      GetSlot(duration, MILLISECONDS),\n      GetSlot(duration, MICROSECONDS),\n      GetSlot(duration, NANOSECONDS),\n      'day'\n    );\n    const id = GetSlot(this, CALENDAR_ID);\n    return impl[id].dateAdd(\n      date,\n      GetSlot(duration, YEARS),\n      GetSlot(duration, MONTHS),\n      GetSlot(duration, WEEKS),\n      days,\n      overflow,\n      id\n    );\n  }\n  dateUntil(\n    oneParam: Params['dateUntil'][0],\n    twoParam: Params['dateUntil'][1],\n    optionsParam: Params['dateUntil'][2] = undefined\n  ): Return['dateUntil'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    let largestUnit = ES.GetTemporalUnit(options, 'largestUnit', 'date', 'auto');\n    if (largestUnit === 'auto') largestUnit = 'day';\n    const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  }\n  year(dateParam: Params['year'][0]): Return['year'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].year(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  month(dateParam: Params['month'][0]): Return['month'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (ES.IsTemporalMonthDay(date)) throw new TypeError('use monthCode on PlainMonthDay instead');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].month(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  monthCode(dateParam: Params['monthCode'][0]): Return['monthCode'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date) && !ES.IsTemporalMonthDay(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthCode(\n      date as Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth\n    );\n  }\n  day(dateParam: Params['day'][0]): Return['day'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalMonthDay(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].day(date as Temporal.PlainDate | Temporal.PlainMonthDay);\n  }\n  era(dateParam: Params['era'][0]): Return['era'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].era(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  eraYear(dateParam: Params['eraYear'][0]): Return['eraYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].eraYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  dayOfWeek(dateParam: Params['dayOfWeek'][0]): Return['dayOfWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n  }\n  dayOfYear(dateParam: Params['dayOfYear'][0]): Return['dayOfYear'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n  }\n  weekOfYear(dateParam: Params['weekOfYear'][0]): Return['weekOfYear'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n  }\n  yearOfWeek(dateParam: Params['yearOfWeek'][0]): Return['yearOfWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].yearOfWeek(date);\n  }\n  daysInWeek(dateParam: Params['daysInWeek'][0]): Return['daysInWeek'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ES.ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n  }\n  daysInMonth(dateParam: Params['daysInMonth'][0]): Return['daysInMonth'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  daysInYear(dateParam: Params['daysInYear'][0]): Return['daysInYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  monthsInYear(dateParam: Params['monthsInYear'][0]): Return['monthsInYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  inLeapYear(dateParam: Params['inLeapYear'][0]): Return['inLeapYear'] {\n    let date = dateParam;\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsTemporalYearMonth(date)) date = ES.ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date as Temporal.PlainDate | Temporal.PlainYearMonth);\n  }\n  toString(): string {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    const calendarSlotValue = ES.ToTemporalCalendarSlotValue(item);\n    return ES.ToTemporalCalendarObject(calendarSlotValue);\n  }\n  [Symbol.toStringTag]!: 'Temporal.Calendar';\n}\n\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\nDefineIntrinsic('Temporal.Calendar.prototype.dateAdd', Calendar.prototype.dateAdd);\nDefineIntrinsic('Temporal.Calendar.prototype.dateFromFields', Calendar.prototype.dateFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.dateUntil', Calendar.prototype.dateUntil);\nDefineIntrinsic('Temporal.Calendar.prototype.day', Calendar.prototype.day);\nDefineIntrinsic('Temporal.Calendar.prototype.dayOfWeek', Calendar.prototype.dayOfWeek);\nDefineIntrinsic('Temporal.Calendar.prototype.dayOfYear', Calendar.prototype.dayOfYear);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInMonth', Calendar.prototype.daysInMonth);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInWeek', Calendar.prototype.daysInWeek);\nDefineIntrinsic('Temporal.Calendar.prototype.daysInYear', Calendar.prototype.daysInYear);\nDefineIntrinsic('Temporal.Calendar.prototype.era', Calendar.prototype.era);\nDefineIntrinsic('Temporal.Calendar.prototype.eraYear', Calendar.prototype.eraYear);\nDefineIntrinsic('Temporal.Calendar.prototype.fields', Calendar.prototype.fields);\nDefineIntrinsic('Temporal.Calendar.prototype.inLeapYear', Calendar.prototype.inLeapYear);\nDefineIntrinsic('Temporal.Calendar.prototype.mergeFields', Calendar.prototype.mergeFields);\nDefineIntrinsic('Temporal.Calendar.prototype.month', Calendar.prototype.month);\nDefineIntrinsic('Temporal.Calendar.prototype.monthCode', Calendar.prototype.monthCode);\nDefineIntrinsic('Temporal.Calendar.prototype.monthDayFromFields', Calendar.prototype.monthDayFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.monthsInYear', Calendar.prototype.monthsInYear);\nDefineIntrinsic('Temporal.Calendar.prototype.weekOfYear', Calendar.prototype.weekOfYear);\nDefineIntrinsic('Temporal.Calendar.prototype.year', Calendar.prototype.year);\nDefineIntrinsic('Temporal.Calendar.prototype.yearMonthFromFields', Calendar.prototype.yearMonthFromFields);\nDefineIntrinsic('Temporal.Calendar.prototype.yearOfWeek', Calendar.prototype.yearOfWeek);\n\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n  dateFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['year', 'day']);\n    const overflow = ES.ToTemporalOverflow(options);\n    fields = resolveNonLunisolarMonth(fields);\n    let { year, month, day } = fields;\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n    return ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n  },\n  yearMonthFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['month', 'monthCode', 'year'], ['year']);\n    const overflow = ES.ToTemporalOverflow(options);\n    fields = resolveNonLunisolarMonth(fields);\n    let { year, month } = fields;\n    ({ year, month } = ES.RegulateISOYearMonth(year, month, overflow));\n    return ES.CreateTemporalYearMonth(year, month, calendarSlotValue, /* referenceISODay = */ 1);\n  },\n  monthDayFromFields(fieldsParam, options, calendarSlotValue) {\n    let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['day']);\n    const overflow = ES.ToTemporalOverflow(options);\n    if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n      throw new TypeError('either year or monthCode required with month');\n    }\n    const useYear = fields.monthCode === undefined;\n    const referenceISOYear = 1972;\n    fields = resolveNonLunisolarMonth(fields);\n    let { month, day, year } = fields;\n    ({ month, day } = ES.RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n    return ES.CreateTemporalMonthDay(month, day, calendarSlotValue, referenceISOYear);\n  },\n  fields(fields) {\n    return fields;\n  },\n  fieldKeysToIgnore(keys) {\n    const result = new OriginalSet();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      ES.Call(SetPrototypeAdd, result, [key]);\n      if (key === 'month') {\n        ES.Call(SetPrototypeAdd, result, ['monthCode']);\n      } else if (key === 'monthCode') {\n        ES.Call(SetPrototypeAdd, result, ['month']);\n      }\n    }\n    return [...ES.Call(SetPrototypeValues, result, [])];\n  },\n  dateAdd(date, years, months, weeks, days, overflow, calendarSlotValue) {\n    let year = GetSlot(date, ISO_YEAR);\n    let month = GetSlot(date, ISO_MONTH);\n    let day = GetSlot(date, ISO_DAY);\n    ({ year, month, day } = ES.AddISODate(year, month, day, years, months, weeks, days, overflow));\n    return ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n  },\n  dateUntil(one, two, largestUnit) {\n    return ES.DifferenceISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY),\n      largestUnit\n    );\n  },\n  year(date) {\n    return GetSlot(date, ISO_YEAR);\n  },\n  era() {\n    return undefined;\n  },\n  eraYear() {\n    return undefined;\n  },\n  month(date) {\n    return GetSlot(date, ISO_MONTH);\n  },\n  monthCode(date) {\n    return buildMonthCode(GetSlot(date, ISO_MONTH));\n  },\n  day(date) {\n    return GetSlot(date, ISO_DAY);\n  },\n  dayOfWeek(date) {\n    return ES.DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n  dayOfYear(date) {\n    return ES.DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n  weekOfYear(date) {\n    return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY)).week;\n  },\n  yearOfWeek(date) {\n    return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY)).year;\n  },\n  daysInWeek() {\n    return 7;\n  },\n  daysInMonth(date) {\n    return ES.ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n  },\n  daysInYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    return ES.LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n  },\n  monthsInYear() {\n    return 12;\n  },\n  inLeapYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    return ES.LeapYear(GetSlot(date, ISO_YEAR));\n  }\n};\n\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\n// proposal for ECMA-262. These calendars will be standardized as part of\n// ECMA-402. Code below here includes an implementation of these calendars to\n// validate the Temporal API and to get feedback. However, native non-ISO\n// calendar behavior is at least somewhat implementation-defined, so may not\n// match this polyfill's output exactly.\n//\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\n// to ensure a clean separation between the ISO calendar implementation which is\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\n// ECMA-402.\n//\n// To ensure this separation, the implementation is split. A `CalendarImpl`\n// interface defines the common operations between both ISO and non-ISO\n// calendars.\n\n/**\n * This type is passed through from Calendar#dateFromFields().\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\n */\ntype CalendarDateFields = Params['dateFromFields'][0] & { monthExtra?: string };\n\n/**\n * This is a \"fully populated\" calendar date record. It's only lacking\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\n * which is only used in some cases.\n */\ntype FullCalendarDate = {\n  era?: string;\n  eraYear?: number;\n  year: number;\n  month: number;\n  monthCode: string;\n  day: number;\n  monthExtra?: string;\n};\n\n// The types below are various subsets of calendar dates\ntype CalendarYMD = { year: number; month: number; day: number };\ntype CalendarYM = { year: number; month: number };\ntype CalendarYearOnly = { year: number };\ntype EraAndEraYear = { era: string; eraYear: number };\n\n/** Record representing YMD of an ISO calendar date */\ntype IsoYMD = { year: number; month: number; day: number };\n\ntype Overflow = NonNullable<Temporal.AssignmentOptions['overflow']>;\n\nfunction monthCodeNumberPart(monthCode: string) {\n  if (!monthCode.startsWith('M')) {\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n  }\n  const month = +monthCode.slice(1);\n  if (isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\n  return month;\n}\n\nfunction buildMonthCode(month: number | string, leap = false) {\n  return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\n  calendarDate: T,\n  overflow: Overflow | undefined = undefined,\n  monthsPerYear = 12\n) {\n  let { month, monthCode } = calendarDate;\n  if (monthCode === undefined) {\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\n    // The ISO calendar uses the default (undefined) value because it does\n    // constrain/reject after this method returns. Non-ISO calendars, however,\n    // rely on this function to constrain/reject out-of-range `month` values.\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\n    monthCode = buildMonthCode(month);\n  } else {\n    const numberPart = monthCodeNumberPart(monthCode);\n    if (month !== undefined && month !== numberPart) {\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n    }\n    if (monthCode !== buildMonthCode(numberPart)) {\n      throw new RangeError(`Invalid month code: ${monthCode}`);\n    }\n    month = numberPart;\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n  }\n  return { ...calendarDate, month, monthCode };\n}\n\ntype CachedTypes = Temporal.PlainYearMonth | Temporal.PlainDate | Temporal.PlainMonthDay;\n\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n  map = new Map();\n  calls = 0;\n  now: number;\n  hits = 0;\n  misses = 0;\n  constructor(cacheToClone?: OneObjectCache) {\n    this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n    if (cacheToClone !== undefined) {\n      let i = 0;\n      for (const entry of cacheToClone.map.entries()) {\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\n        this.map.set(...entry);\n      }\n    }\n  }\n  get(key: string) {\n    const result = this.map.get(key);\n    if (result) {\n      this.hits++;\n      this.report();\n    }\n    this.calls++;\n    return result;\n  }\n  set(key: string, value: unknown) {\n    this.map.set(key, value);\n    this.misses++;\n    this.report();\n  }\n  report() {\n    /*\n    if (this.calls === 0) return;\n    const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n    const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n    console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n    */\n  }\n  setObject(obj: CachedTypes) {\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\n    OneObjectCache.objectMap.set(obj, this);\n    this.report();\n  }\n\n  static objectMap = new WeakMap();\n  static MAX_CACHE_ENTRIES = 1000;\n\n  /**\n   * Returns a WeakMap-backed cache that's used to store expensive results\n   * that are associated with a particular Temporal object instance.\n   *\n   * @param obj - object to associate with the cache\n   */\n  static getCacheForObject(obj: CachedTypes) {\n    let cache = OneObjectCache.objectMap.get(obj);\n    if (!cache) {\n      cache = new OneObjectCache();\n      OneObjectCache.objectMap.set(obj, cache);\n    }\n    return cache;\n  }\n}\n\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\n  const yearString = ES.ISOYearString(isoYear);\n  const monthString = ES.ISODateTimePartString(isoMonth);\n  const dayString = ES.ISODateTimePartString(isoDay);\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\n\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\n  return {\n    years: one.year - two.year,\n    months: one.month - two.month,\n    days: one.day - two.day\n  };\n}\n\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nabstract class HelperBase {\n  abstract id: BuiltinCalendarId;\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\n  abstract estimateIsoDate(calendarDate: CalendarYMD): IsoYMD;\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: IsoYMD): T;\n  constantEra?: string;\n  checkIcuBugs?(isoDate: IsoYMD): void;\n  private formatter?: globalThis.Intl.DateTimeFormat;\n  getFormatter() {\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n    // calendars that are used. Note that the nonIsoHelperBase object is spread\n    // into each each calendar's implementation before any cache is created, so\n    // each calendar gets its own separate cached formatter.\n    if (typeof this.formatter === 'undefined') {\n      this.formatter = new IntlDateTimeFormat(`en-US-u-ca-${this.id}`, {\n        day: 'numeric',\n        month: 'numeric',\n        year: 'numeric',\n        era: this.eraLength,\n        timeZone: 'UTC'\n      });\n    }\n    return this.formatter;\n  }\n  isoToCalendarDate(isoDate: IsoYMD, cache: OneObjectCache): FullCalendarDate {\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n\n    const dateTimeFormat = this.getFormatter();\n    let parts, isoString;\n    try {\n      isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n      parts = dateTimeFormat.formatToParts(new Date(isoString));\n    } catch (e: unknown) {\n      throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n    }\n    const result: Partial<FullCalendarDate> = {};\n    for (let { type, value } of parts) {\n      if (type === 'year') result.eraYear = +value;\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n      if (type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) result.eraYear = +value;\n      if (type === 'month') {\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n          throw new RangeError(`Unexpected month: ${value}`);\n        }\n        // If the month has no numeric part (should only see this for the Hebrew\n        // calendar with newer FF / Chromium versions; see\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n        // placeholder month index of `1` and rely on the derived class to\n        // calculate the correct month index from the month name stored in\n        // `monthExtra`.\n        result.month = matches[1] ? +matches[1] : 1;\n        if (result.month < 1) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\n          );\n        }\n        if (result.month > 13) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n          );\n        }\n\n        // The ICU formats for the Hebrew calendar no longer support a numeric\n        // month format. So we'll rely on the derived class to interpret it.\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\n        // \"bis\" indicating a leap month.\n        if (matches[2]) result.monthExtra = matches[2];\n      }\n      if (type === 'day') result.day = +value;\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\n        // The convention for Temporal era values is lowercase, so following\n        // that convention in this prototype. Punctuation is removed, accented\n        // letters are normalized, and spaces are replaced with dashes.\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n        // The call to normalize() and the replacement regex deals with era\n        // names that contain non-ASCII characters like Japanese eras. Also\n        // ignore extra content in parentheses like JPN era date ranges.\n        value = value.split(' (')[0];\n        result.era = value\n          .normalize('NFD')\n          .replace(/[^-0-9 \\p{L}]/gu, '')\n          .replace(' ', '-')\n          .toLowerCase();\n      }\n    }\n    if (result.eraYear === undefined) {\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n      // output of Intl.DateTimeFormat.formatToParts.\n      throw new RangeError(\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n      );\n    }\n    // Translate eras that may be handled differently by Temporal vs. by Intl\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n    if (this.reviseIntlEra) {\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n      result.era = era;\n      result.eraYear = eraYear;\n    }\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\n\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.month === undefined) throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n    cache.set(key, calendarDate);\n    // Also cache the reverse mapping\n    ['constrain', 'reject'].forEach((overflow) => {\n      const keyReverse = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: calendarDate.year,\n        month: calendarDate.month,\n        day: calendarDate.day,\n        overflow,\n        id: this.id\n      });\n      cache.set(keyReverse, isoDate);\n    });\n    return calendarDate;\n  }\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\n    const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n    // the derived class must deal with it.\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\n    if (day === undefined) throw new RangeError('Missing day');\n    if (monthCode !== undefined) {\n      if (typeof monthCode !== 'string') {\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n      }\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    if (this.constantEra) {\n      if (era !== undefined && era !== this.constantEra) {\n        throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n      }\n      if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n        throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n      }\n    }\n    if (this.hasEra) {\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n      }\n    }\n  }\n  /**\n   * Allows derived calendars to add additional fields and/or to make\n   * adjustments e.g. to set the era based on the date or to revise the month\n   * number in lunisolar calendars per\n   * https://github.com/tc39/proposal-temporal/issues/1203.\n   *\n   * The base implementation fills in missing values by assuming the simplest\n   * possible calendar:\n   * - no eras or a constant era defined in `.constantEra`\n   * - non-lunisolar calendar (no leap months)\n   * */\n  adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache: OneObjectCache | undefined = undefined,\n    overflow: Overflow = 'constrain',\n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\n    let calendarDate = calendarDateParam;\n    this.validateCalendarDate(calendarDate);\n    // For calendars that always use the same era, set it here so that derived\n    // calendars won't need to implement this method simply to set the era.\n    if (this.constantEra) {\n      // year and eraYear always match when there's only one possible era\n      const { year, eraYear } = calendarDate;\n      calendarDate = {\n        ...calendarDate,\n        era: this.constantEra,\n        year: year !== undefined ? year : eraYear,\n        eraYear: eraYear !== undefined ? eraYear : year\n      };\n    }\n\n    const largestMonth = this.monthsInYear(calendarDate as CalendarYearOnly, cache);\n    let { month, monthCode } = calendarDate;\n\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\n  }\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let { month, day } = calendarDate;\n    if (overflow === 'reject') {\n      ES.RejectToRange(month, 1, largestMonth);\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n    } else {\n      month = ES.ConstrainToRange(month, 1, largestMonth);\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n    }\n    return { ...calendarDate, month, day };\n  }\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): IsoYMD {\n    const originalDate = dateParam as Partial<FullCalendarDate>;\n    // First, normalize the calendar date to ensure that (year, month, day)\n    // are all present, converting monthCode and eraYear if needed.\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\n    // not in this particular year, may not be caught here for some calendars.\n    // If so, these will be handled lower below.\n    date = this.regulateMonthDayNaive(date, overflow, cache);\n\n    const { year, month, day } = date;\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n    let cached = cache.get(key);\n    if (cached) return cached;\n    // If YMD are present in the input but the input has been constrained\n    // already, then cache both the original value and the constrained value.\n    let keyOriginal;\n    if (\n      originalDate.year !== undefined &&\n      originalDate.month !== undefined &&\n      originalDate.day !== undefined &&\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\n    ) {\n      keyOriginal = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: originalDate.year,\n        month: originalDate.month,\n        day: originalDate.day,\n        overflow,\n        id: this.id\n      });\n      cached = cache.get(keyOriginal);\n      if (cached) return cached;\n    }\n\n    // First, try to roughly guess the result\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\n    const calculateSameMonthResult = (diffDays: number) => {\n      // If the estimate is in the same year & month as the target, then we can\n      // calculate the result exactly and short-circuit any additional logic.\n      // This optimization assumes that months are continuous. It would break if\n      // a calendar skipped days, like the Julian->Gregorian switchover. But the\n      // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n      // that's currently detected by `checkIcuBugs()` which will throw. So\n      // this optimization should be safe for all ICU calendars.\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n      if (date.day > this.minimumMonthLength(date)) {\n        // There's a chance that the calendar date is out of range. Throw or\n        // constrain if so.\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n          if (overflow === 'reject') {\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n          }\n          // Back up a day at a time until we're not hanging over the month end\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        }\n      }\n      return testIsoEstimate;\n    };\n    let sign = 0;\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n    let diff = simpleDateDiff(date, roundtripEstimate);\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      diff = simpleDateDiff(date, roundtripEstimate);\n      if (diff.years === 0 && diff.months === 0) {\n        isoEstimate = calculateSameMonthResult(diff.days);\n      } else {\n        sign = this.compareCalendarDates(date, roundtripEstimate);\n      }\n    }\n    // If the initial guess is not in the same month, then then bisect the\n    // distance to the target, starting with 8 days per step.\n    let increment = 8;\n    while (sign) {\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n      const oldRoundtripEstimate = roundtripEstimate;\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      const oldSign = sign;\n      sign = this.compareCalendarDates(date, roundtripEstimate);\n      if (sign) {\n        diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years === 0 && diff.months === 0) {\n          isoEstimate = calculateSameMonthResult(diff.days);\n          // Signal the loop condition that there's a match.\n          sign = 0;\n        } else if (oldSign && sign !== oldSign) {\n          if (increment > 1) {\n            // If the estimate overshot the target, try again with a smaller increment\n            // in the reverse direction.\n            increment /= 2;\n          } else {\n            // Increment is 1, and neither the previous estimate nor the new\n            // estimate is correct. The only way that can happen is if the\n            // original date was an invalid value that will be constrained or\n            // rejected here.\n            if (overflow === 'reject') {\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n            } else {\n              // To constrain, pick the earliest value\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n              // If current value is larger, then back up to the previous value.\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\n              sign = 0;\n            }\n          }\n        }\n      }\n    }\n    cache.set(key, isoEstimate);\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\n    if (\n      date.year === undefined ||\n      date.month === undefined ||\n      date.day === undefined ||\n      date.monthCode === undefined ||\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\n    ) {\n      throw new RangeError('Unexpected missing property');\n    }\n    return isoEstimate;\n  }\n  temporalToCalendarDate(\n    date: Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n    const result = this.isoToCalendarDate(isoDate, cache);\n    return result;\n  }\n  compareCalendarDates(date1Param: Partial<CalendarYMD>, date2Param: Partial<CalendarYMD>): 0 | 1 | -1 {\n    // `date1` and `date2` are already records. The calls below simply validate\n    // that all three required fields are present.\n    const date1 = ES.PrepareTemporalFields(date1Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n    const date2 = ES.PrepareTemporalFields(date2Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\n    return 0;\n  }\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n    return this.isoToCalendarDate(isoDate, cache);\n  }\n  addDaysIso(isoDate: IsoYMD, days: number): IsoYMD {\n    const added = ES.AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n    return added;\n  }\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIso = this.addDaysIso(isoDate, days);\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n    return addedCalendar;\n  }\n  addMonthsCalendar(\n    calendarDateParam: CalendarYMD,\n    months: number,\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): CalendarYMD {\n    let calendarDate = calendarDateParam;\n    const { day } = calendarDate;\n    for (let i = 0, absMonths = MathAbs(months); i < absMonths; i++) {\n      const { month } = calendarDate;\n      const oldCalendarDate = calendarDate;\n      const days =\n        months < 0\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n          : this.daysInMonth(calendarDate, cache);\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n      let addedIso = this.addDaysIso(isoDate, days);\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\n\n      // Normally, we can advance one month by adding the number of days in the\n      // current month. However, if we're at the end of the current month and\n      // the next month has fewer days, then we rolled over to the after-next\n      // month. Below we detect this condition and back up until we're back in\n      // the desired month.\n      if (months > 0) {\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\n          addedIso = this.addDaysIso(addedIso, -1);\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\n        }\n      }\n\n      if (calendarDate.day !== day) {\n        // try to retain the original day-of-month, if possible\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n      }\n    }\n    if (overflow === 'reject' && calendarDate.day !== day) {\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n    }\n    return calendarDate;\n  }\n  addCalendar(\n    calendarDate: CalendarYMD & { monthCode: string },\n    { years = 0, months = 0, weeks = 0, days = 0 },\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const { year, day, monthCode } = calendarDate;\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\n    const initialDays = days + weeks * 7;\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n    return addedDays;\n  }\n  untilCalendar(\n    calendarOne: FullCalendarDate,\n    calendarTwo: FullCalendarDate,\n    largestUnit: Temporal.DateUnit,\n    cache: OneObjectCache\n  ): { years: number; months: number; weeks: number; days: number } {\n    let days = 0;\n    let weeks = 0;\n    let months = 0;\n    let years = 0;\n    switch (largestUnit) {\n      case 'day':\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        break;\n      case 'week': {\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        days = totalDays % 7;\n        weeks = (totalDays - days) / 7;\n        break;\n      }\n      case 'month':\n      case 'year': {\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n        if (!sign) {\n          return { years: 0, months: 0, weeks: 0, days: 0 };\n        }\n        const diffYears = calendarTwo.year - calendarOne.year;\n        const diffDays = calendarTwo.day - calendarOne.day;\n        if (largestUnit === 'year' && diffYears) {\n          let diffInYearSign = 0;\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\n        }\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n        // Now we have less than one year remaining. Add one month at a time\n        // until we go over the target, then back up one month and calculate\n        // remaining days and weeks.\n        let current;\n        let next: CalendarYMD = yearsAdded;\n        do {\n          months += sign;\n          current = next;\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n          if (next.day !== calendarOne.day) {\n            // In case the day was constrained down, try to un-constrain it\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n          }\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n        months -= sign; // correct for loop above which overshoots by 1\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n        days = remainingDays;\n        break;\n      }\n    }\n    return { years, months, weeks, days };\n  }\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    // Add enough days to roll over to the next month. One we're in the next\n    // month, we can calculate the length of the current month. NOTE: This\n    // algorithm assumes that months are continuous. It would break if a\n    // calendar skipped days, like the Julian->Gregorian switchover. But the\n    // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n    // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n    // that's currently detected by `checkIcuBugs()` which will throw. So this\n    // code should be safe for all ICU calendars.\n    const { day } = calendarDate;\n    const max = this.maximumMonthLength(calendarDate);\n    const min = this.minimumMonthLength(calendarDate);\n    // easiest case: we already know the month length if min and max are the same.\n    if (min === max) return min;\n\n    // Add enough days to get into the next month, without skipping it\n    const increment = day <= max - min ? max : min;\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n\n    // Now back up to the last day of the original month\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n    return endOfMonthCalendar.day;\n  }\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    const { day, month, year } = calendarDate;\n\n    // Check to see if we already know the month length, and return it if so\n    const previousMonthYear = month > 1 ? year : year - 1;\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\n    const min = this.minimumMonthLength(previousMonthDate);\n    const max = this.maximumMonthLength(previousMonthDate);\n    if (min === max) return max;\n\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n    return lastDayOfPreviousMonthCalendar.day;\n  }\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n  }\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n  }\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n    return this.isoDaysUntil(oneIso, twoIso);\n  }\n  isoDaysUntil(oneIso: IsoYMD, twoIso: IsoYMD): number {\n    const duration = ES.DifferenceISODate(\n      oneIso.year,\n      oneIso.month,\n      oneIso.day,\n      twoIso.year,\n      twoIso.month,\n      twoIso.day,\n      'day'\n    );\n    return duration.days;\n  }\n  // The short era format works for all calendars except Japanese, which will\n  // override.\n  eraLength: Intl.DateTimeFormatOptions['era'] = 'short';\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  hasEra = true;\n  // See https://github.com/tc39/proposal-temporal/issues/1784\n  erasBeginMidYear = false;\n  monthDayFromFields(fields: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): IsoYMD {\n    let { monthCode, day } = fields;\n    if (monthCode === undefined) {\n      let { year, era, eraYear } = fields;\n      if (year === undefined && (era === undefined || eraYear === undefined)) {\n        throw new TypeError('when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required');\n      }\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\n    }\n\n    let isoYear, isoMonth, isoDay;\n    let closestCalendar, closestIso;\n    // Look backwards starting from one of the calendar years spanning ISO year\n    // 1972, up to 100 calendar years prior, to find a year that has this month\n    // and day. Normal months and days will match immediately, but for leap days\n    // and leap months we may have to look for a while.\n    const startDateIso = { year: 1972, month: 12, day: 31 };\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\n    // Note: relies on lexicographical ordering of monthCodes\n    const calendarYear =\n      calendarOfStartDateIso.monthCode > monthCode ||\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\n        ? calendarOfStartDateIso.year\n        : calendarOfStartDateIso.year - 1;\n    for (let i = 0; i < 100; i++) {\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\n        { day, monthCode, year: calendarYear - i },\n        cache\n      );\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n        return { month: isoMonth, day: isoDay, year: isoYear };\n      } else if (overflow === 'constrain') {\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\n        if (\n          closestCalendar === undefined ||\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n            roundTripCalendarDate.day > closestCalendar.day)\n        ) {\n          closestCalendar = roundTripCalendarDate;\n          closestIso = isoDate;\n        }\n      }\n    }\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n  }\n}\n\ninterface HebrewMonthInfo {\n  [m: string]: (\n    | {\n        leap: undefined;\n        regular: number;\n      }\n    | {\n        leap: number;\n        regular: undefined;\n      }\n    | {\n        leap: number;\n        regular: number;\n      }\n  ) & {\n    monthCode: string;\n    days:\n      | number\n      | {\n          min: number;\n          max: number;\n        };\n  };\n}\n\nclass HebrewHelper extends HelperBase {\n  id = 'hebrew' as const;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    const { year } = calendarDate;\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\n    // also has per-year changes to the number of days of Heshvan and Kislev.\n    // Given that these can be calculated by counting the number of days in\n    // those months, I assume that these DO NOT need to be exposed as\n    // Hebrew-only prototype fields or methods.\n    return (7 * year + 1) % 19 < 7;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly) {\n    return this.inLeapYear(calendarDate) ? 13 : 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'min');\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'max');\n  }\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\n    const { month, year } = calendarDate;\n    const monthCode = this.getMonthCode(year, month);\n    const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\n    const daysInMonth = monthInfo[1].days;\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n  }\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = calendarDate;\n    return { year: year - 3760, month: 1, day: 1 };\n  }\n  months: HebrewMonthInfo = {\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n  };\n  getMonthCode(year: number, month: number) {\n    if (this.inLeapYear({ year })) {\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n    } else {\n      return buildMonthCode(month);\n    }\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    // The incoming type is actually CalendarDate (same as args to\n    // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n    // reassignments below, so as an alternative to 10+ type casts, we'll lie\n    // here and claim that the type has `day` and `year` filled in already.\n    let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate as Omit<\n      typeof calendarDate,\n      'year' | 'day'\n    > & { year: number; day: number };\n    if (year === undefined && eraYear !== undefined) year = eraYear;\n    if (eraYear === undefined && year !== undefined) eraYear = year;\n    if (fromLegacyDate) {\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n      // output returns the numeric equivalent of `month` as a string, meaning\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n      // means Adar. In this case, `month` will already be correct and no action\n      // is needed. However, in Node 14 and later formatToParts returns the name\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n      // correct `month` using the string name as a key.\n      if (monthExtra) {\n        const monthInfo = this.months[monthExtra];\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n      }\n      // Because we're getting data from legacy Date, then `month` will always be present\n      monthCode = this.getMonthCode(year, month as number);\n      const result = { year, month: month as number, day, era: undefined as string | undefined, eraYear, monthCode };\n      return result;\n    } else {\n      // When called without input coming from legacy Date output, simply ensure\n      // that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (month === undefined) {\n        if ((monthCode as string).endsWith('L')) {\n          if (monthCode !== 'M05L') {\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n          }\n          month = 6;\n          if (!this.inLeapYear({ year })) {\n            if (overflow === 'reject') {\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n            } else {\n              // constrain to same day of next month (Adar)\n              month = 6;\n              monthCode = 'M06';\n            }\n          }\n        } else {\n          month = monthCodeNumberPart(monthCode as string);\n          // if leap month is before this one, the month index is one more than the month code\n          if (this.inLeapYear({ year }) && month >= 6) month++;\n          const largestMonth = this.monthsInYear({ year });\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n      } else {\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n        } else {\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n        }\n        if (monthCode === undefined) {\n          monthCode = this.getMonthCode(year, month);\n        } else {\n          const calculatedMonthCode = this.getMonthCode(year, month);\n          if (calculatedMonthCode !== monthCode) {\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n          }\n        }\n      }\n      return { ...calendarDate, day, month, monthCode: monthCode as string, year, eraYear };\n    }\n  }\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  override hasEra = false;\n}\n\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nabstract class IslamicBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // In leap years, the 12th month has 30 days. In non-leap years: 29.\n    const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n    return days === 30;\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n  DAYS_PER_ISO_YEAR = 365.2425;\n  override constantEra = 'ah';\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: MathFloor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n  }\n}\n\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n  id = 'islamic' as const;\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n  id = 'islamic-umalqura' as const;\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n  id = 'islamic-tbla' as const;\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n  id = 'islamic-civil' as const;\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n  id = 'islamic-rgsa' as const;\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n  id = 'islamicc' as const;\n}\n\nclass PersianHelper extends HelperBase {\n  id = 'persian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // Same logic (count days in the last month) for Persian as for Islamic,\n    // even though Persian is solar and Islamic is lunar.\n    return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 29;\n    return month <= 6 ? 31 : 30;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 30;\n    return month <= 6 ? 31 : 30;\n  }\n  override constantEra = 'ap';\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: year + 621, month: 1, day: 1 };\n  }\n}\n\ninterface IndianMonthInfo {\n  [month: number]: {\n    length: number;\n    month: number;\n    day: number;\n    leap?: {\n      length: number;\n      month: number;\n      day: number;\n    };\n    nextYear?: true | undefined;\n  };\n}\n\nclass IndianHelper extends HelperBase {\n  id = 'indian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\n    // the result is a leap year in the Gregorian calendar, then the Saka year\n    // is a leap year as well.\n    return isGregorianLeapYear(calendarDate.year + 78);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  override constantEra = 'saka';\n  // Indian months always start at the same well-known Gregorian month and\n  // day. So this conversion is easy and fast. See\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\n  months: IndianMonthInfo = {\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n    2: { length: 31, month: 4, day: 21 },\n    3: { length: 31, month: 5, day: 22 },\n    4: { length: 31, month: 6, day: 22 },\n    5: { length: 31, month: 7, day: 23 },\n    6: { length: 31, month: 8, day: 23 },\n    7: { length: 30, month: 9, day: 23 },\n    8: { length: 30, month: 10, day: 23 },\n    9: { length: 30, month: 11, day: 22 },\n    10: { length: 30, month: 12, day: 22 },\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\n  };\n  getMonthInfo(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    let monthInfo = this.months[month];\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\n    return monthInfo;\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n    // calendar fast!\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const monthInfo = this.getMonthInfo(calendarDate);\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n    const isoMonth = monthInfo.month;\n    const isoDay = monthInfo.day;\n    const isoDate = ES.AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n    return isoDate;\n  }\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n  // expected.\n  vulnerableToBceBug =\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n  override checkIcuBugs(isoDate: IsoYMD) {\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\n      throw new RangeError(\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n      );\n    }\n  }\n}\n\n/**\n * Era metadata defined for each calendar.\n * TODO: instead of optional properties, this should really have rules\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\n *  */\ninterface InputEra {\n  /** name of the era */\n  name: string;\n\n  /**\n   * Signed calendar year where this era begins.Will be\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\n   * numbering starts at the beginning of the anchor era, which is true\n   * for all ICU calendars except Japanese. If an era starts mid-year\n   * then a calendar month and day are included. Otherwise\n   * `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch?: { year: number; month: number; day: number };\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: string;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n/**\n * Transformation of the `InputEra` type with all fields filled in by\n * `adjustEras()`\n * */\ninterface Era {\n  /** name of the era */\n  name: string;\n\n  /**\n   * alternate name of the era used in old versions of ICU data\n   * format is `era{n}` where n is the zero-based index of the era\n   * with the oldest era being 0.\n   * */\n  genericName: string;\n\n  /**\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\n   * eras) for the anchor era assuming that `year` numbering starts at the\n   * beginning of the anchor era, which is true for all ICU calendars except\n   * Japanese. For input, the month and day are optional. If an era starts\n   * mid-year then a calendar month and day are included.\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch: CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch: IsoYMD;\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: Era;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\n  let eras: (InputEra | Era)[] = erasParam;\n  if (eras.length === 0) {\n    throw new RangeError('Invalid era data: eras are required');\n  }\n  if (eras.length === 1 && eras[0].reverseOf) {\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n  }\n  if (eras.length === 1 && !eras[0].name) {\n    throw new RangeError('Invalid era data: at least one named era is required');\n  }\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\n    throw new RangeError('Invalid era data: only one era can count years backwards');\n  }\n\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\n  // anchor.\n  let anchorEra: Era | InputEra | undefined;\n  eras.forEach((e) => {\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n      anchorEra = e;\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n    } else if (!e.name) {\n      throw new RangeError('If era name is blank, it must be the anchor era');\n    }\n  });\n\n  // If the era name is undefined, then it's an anchor that doesn't interact\n  // with eras at all. For example, Japanese `year` is always the same as ISO\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n  // Strip it from the list that's returned.\n  eras = eras.filter((e) => e.name);\n\n  eras.forEach((e) => {\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n    // Replace the string-valued \"reverseOf\" property with the actual era object\n    // that's reversed.\n    const { reverseOf } = e;\n    if (reverseOf) {\n      const reversedEra = eras.find((era) => era.name === reverseOf);\n      if (reversedEra === undefined) throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n      e.reverseOf = reversedEra as Era;\n      e.anchorEpoch = reversedEra.anchorEpoch;\n      e.isoEpoch = reversedEra.isoEpoch;\n    }\n    type YMD = {\n      year: number;\n      month: number;\n      day: number;\n    };\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\n  });\n\n  // Ensure that the latest epoch is first in the array. This lets us try to\n  // match eras in index order, with the last era getting the remaining older\n  // years. Any reverse-signed era must be at the end.\n  ArraySort.call(eras, (e1, e2) => {\n    if (e1.reverseOf) return 1;\n    if (e2.reverseOf) return -1;\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\n    return e2.isoEpoch.year - e1.isoEpoch.year;\n  });\n\n  // If there's a reversed era, then the one before it must be the era that's\n  // being reversed.\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\n  if (lastEraReversed) {\n    if (lastEraReversed !== eras[eras.length - 2]) throw new RangeError('Invalid era data: invalid reverse-sign era');\n  }\n\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n  // zero-based index, with the oldest era being zero. This format is used by\n  // older versions of ICU data.\n  eras.forEach((e, i) => {\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\n  });\n\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\n}\n\nfunction isGregorianLeapYear(year: number) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n/** Base for all Gregorian-like calendars. */\nabstract class GregorianBaseHelper extends HelperBase {\n  id: BuiltinCalendarId;\n  eras: Era[];\n  anchorEra: Era;\n\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super();\n    this.id = id;\n    const { eras, anchorEra } = adjustEras(originalEras);\n    this.anchorEra = anchorEra;\n    this.eras = eras;\n  }\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // Calendars that don't override this method use the same months and leap\n    // years as Gregorian. Once we know the ISO year corresponding to the\n    // calendar year, we'll know if it's a leap year or not.\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n    return isGregorianLeapYear(year);\n  }\n  monthsInYear(/* calendarDate */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM): number {\n    const { month } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n  maximumMonthLength(calendarDate: CalendarYM): number {\n    return this.minimumMonthLength(calendarDate);\n  }\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\n  completeEraYear(calendarDate: Partial<FullCalendarDate>) {\n    const checkField = (name: keyof FullCalendarDate, value: string | number | undefined) => {\n      const currentValue = calendarDate[name];\n      if (currentValue != null && currentValue != value) {\n        throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n      }\n    };\n    const eraFromYear = (year: number) => {\n      let eraYear;\n      const adjustedCalendarDate = { ...calendarDate, year };\n      const matchingEra = this.eras.find((e, i) => {\n        if (i === this.eras.length - 1) {\n          if (e.reverseOf) {\n            // This is a reverse-sign era (like BCE) which must be the oldest\n            // era. Count years backwards.\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n            eraYear = e.anchorEpoch.year - year;\n            return true;\n          }\n          // last era always gets all \"leftover\" (older than epoch) years,\n          // so no need for a comparison like below.\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n        if (comparison >= 0) {\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        return false;\n      });\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\n      return { eraYear: eraYear as unknown as number, era: matchingEra.name };\n    };\n\n    let { year, eraYear, era } = calendarDate;\n    if (year != null) {\n      ({ eraYear, era } = eraFromYear(year));\n      checkField('era', era);\n      checkField('eraYear', eraYear);\n    } else if (eraYear != null) {\n      const matchingEra =\n        era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n      if (eraYear < 1 && matchingEra.reverseOf) {\n        throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n      }\n      if (matchingEra.reverseOf) {\n        year = matchingEra.anchorEpoch.year - eraYear;\n      } else {\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n      }\n      checkField('year', year);\n      // We'll accept dates where the month/day is earlier than the start of\n      // the era or after its end as long as it's in the same year. If that\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\n      // the `year`.\n      ({ eraYear, era } = eraFromYear(year));\n    } else {\n      throw new RangeError('Either `year` or `eraYear` and `era` are required');\n    }\n    return { ...calendarDate, year, eraYear, era };\n  }\n  override adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain'\n  ): FullCalendarDate {\n    let calendarDate = calendarDateParam;\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n    const { month, monthCode } = calendarDate;\n    if (month === undefined) calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode as string) };\n    this.validateCalendarDate(calendarDate);\n    calendarDate = this.completeEraYear(calendarDate);\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const { year, month, day } = calendarDate;\n    const { anchorEra } = this;\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n  }\n  // Several calendars based on the Gregorian calendar use Julian dates (not\n  // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n  v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n    .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n    .startsWith('12');\n  calendarIsVulnerableToJulianBug = false;\n  override checkIcuBugs(isoDate: IsoYMD) {\n    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n      const beforeJulianSwitch = ES.CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n      if (beforeJulianSwitch) {\n        throw new RangeError(\n          `calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n            ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)'\n        );\n      }\n    }\n  }\n}\n\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super(id, originalEras);\n  }\n  override inLeapYear(calendarDate: CalendarYearOnly) {\n    // Leap years happen one year before the Julian leap year. Note that this\n    // calendar is based on the Julian calendar which has a leap year every 4\n    // years, unlike the Gregorian calendar which doesn't have leap years on\n    // years divisible by 100 except years divisible by 400.\n    //\n    // Note that we're assuming that leap years in before-epoch times match\n    // how leap years are defined now. This is probably not accurate but I'm\n    // not sure how better to do it.\n    const { year } = calendarDate;\n    return (year + 1) % 4 === 0;\n  }\n  override monthsInYear(/* calendarDate */) {\n    return 13;\n  }\n  override minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\n    return 30;\n  }\n  override maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minimumMonthLength(calendarDate);\n  }\n}\n\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n  }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('coptic', [\n      { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n      { name: 'era0', reverseOf: 'era1' }\n    ]);\n  }\n}\n\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethiopic', [\n      { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n      { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n    ]);\n  }\n}\n\nclass RocHelper extends GregorianBaseHelper {\n  constructor() {\n    super('roc', [\n      { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n      { name: 'before-roc', reverseOf: 'minguo' }\n    ]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n}\n\nclass BuddhistHelper extends GregorianBaseHelper {\n  constructor() {\n    super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n}\n\nclass GregoryHelper extends GregorianBaseHelper {\n  constructor() {\n    super('gregory', [\n      { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n      { name: 'bce', reverseOf: 'ce' }\n    ]);\n  }\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\n    let { era, eraYear } = calendarDate;\n    // Firefox 96 introduced a bug where the `'short'` format of the era\n    // option mistakenly returns the one-letter (narrow) format instead. The\n    // code below handles either the correct or Firefox-buggy format. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n    if (era === 'bc' || era === 'b') era = 'bce';\n    if (era === 'ad' || era === 'a') era = 'ce';\n    return { era, eraYear } as T;\n  }\n}\n\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n  constructor() {\n    super('japanese', [\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n      { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n      { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n      { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n      { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n      { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n      { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n      { name: 'bce', reverseOf: 'ce' }\n    ]);\n  }\n  override calendarIsVulnerableToJulianBug = true;\n\n  // The last 3 Japanese eras confusingly return only one character in the\n  // default \"short\" era, so need to use the long format.\n  override eraLength = 'long' as const;\n\n  override erasBeginMidYear = true;\n\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: IsoYMD): T {\n    const { era, eraYear } = calendarDate;\n    const { year: isoYear } = isoDate;\n    if (this.eras.find((e) => e.name === era)) return { era, eraYear } as T;\n    return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear }) as T;\n  }\n}\n\ninterface ChineseMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth: number };\n}\ninterface ChineseDraftMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth?: number };\n}\n\nabstract class ChineseBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    const months = this.getMonthList(calendarDate.year, cache);\n    return ObjectEntries(months).length === 13;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\n    if (calendarYear === undefined) {\n      throw new TypeError('Missing year');\n    }\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n    const dateTimeFormat = this.getFormatter();\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n      const legacyDate = new Date(isoStringFeb1);\n      // Now add the requested number of days, which may wrap to the next month.\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n      const calendarMonthString = (newYearGuess.find((tv) => tv.type === 'month') as Intl.DateTimeFormatPart).value;\n      const calendarDay = +(newYearGuess.find((tv) => tv.type === 'day') as Intl.DateTimeFormatPart).value;\n      let calendarYearToVerify: globalThis.Intl.DateTimeFormatPart | number | undefined = newYearGuess.find(\n        (tv) => (tv.type as string) === 'relatedYear'\n      );\n      if (calendarYearToVerify !== undefined) {\n        calendarYearToVerify = +calendarYearToVerify.value;\n      } else {\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n        // output of Intl.DateTimeFormat.formatToParts.\n        throw new RangeError(\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n        );\n      }\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\n    };\n\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\n    // the first month or near the end of the last month of the previous year.\n    let isoDaysDelta = 17;\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n\n    // If we didn't guess the first month correctly, add (almost in some months)\n    // a lunar month\n    if (calendarMonthString !== '1') {\n      isoDaysDelta += 29;\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n    }\n\n    // Now back up to near the start of the first month, but not too near that\n    // off-by-one issues matter.\n    isoDaysDelta -= calendarDay - 5;\n    const result = {} as ChineseDraftMonthInfo;\n    let monthIndex = 1;\n    let oldCalendarDay: number | undefined;\n    let oldMonthString: string | undefined;\n    let done = false;\n    do {\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n      if (oldCalendarDay) {\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\n      }\n      if (calendarYearToVerify !== calendarYear) {\n        done = true;\n      } else {\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\n        // Move to the next month. Because months are sometimes 29 days, the day of the\n        // calendar month will move forward slowly but not enough to flip over to a new\n        // month before the loop ends at 12-13 months.\n        isoDaysDelta += 30;\n      }\n      oldCalendarDay = calendarDay;\n      oldMonthString = calendarMonthString;\n    } while (!done);\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n\n    cache.set(key, result);\n    return result as ChineseMonthInfo;\n  }\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year, month } = calendarDate;\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n    if (fromLegacyDate) {\n      // Legacy Date output returns a string that's an integer with an optional\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n      // month. Below we'll normalize the output.\n      year = eraYear;\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\n      const monthString = `${month}${monthExtra || ''}`;\n      const months = this.getMonthList(year as number, cache);\n      const monthInfo = months[monthString];\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n      month = monthInfo.monthIndex;\n      return { year: year as number, month, day: day as number, era: undefined, eraYear, monthCode };\n    } else {\n      // When called without input coming from legacy Date output,\n      // simply ensure that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (year === undefined) year = eraYear;\n      if (eraYear === undefined) eraYear = year;\n      if (month === undefined) {\n        ES.assertExists(monthCode);\n        const months = this.getMonthList(year as number, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        let monthInfo = months[numberPart];\n        month = monthInfo && monthInfo.monthIndex;\n\n        // If this leap month isn't present in this year, constrain to the same\n        // day of the previous month.\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\n          let withoutML = monthCode.slice(1, -1);\n          if (withoutML[0] === '0') withoutML = withoutML.slice(1);\n          monthInfo = months[withoutML];\n          if (monthInfo) {\n            month = monthInfo.monthIndex;\n            monthCode = buildMonthCode(withoutML);\n          }\n        }\n        if (month === undefined) {\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n        }\n      } else if (monthCode === undefined) {\n        const months = this.getMonthList(year as number, cache);\n        const monthEntries = ObjectEntries(months);\n        const largestMonth = monthEntries.length;\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, largestMonth);\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\n        } else {\n          month = ES.ConstrainToRange(month, 1, largestMonth);\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n        }\n        const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n        if (matchingMonthEntry === undefined) {\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n        }\n        monthCode = buildMonthCode(\n          matchingMonthEntry[0].replace('bis', ''),\n          matchingMonthEntry[0].indexOf('bis') !== -1\n        );\n      } else {\n        // Both month and monthCode are present. Make sure they don't conflict.\n        const months = this.getMonthList(year as number, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        const monthInfo = months[numberPart];\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n        if (month !== monthInfo.monthIndex) {\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n        }\n      }\n      return {\n        ...calendarDate,\n        year: year as number,\n        eraYear,\n        month,\n        monthCode: monthCode,\n        day: day as number\n      };\n    }\n  }\n  // All built-in calendars except Chinese/Dangi and Hebrew use an era\n  override hasEra = false;\n}\n\nclass ChineseHelper extends ChineseBaseHelper {\n  id = 'chinese' as const;\n}\n\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n  id = 'dangi' as const;\n}\n\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nclass NonIsoCalendar implements CalendarImpl {\n  constructor(private readonly helper: HelperBase) {}\n  dateFromFields(\n    fieldsParam: Params['dateFromFields'][0],\n    options: NonNullable<Params['dateFromFields'][1]>,\n    calendarSlotValue: string\n  ): Temporal.PlainDate {\n    const cache = new OneObjectCache();\n    const fieldNames = this.fields(['day', 'month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n    const result = ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n    cache.setObject(result);\n    return result;\n  }\n  yearMonthFromFields(\n    fieldsParam: Params['yearMonthFromFields'][0],\n    options: NonNullable<Params['yearMonthFromFields'][1]>,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainYearMonth {\n    const cache = new OneObjectCache();\n    const fieldNames = this.fields(['month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n    const result = ES.CreateTemporalYearMonth(year, month, calendarSlotValue, /* referenceISODay = */ day);\n    cache.setObject(result);\n    return result;\n  }\n  monthDayFromFields(\n    fieldsParam: Params['monthDayFromFields'][0],\n    options: NonNullable<Params['monthDayFromFields'][1]>,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainMonthDay {\n    const cache = new OneObjectCache();\n    // For lunisolar calendars, either `monthCode` or `year` must be provided\n    // because `month` is ambiguous without a year or a code.\n    const fieldNames = this.fields(['day', 'month', 'monthCode', 'year']) as AnyTemporalKey[];\n    const fields = ES.PrepareTemporalFields(fieldsParam, fieldNames, []);\n    const overflow = ES.ToTemporalOverflow(options);\n    const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n    // `year` is a reference year where this month/day exists in this calendar\n    const result = ES.CreateTemporalMonthDay(month, day, calendarSlotValue, /* referenceISOYear = */ year);\n    cache.setObject(result);\n    return result;\n  }\n  fields(fieldsParam: string[]): string[] {\n    let fields = fieldsParam;\n    if (ArrayIncludes.call(fields, 'year')) fields = [...fields, 'era', 'eraYear'];\n    return fields;\n  }\n  fieldKeysToIgnore(\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\n    const result = new OriginalSet();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      ES.Call(SetPrototypeAdd, result, [key]);\n      switch (key) {\n        case 'era':\n          ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          ES.Call(SetPrototypeAdd, result, ['year']);\n          break;\n        case 'eraYear':\n          ES.Call(SetPrototypeAdd, result, ['era']);\n          ES.Call(SetPrototypeAdd, result, ['year']);\n          break;\n        case 'year':\n          ES.Call(SetPrototypeAdd, result, ['era']);\n          ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          break;\n        case 'month':\n          ES.Call(SetPrototypeAdd, result, ['monthCode']);\n          // See https://github.com/tc39/proposal-temporal/issues/1784\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n        case 'monthCode':\n          ES.Call(SetPrototypeAdd, result, ['month']);\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n        case 'day':\n          if (this.helper.erasBeginMidYear) {\n            ES.Call(SetPrototypeAdd, result, ['era']);\n            ES.Call(SetPrototypeAdd, result, ['eraYear']);\n          }\n          break;\n      }\n    }\n    return [...ES.Call(SetPrototypeValues, result, [])];\n  }\n  dateAdd(\n    date: Temporal.PlainDate,\n    years: number,\n    months: number,\n    weeks: number,\n    days: number,\n    overflow: Overflow,\n    calendarSlotValue: CalendarSlot\n  ): Temporal.PlainDate {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n    const { year, month, day } = isoAdded;\n    const newTemporalObject = ES.CreateTemporalDate(year, month, day, calendarSlotValue);\n    // The new object's cache starts with the cache of the old object\n    const newCache = new OneObjectCache(cache);\n    newCache.setObject(newTemporalObject);\n    return newTemporalObject;\n  }\n  dateUntil(one: Temporal.PlainDate, two: Temporal.PlainDate, largestUnit: Temporal.DateUnit) {\n    const cacheOne = OneObjectCache.getCacheForObject(one);\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\n    const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n    const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n    return result;\n  }\n  year(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.year;\n  }\n  month(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.month;\n  }\n  day(date: Temporal.PlainDate | Temporal.PlainMonthDay): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.day;\n  }\n  era(date: Temporal.PlainDate | Temporal.PlainYearMonth): string | undefined {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.era;\n  }\n  eraYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number | undefined {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.eraYear;\n  }\n  monthCode(date: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay): string {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.monthCode;\n  }\n  dayOfWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].dayOfWeek(date);\n  }\n  dayOfYear(date: Temporal.PlainDate): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.isoToCalendarDate(date, cache);\n    const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n    const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n    return diffDays + 1;\n  }\n  weekOfYear(date: Temporal.PlainDate): number {\n    return impl['iso8601'].weekOfYear(date);\n  }\n  yearOfWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].yearOfWeek(date);\n  }\n  daysInWeek(date: Temporal.PlainDate): number {\n    return impl['iso8601'].daysInWeek(date);\n  }\n  daysInMonth(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n\n    // Easy case: if the helper knows the length without any heavy calculation.\n    const max = this.helper.maximumMonthLength(calendarDate);\n    const min = this.helper.minimumMonthLength(calendarDate);\n    if (max === min) return max;\n\n    // The harder case is where months vary every year, e.g. islamic calendars.\n    // Find the answer by calculating the difference in days between the first\n    // day of the current month and the first day of the next month.\n    const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n    const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n    return result;\n  }\n  daysInYear(dateParam: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n    const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    return result;\n  }\n  monthsInYear(date: Temporal.PlainDate | Temporal.PlainYearMonth): number {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.monthsInYear(calendarDate, cache);\n    return result;\n  }\n  inLeapYear(dateParam: Temporal.PlainDate | Temporal.PlainYearMonth): boolean {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ES.ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.inLeapYear(calendarDate, cache);\n    return result;\n  }\n}\n\nfor (const Helper of [\n  HebrewHelper,\n  PersianHelper,\n  EthiopicHelper,\n  EthioaaHelper,\n  CopticHelper,\n  ChineseHelper,\n  DangiHelper,\n  RocHelper,\n  IndianHelper,\n  BuddhistHelper,\n  GregoryHelper,\n  JapaneseHelper,\n  IslamicHelper,\n  IslamicUmalquraHelper,\n  IslamicTblaHelper,\n  IslamicCivilHelper,\n  IslamicRgsaHelper,\n  IslamicCcHelper\n]) {\n  const helper = new Helper();\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\n  // per-calendar logic.\n  impl[helper.id] = new NonIsoCalendar(helper);\n}\n", "import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\n\nexport class PlainDate implements Temporal.PlainDate {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    isoDayParam: Params['constructor'][2],\n    calendarParam: Params['constructor'][3] = 'iso8601'\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get yearOfWeek(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalDateLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalDateLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialDate = ES.PrepareTemporalFields(temporalDateLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarDateFromFields(calendar, fields, options);\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], optionsParam: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    const duration = ES.ToTemporalDuration(temporalDurationLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    optionsParam: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    const duration = ES.CreateNegatedTemporalDuration(ES.ToTemporalDuration(temporalDurationLike));\n    const options = ES.GetOptionsObject(optionsParam);\n\n    return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalDate(otherParam);\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalDateToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n  }\n  toPlainDateTime(temporalTimeParam: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    if (temporalTimeParam === undefined) return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n\n    const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    type TimeZoneAndPlainTimeProps = Exclude<typeof item, string | Temporal.TimeZoneProtocol>;\n    let timeZone: Temporal.TimeZoneLike, temporalTime: TimeZoneAndPlainTimeProps['plainTime'];\n    if (ES.IsObject(item)) {\n      if (ES.IsTemporalTimeZone(item)) {\n        timeZone = item;\n      } else {\n        const timeZoneLike = (item as TimeZoneAndPlainTimeProps).timeZone;\n        if (timeZoneLike === undefined) {\n          ES.uncheckedAssertNarrowedType<Temporal.TimeZoneProtocol>(\n            item,\n            \"if no timeZone property, then assume it's a custom time zone object\"\n          );\n          timeZone = ES.ToTemporalTimeZoneSlotValue(item);\n        } else {\n          timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneLike);\n          ES.uncheckedAssertNarrowedType<TimeZoneAndPlainTimeProps>(\n            item,\n            \"it's a property bag with a timeZone and optional plainTime\"\n          );\n          temporalTime = item.plainTime;\n        }\n      }\n    } else {\n      timeZone = ES.ToTemporalTimeZoneSlotValue(item);\n    }\n\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    let hour = 0,\n      minute = 0,\n      second = 0,\n      millisecond = 0,\n      microsecond = 0,\n      nanosecond = 0;\n    if (temporalTime !== undefined) {\n      temporalTime = ES.ToTemporalTime(temporalTime);\n      ES.uncheckedAssertNarrowedType<Temporal.PlainTime>(\n        temporalTime,\n        'ToTemporalTime above always returns a PlainTime'\n      );\n      hour = GetSlot(temporalTime, ISO_HOUR);\n      minute = GetSlot(temporalTime, ISO_MINUTE);\n      second = GetSlot(temporalTime, ISO_SECOND);\n      millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n      microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n      nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n    }\n\n    const dt = ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalDate(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalDate(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalDate(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    return ES.CompareISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY)\n    );\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\n}\n\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n", "import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\n\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\n\nexport class PlainDateTime implements Temporal.PlainDateTime {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    isoDayParam: Params['constructor'][2],\n    hourParam: Params['constructor'][3] = 0,\n    minuteParam: Params['constructor'][4] = 0,\n    secondParam: Params['constructor'][5] = 0,\n    millisecondParam: Params['constructor'][6] = 0,\n    microsecondParam: Params['constructor'][7] = 0,\n    nanosecondParam: Params['constructor'][8] = 0,\n    calendarParam: Params['constructor'][9] = 'iso8601'\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalDateTimeSlots(\n      this,\n      isoYear,\n      isoMonth,\n      isoDay,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalDateTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalDateTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\n\n    const options = ES.GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialDateTime = ES.PrepareTemporalFields(temporalDateTimeLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n      ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n\n    if (temporalTimeParam === undefined) return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n\n    const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withPlainDate(temporalDateParam: Params['withPlainDate'][0]): Return['withPlainDate'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return new PlainDateTime(\n      GetSlot(this, ISO_YEAR),\n      GetSlot(this, ISO_MONTH),\n      GetSlot(this, ISO_DAY),\n      GetSlot(this, ISO_HOUR),\n      GetSlot(this, ISO_MINUTE),\n      GetSlot(this, ISO_SECOND),\n      GetSlot(this, ISO_MILLISECOND),\n      GetSlot(this, ISO_MICROSECOND),\n      GetSlot(this, ISO_NANOSECOND),\n      calendar\n    );\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    let year = GetSlot(this, ISO_YEAR);\n    let month = GetSlot(this, ISO_MONTH);\n    let day = GetSlot(this, ISO_DAY);\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode\n    ));\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      GetSlot(this, CALENDAR)\n    );\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalDateTime(otherParam);\n    for (const slot of [\n      ISO_YEAR,\n      ISO_MONTH,\n      ISO_DAY,\n      ISO_HOUR,\n      ISO_MINUTE,\n      ISO_SECOND,\n      ISO_MILLISECOND,\n      ISO_MICROSECOND,\n      ISO_NANOSECOND\n    ]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n  }\n\n  toZonedDateTime(\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\n    optionsParam: Params['toZonedDateTime'][1] = undefined\n  ): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n    const options = ES.GetOptionsObject(optionsParam);\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    const instant = ES.GetInstantFor(timeZone, this, disambiguation);\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToDate(this);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToTime(this);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalDateTime(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalDateTime(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDateTime(oneParam);\n    const two = ES.ToTemporalDateTime(twoParam);\n    for (const slot of [\n      ISO_YEAR,\n      ISO_MONTH,\n      ISO_DAY,\n      ISO_HOUR,\n      ISO_MINUTE,\n      ISO_SECOND,\n      ISO_MILLISECOND,\n      ISO_MICROSECOND,\n      ISO_NANOSECOND\n    ] as const) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n    }\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\n}\n\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\nimport JSBI from 'jsbi';\n\nexport class Duration implements Temporal.Duration {\n  constructor(\n    yearsParam: Params['constructor'][0] = 0,\n    monthsParam: Params['constructor'][1] = 0,\n    weeksParam: Params['constructor'][2] = 0,\n    daysParam: Params['constructor'][3] = 0,\n    hoursParam: Params['constructor'][4] = 0,\n    minutesParam: Params['constructor'][5] = 0,\n    secondsParam: Params['constructor'][6] = 0,\n    millisecondsParam: Params['constructor'][7] = 0,\n    microsecondsParam: Params['constructor'][8] = 0,\n    nanosecondsParam: Params['constructor'][9] = 0\n  ) {\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\n\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    CreateSlots(this);\n    SetSlot(this, YEARS, years);\n    SetSlot(this, MONTHS, months);\n    SetSlot(this, WEEKS, weeks);\n    SetSlot(this, DAYS, days);\n    SetSlot(this, HOURS, hours);\n    SetSlot(this, MINUTES, minutes);\n    SetSlot(this, SECONDS, seconds);\n    SetSlot(this, MILLISECONDS, milliseconds);\n    SetSlot(this, MICROSECONDS, microseconds);\n    SetSlot(this, NANOSECONDS, nanoseconds);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${ES.TemporalDurationToString(this)}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get years(): Return['years'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, YEARS);\n  }\n  get months(): Return['months'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MONTHS);\n  }\n  get weeks(): Return['weeks'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, WEEKS);\n  }\n  get days(): Return['days'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, DAYS);\n  }\n  get hours(): Return['hours'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, HOURS);\n  }\n  get minutes(): Return['minutes'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MINUTES);\n  }\n  get seconds(): Return['seconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, SECONDS);\n  }\n  get milliseconds(): Return['milliseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MILLISECONDS);\n  }\n  get microseconds(): Return['microseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MICROSECONDS);\n  }\n  get nanoseconds(): Return['nanoseconds'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, NANOSECONDS);\n  }\n  get sign(): Return['sign'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.DurationSign(\n      GetSlot(this, YEARS),\n      GetSlot(this, MONTHS),\n      GetSlot(this, WEEKS),\n      GetSlot(this, DAYS),\n      GetSlot(this, HOURS),\n      GetSlot(this, MINUTES),\n      GetSlot(this, SECONDS),\n      GetSlot(this, MILLISECONDS),\n      GetSlot(this, MICROSECONDS),\n      GetSlot(this, NANOSECONDS)\n    );\n  }\n  get blank(): Return['blank'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return (\n      ES.DurationSign(\n        GetSlot(this, YEARS),\n        GetSlot(this, MONTHS),\n        GetSlot(this, WEEKS),\n        GetSlot(this, DAYS),\n        GetSlot(this, HOURS),\n        GetSlot(this, MINUTES),\n        GetSlot(this, SECONDS),\n        GetSlot(this, MILLISECONDS),\n        GetSlot(this, MICROSECONDS),\n        GetSlot(this, NANOSECONDS)\n      ) === 0\n    );\n  }\n  with(durationLike: Params['with'][0]): Return['with'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const partialDuration = ES.PrepareTemporalFields(\n      durationLike,\n      // NOTE: Field order here is important.\n      [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n      ],\n      'partial'\n    );\n    const {\n      years = GetSlot(this, YEARS),\n      months = GetSlot(this, MONTHS),\n      weeks = GetSlot(this, WEEKS),\n      days = GetSlot(this, DAYS),\n      hours = GetSlot(this, HOURS),\n      minutes = GetSlot(this, MINUTES),\n      seconds = GetSlot(this, SECONDS),\n      milliseconds = GetSlot(this, MILLISECONDS),\n      microseconds = GetSlot(this, MICROSECONDS),\n      nanoseconds = GetSlot(this, NANOSECONDS)\n    } = partialDuration;\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  negated(): Return['negated'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.CreateNegatedTemporalDuration(this);\n  }\n  abs(): Return['abs'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return new Duration(\n      Math.abs(GetSlot(this, YEARS)),\n      Math.abs(GetSlot(this, MONTHS)),\n      Math.abs(GetSlot(this, WEEKS)),\n      Math.abs(GetSlot(this, DAYS)),\n      Math.abs(GetSlot(this, HOURS)),\n      Math.abs(GetSlot(this, MINUTES)),\n      Math.abs(GetSlot(this, SECONDS)),\n      Math.abs(GetSlot(this, MILLISECONDS)),\n      Math.abs(GetSlot(this, MICROSECONDS)),\n      Math.abs(GetSlot(this, NANOSECONDS))\n    );\n  }\n  add(other: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromDuration('add', this, other, options);\n  }\n  subtract(other: Params['subtract'][0], options: Params['subtract'][1] = undefined): Return['subtract'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromDuration('subtract', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n\n    let defaultLargestUnit = ES.DefaultTemporalLargestUnit(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    );\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n\n    let largestUnit = ES.GetTemporalUnit(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\n    let relativeTo = ES.ToRelativeTemporalObject(roundTo);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    let smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'datetime', undefined);\n\n    let smallestUnitPresent = true;\n    if (!smallestUnit) {\n      smallestUnitPresent = false;\n      smallestUnit = 'nanosecond';\n    }\n    defaultLargestUnit = ES.LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n    let largestUnitPresent = true;\n    if (!largestUnit) {\n      largestUnitPresent = false;\n      largestUnit = defaultLargestUnit;\n    }\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n    if (!smallestUnitPresent && !largestUnitPresent) {\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\n    }\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n\n    const maximumIncrements = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    } as { [k in Temporal.DateTimeUnit]?: number };\n    const maximum = maximumIncrements[smallestUnit];\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n    ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(\n      years,\n      months,\n      weeks,\n      days,\n      largestUnit,\n      relativeTo\n    ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      ES.RoundDuration(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode,\n        relativeTo\n      ));\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n      ES.AdjustRoundedDurationDays(\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode,\n        relativeTo\n      ));\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      largestUnit,\n      relativeTo\n    ));\n    ({ years, months, weeks, days } = ES.BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  total(optionsParam: Params['total'][0]): Return['total'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\n    const options =\n      typeof optionsParam === 'string'\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\n        : ES.GetOptionsObject(optionsParam);\n    const relativeTo = ES.ToRelativeTemporalObject(options);\n    const unit = ES.GetTemporalUnit(options, 'unit', 'datetime', ES.REQUIRED);\n\n    // Convert larger units down to days\n    ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n    // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n    let intermediate;\n    if (ES.IsTemporalZonedDateTime(relativeTo)) {\n      intermediate = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n    }\n    let balanceResult = ES.BalancePossiblyInfiniteDuration(\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      unit,\n      intermediate\n    );\n    if (balanceResult === 'positive overflow') {\n      return Infinity;\n    } else if (balanceResult === 'negative overflow') {\n      return -Infinity;\n    }\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = balanceResult);\n    // Finally, truncate to the correct unit and calculate remainder\n    const { total } = ES.RoundDuration(\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n      1,\n      unit,\n      'trunc',\n      relativeTo\n    );\n    return total;\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\n    }\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\n      precision,\n      'Precision cannot be \"minute\" because of RangeError above'\n    );\n    return ES.TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDurationToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    if (typeof Intl !== 'undefined' && typeof (Intl as any).DurationFormat !== 'undefined') {\n      return new (Intl as any).DurationFormat(locales, options).format(this);\n    }\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n    return ES.TemporalDurationToString(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() to compare Temporal.Duration');\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    if (ES.IsTemporalDuration(item)) {\n      return new Duration(\n        GetSlot(item, YEARS),\n        GetSlot(item, MONTHS),\n        GetSlot(item, WEEKS),\n        GetSlot(item, DAYS),\n        GetSlot(item, HOURS),\n        GetSlot(item, MINUTES),\n        GetSlot(item, SECONDS),\n        GetSlot(item, MILLISECONDS),\n        GetSlot(item, MICROSECONDS),\n        GetSlot(item, NANOSECONDS)\n      );\n    }\n    return ES.ToTemporalDuration(item);\n  }\n  static compare(\n    oneParam: Params['compare'][0],\n    twoParam: Params['compare'][1],\n    optionsParam: Params['compare'][2] = undefined\n  ) {\n    const one = ES.ToTemporalDuration(oneParam);\n    const two = ES.ToTemporalDuration(twoParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const relativeTo = ES.ToRelativeTemporalObject(options);\n    const y1 = GetSlot(one, YEARS);\n    const mon1 = GetSlot(one, MONTHS);\n    const w1 = GetSlot(one, WEEKS);\n    let d1 = GetSlot(one, DAYS);\n    const h1 = GetSlot(one, HOURS);\n    const min1 = GetSlot(one, MINUTES);\n    const s1 = GetSlot(one, SECONDS);\n    const ms1 = GetSlot(one, MILLISECONDS);\n    const µs1 = GetSlot(one, MICROSECONDS);\n    let ns1 = GetSlot(one, NANOSECONDS);\n    const y2 = GetSlot(two, YEARS);\n    const mon2 = GetSlot(two, MONTHS);\n    const w2 = GetSlot(two, WEEKS);\n    let d2 = GetSlot(two, DAYS);\n    const h2 = GetSlot(two, HOURS);\n    const min2 = GetSlot(two, MINUTES);\n    const s2 = GetSlot(two, SECONDS);\n    const ms2 = GetSlot(two, MILLISECONDS);\n    const µs2 = GetSlot(two, MICROSECONDS);\n    let ns2 = GetSlot(two, NANOSECONDS);\n    const shift1 = ES.CalculateOffsetShift(relativeTo, y1, mon1, w1, d1);\n    const shift2 = ES.CalculateOffsetShift(relativeTo, y2, mon2, w2, d2);\n    if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n      ({ days: d1 } = ES.UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n      ({ days: d2 } = ES.UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n    }\n    const totalNs1 = ES.TotalDurationNanoseconds(d1, h1, min1, s1, ms1, µs1, ns1, shift1);\n    const totalNs2 = ES.TotalDurationNanoseconds(d2, h2, min2, s2, ms2, µs2, ns2, shift2);\n    return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(totalNs1, totalNs2)));\n  }\n  [Symbol.toStringTag]!: 'Temporal.Duration';\n}\n\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n", "import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_MONTH, ISO_DAY, ISO_YEAR, CALENDAR, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\n\nconst ObjectCreate = Object.create;\n\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\n  constructor(\n    isoMonthParam: Params['constructor'][0],\n    isoDayParam: Params['constructor'][0],\n    calendarParam: string | Temporal.CalendarProtocol = 'iso8601',\n    referenceISOYearParam = 1972\n  ) {\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const isoDay = ES.ToIntegerWithTruncation(isoDayParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    const referenceISOYear = ES.ToIntegerWithTruncation(referenceISOYearParam);\n\n    ES.CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n  }\n\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n\n  with(temporalMonthDayLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalMonthDayLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialMonthDay = ES.PrepareTemporalFields(temporalMonthDayLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarMonthDayFromFields(calendar, fields, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalMonthDay(otherParam);\n    for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalMonthDayToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalMonthDayToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const receiverFieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n\n    const inputFieldNames = ES.CalendarFields(calendar, ['year'] as const);\n    const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n\n    // TODO: Use MergeLists abstract operation.\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n    const options = ObjectCreate(null);\n    options.overflow = 'reject';\n    return ES.CalendarDateFromFields(calendar, mergedFields, options);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalMonthDay(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalMonthDay(\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, ISO_DAY),\n        GetSlot(item, CALENDAR),\n        GetSlot(item, ISO_YEAR)\n      );\n    }\n    return ES.ToTemporalMonthDay(item, options);\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\n}\n\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n", "import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport type { Temporal } from '..';\n\nconst instant: typeof Temporal.Now['instant'] = () => {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  return new Instant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime: typeof Temporal.Now['plainDateTime'] = (\n  calendarLike,\n  temporalTimeZoneLike = ES.DefaultTimeZone()\n) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n  const inst = instant();\n  return ES.GetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO: typeof Temporal.Now['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const inst = instant();\n  return ES.GetPlainDateTimeFor(tZ, inst, 'iso8601');\n};\nconst zonedDateTime: typeof Temporal.Now['zonedDateTime'] = (\n  calendarLike,\n  temporalTimeZoneLike = ES.DefaultTimeZone()\n) => {\n  const tZ = ES.ToTemporalTimeZoneSlotValue(temporalTimeZoneLike);\n  const calendar = ES.ToTemporalCalendarSlotValue(calendarLike);\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO: typeof Temporal.Now['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return zonedDateTime('iso8601', temporalTimeZoneLike);\n};\nconst plainDate: typeof Temporal.Now['plainDate'] = (calendarLike, temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO: typeof Temporal.Now['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO: typeof Temporal.Now['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  return ES.TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZoneId: typeof Temporal.Now['timeZoneId'] = () => {\n  return ES.DefaultTimeZone();\n};\n\nexport const Now: typeof Temporal.Now = {\n  instant,\n  plainDateTime,\n  plainDateTimeISO,\n  plainDate,\n  plainDateISO,\n  plainTimeISO,\n  timeZoneId,\n  zonedDateTime,\n  zonedDateTimeISO,\n  [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n  value: 'Temporal.Now',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\n\nimport {\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\n\nconst ObjectAssign = Object.assign;\n\ntype TemporalTimeToStringOptions = {\n  unit: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['unit'];\n  increment: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['increment'];\n  roundingMode: Temporal.RoundingMode;\n};\n\nfunction TemporalTimeToString(\n  time: Temporal.PlainTime,\n  precision: ReturnType<typeof ES.ToSecondsStringPrecisionRecord>['precision'],\n  options: TemporalTimeToStringOptions | undefined = undefined\n) {\n  let hour = GetSlot(time, ISO_HOUR);\n  let minute = GetSlot(time, ISO_MINUTE);\n  let second = GetSlot(time, ISO_SECOND);\n  let millisecond = GetSlot(time, ISO_MILLISECOND);\n  let microsecond = GetSlot(time, ISO_MICROSECOND);\n  let nanosecond = GetSlot(time, ISO_NANOSECOND);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      increment,\n      unit,\n      roundingMode\n    ));\n  }\n\n  const hourString = ES.ISODateTimePartString(hour);\n  const minuteString = ES.ISODateTimePartString(minute);\n  const seconds = ES.FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  return `${hourString}:${minuteString}${seconds}`;\n}\n\nexport class PlainTime implements Temporal.PlainTime {\n  constructor(\n    isoHourParam = 0,\n    isoMinuteParam = 0,\n    isoSecondParam = 0,\n    isoMillisecondParam = 0,\n    isoMicrosecondParam = 0,\n    isoNanosecondParam = 0\n  ) {\n    const isoHour = isoHourParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoHourParam);\n    const isoMinute = isoMinuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinuteParam);\n    const isoSecond = isoSecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecondParam);\n    const isoMillisecond = isoMillisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecondParam);\n    const isoMicrosecond = isoMicrosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecondParam);\n    const isoNanosecond = isoNanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecondParam);\n\n    ES.RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n    CreateSlots(this);\n    SetSlot(this, ISO_HOUR, isoHour);\n    SetSlot(this, ISO_MINUTE, isoMinute);\n    SetSlot(this, ISO_SECOND, isoSecond);\n    SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n    SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n    SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n\n  with(temporalTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalTimeLike);\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\n\n    const fields = ES.ToTemporalTimeRecord(this);\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, partialTime);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainTime('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainTime('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const MAX_INCREMENTS = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\n\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode\n    ));\n\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalTime(otherParam);\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return true;\n  }\n\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return TemporalTimeToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n  }\n\n  toPlainDateTime(temporalDateParam: Params['toPlainDateTime'][0]): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    return ES.CreateTemporalDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    if (!ES.IsObject(item)) {\n      throw new TypeError('invalid argument');\n    }\n\n    const dateLike = item.plainDate;\n    if (dateLike === undefined) {\n      throw new TypeError('missing date property');\n    }\n    const temporalDate = ES.ToTemporalDate(dateLike);\n\n    const timeZoneLike = item.timeZone;\n    if (timeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property');\n    }\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneLike);\n\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return {\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND)\n    };\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    const overflow = ES.ToTemporalOverflow(options);\n    if (ES.IsTemporalTime(item)) {\n      return new PlainTime(\n        GetSlot(item, ISO_HOUR),\n        GetSlot(item, ISO_MINUTE),\n        GetSlot(item, ISO_SECOND),\n        GetSlot(item, ISO_MILLISECOND),\n        GetSlot(item, ISO_MICROSECOND),\n        GetSlot(item, ISO_NANOSECOND)\n      );\n    }\n    return ES.ToTemporalTime(item, overflow);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalTime(oneParam);\n    const two = ES.ToTemporalTime(twoParam);\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND] as const) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n    }\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\n}\n\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { DefineIntrinsic, GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  TIMEZONE_ID,\n  EPOCHNANOSECONDS,\n  ISO_YEAR,\n  ISO_MONTH,\n  ISO_DAY,\n  ISO_HOUR,\n  ISO_MINUTE,\n  ISO_SECOND,\n  ISO_MILLISECOND,\n  ISO_MICROSECOND,\n  ISO_NANOSECOND,\n  CreateSlots,\n  GetSlot,\n  SetSlot\n} from './slots';\nimport JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { TimeZoneParams as Params, TimeZoneReturn as Return } from './internaltypes';\n\nexport class TimeZone implements Temporal.TimeZone {\n  constructor(timeZoneIdentifierParam: string) {\n    // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n    //       This check exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: identifier is required');\n    }\n\n    const timeZoneIdentifier = ES.GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n    CreateSlots(this);\n    SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get id(): Return['id'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  getOffsetNanosecondsFor(instantParam: Params['getOffsetNanosecondsFor'][0]): Return['getOffsetNanosecondsFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (ES.IsTimeZoneOffsetString(id)) {\n      return ES.ParseTimeZoneOffsetString(id);\n    }\n\n    return ES.GetNamedTimeZoneOffsetNanoseconds(id, GetSlot(instant, EPOCHNANOSECONDS));\n  }\n  getOffsetStringFor(instantParam: Params['getOffsetStringFor'][0]): Return['getOffsetStringFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    return ES.GetOffsetStringFor(this, instant);\n  }\n  getPlainDateTimeFor(\n    instantParam: Params['getPlainDateTimeFor'][0],\n    calendarParam: Params['getPlainDateTimeFor'][1] = 'iso8601'\n  ): Return['getPlainDateTimeFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ES.ToTemporalInstant(instantParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return ES.GetPlainDateTimeFor(this, instant, calendar);\n  }\n  getInstantFor(\n    dateTimeParam: Params['getInstantFor'][0],\n    optionsParam: Params['getInstantFor'][1] = undefined\n  ): Return['getInstantFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n    const options = ES.GetOptionsObject(optionsParam);\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    return ES.GetInstantFor(this, dateTime, disambiguation);\n  }\n  getPossibleInstantsFor(dateTimeParam: Params['getPossibleInstantsFor'][0]): Return['getPossibleInstantsFor'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (ES.IsTimeZoneOffsetString(id)) {\n      const epochNs = ES.GetUTCEpochNanoseconds(\n        GetSlot(dateTime, ISO_YEAR),\n        GetSlot(dateTime, ISO_MONTH),\n        GetSlot(dateTime, ISO_DAY),\n        GetSlot(dateTime, ISO_HOUR),\n        GetSlot(dateTime, ISO_MINUTE),\n        GetSlot(dateTime, ISO_SECOND),\n        GetSlot(dateTime, ISO_MILLISECOND),\n        GetSlot(dateTime, ISO_MICROSECOND),\n        GetSlot(dateTime, ISO_NANOSECOND)\n      );\n      if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n      const offsetNs = ES.ParseTimeZoneOffsetString(id);\n      return [new Instant(JSBI.subtract(epochNs, JSBI.BigInt(offsetNs)))];\n    }\n\n    const possibleEpochNs = ES.GetNamedTimeZoneEpochNanoseconds(\n      id,\n      GetSlot(dateTime, ISO_YEAR),\n      GetSlot(dateTime, ISO_MONTH),\n      GetSlot(dateTime, ISO_DAY),\n      GetSlot(dateTime, ISO_HOUR),\n      GetSlot(dateTime, ISO_MINUTE),\n      GetSlot(dateTime, ISO_SECOND),\n      GetSlot(dateTime, ISO_MILLISECOND),\n      GetSlot(dateTime, ISO_MICROSECOND),\n      GetSlot(dateTime, ISO_NANOSECOND)\n    );\n    return possibleEpochNs.map((ns) => new Instant(ns));\n  }\n  getNextTransition(startingPointParam: Params['getNextTransition'][0]): Return['getNextTransition'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ES.ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds: JSBI | null = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = ES.GetNamedTimeZoneNextTransition(id, epochNanoseconds);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n  getPreviousTransition(startingPointParam: Params['getPreviousTransition'][0]): Return['getPreviousTransition'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ES.ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds: JSBI | null = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = ES.GetNamedTimeZonePreviousTransition(id, epochNanoseconds);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n  toString(): string {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIMEZONE_ID);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    const timeZoneSlotValue = ES.ToTemporalTimeZoneSlotValue(item);\n    return ES.ToTemporalTimeZoneObject(timeZoneSlotValue);\n  }\n  [Symbol.toStringTag]!: 'Temporal.TimeZone';\n}\n\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\nDefineIntrinsic('Temporal.TimeZone.prototype.getOffsetNanosecondsFor', TimeZone.prototype.getOffsetNanosecondsFor);\nDefineIntrinsic('Temporal.TimeZone.prototype.getPossibleInstantsFor', TimeZone.prototype.getPossibleInstantsFor);\n", "import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, CALENDAR, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainYearMonthParams as Params, PlainYearMonthReturn as Return } from './internaltypes';\n\nconst ObjectCreate = Object.create;\n\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\n  constructor(\n    isoYearParam: Params['constructor'][0],\n    isoMonthParam: Params['constructor'][1],\n    calendarParam: Params['constructor'][2] = 'iso8601',\n    referenceISODayParam: Params['constructor'][3] = 1\n  ) {\n    const isoYear = ES.ToIntegerWithTruncation(isoYearParam);\n    const isoMonth = ES.ToIntegerWithTruncation(isoMonthParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    const referenceISODay = ES.ToIntegerWithTruncation(referenceISODayParam);\n\n    ES.CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n  with(temporalYearMonthLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalYearMonthLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['month', 'monthCode', 'year'] as const);\n    let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    const partialYearMonth = ES.PrepareTemporalFields(temporalYearMonthLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n\n    return ES.CalendarYearMonthFromFields(calendar, fields, options);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalYearMonth(otherParam);\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    return ES.TemporalYearMonthToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalYearMonthToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const receiverFieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n\n    const inputFieldNames = ES.CalendarFields(calendar, ['day'] as const);\n    const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n\n    // TODO: Use MergeLists abstract operation.\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n    const options = ObjectCreate(null);\n    options.overflow = 'reject';\n    return ES.CalendarDateFromFields(calendar, mergedFields, options);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalYearMonth(item)) {\n      ES.ToTemporalOverflow(options); // validate and ignore\n      return ES.CreateTemporalYearMonth(\n        GetSlot(item, ISO_YEAR),\n        GetSlot(item, ISO_MONTH),\n        GetSlot(item, CALENDAR),\n        GetSlot(item, ISO_DAY)\n      );\n    }\n    return ES.ToTemporalYearMonth(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalYearMonth(oneParam);\n    const two = ES.ToTemporalYearMonth(twoParam);\n    return ES.CompareISODate(\n      GetSlot(one, ISO_YEAR),\n      GetSlot(one, ISO_MONTH),\n      GetSlot(one, ISO_DAY),\n      GetSlot(two, ISO_YEAR),\n      GetSlot(two, ISO_MONTH),\n      GetSlot(two, ISO_DAY)\n    );\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\n}\n\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n", "import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  ISO_HOUR,\n  INSTANT,\n  ISO_DAY,\n  ISO_MONTH,\n  ISO_YEAR,\n  ISO_MICROSECOND,\n  ISO_MILLISECOND,\n  ISO_MINUTE,\n  ISO_NANOSECOND,\n  ISO_SECOND,\n  TIME_ZONE,\n  GetSlot\n} from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { ZonedDateTimeParams as Params, ZonedDateTimeReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND, ZERO, HOUR_NANOS } from './ecmascript';\n\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\nconst ObjectCreate = Object.create;\n\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\n  constructor(\n    epochNanosecondsParam: bigint | JSBI,\n    timeZoneParam: string | Temporal.TimeZoneProtocol,\n    calendarParam: string | Temporal.CalendarProtocol = 'iso8601'\n  ) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    //       ToTemporalTimeZoneSlotValue(undefined) has a clear enough message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n  }\n  get timeZoneId(): Return['timeZoneId'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalTimeZoneIdentifier(GetSlot(this, TIME_ZONE));\n  }\n  get year(): Return['year'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get month(): Return['month'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get monthCode(): Return['monthCode'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get day(): Return['day'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get hour(): Return['hour'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_HOUR);\n  }\n  get minute(): Return['minute'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MINUTE);\n  }\n  get second(): Return['second'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_SECOND);\n  }\n  get millisecond(): Return['millisecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MILLISECOND);\n  }\n  get microsecond(): Return['microsecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MICROSECOND);\n  }\n  get nanosecond(): Return['nanosecond'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_NANOSECOND);\n  }\n  get era(): Return['era'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get eraYear(): Return['eraYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get epochSeconds(): Return['epochSeconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, BILLION));\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(ES.BigIntFloorDiv(value, MILLION));\n  }\n  get epochMicroseconds(): Return['epochMicroseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ES.ToBigIntExternal(ES.BigIntFloorDiv(value, THOUSAND));\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarYearOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get hoursInDay(): Return['hoursInDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const year = GetSlot(dt, ISO_YEAR);\n    const month = GetSlot(dt, ISO_MONTH);\n    const day = GetSlot(dt, ISO_DAY);\n    const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n    const tomorrowFields = ES.AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n    const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const todayNs = GetSlot(ES.GetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n    const tomorrowNs = GetSlot(ES.GetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n    const diffNs = JSBI.subtract(tomorrowNs, todayNs);\n    return ES.BigIntDivideToNumber(diffNs, HOUR_NANOS);\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get daysInYear(): Return['daysInYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n  get offset(): Return['offset'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.GetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n  with(temporalZonedDateTimeLike: Params['with'][0], optionsParam: Params['with'][1] = undefined): Return['with'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\n      throw new TypeError('invalid zoned-date-time-like');\n    }\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fieldNames: (keyof Temporal.ZonedDateTimeLike)[] = ES.CalendarFields(calendar, [\n      'day',\n      'hour',\n      'microsecond',\n      'millisecond',\n      'minute',\n      'month',\n      'monthCode',\n      'nanosecond',\n      'second',\n      'year'\n    ] as const);\n    fieldNames.push('offset');\n    let fields = ES.PrepareTemporalFields(this, fieldNames, ['offset']);\n    const partialZonedDateTime = ES.PrepareTemporalFields(temporalZonedDateTimeLike, fieldNames, 'partial');\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\n    fields = ES.PrepareTemporalFields(fields, fieldNames, ['offset']);\n\n    const disambiguation = ES.ToTemporalDisambiguation(options);\n    const offset = ES.ToTemporalOffset(options, 'prefer');\n\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } =\n      ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n    const offsetNs = ES.ParseTimeZoneOffsetString(fields.offset);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      'option',\n      offsetNs,\n      timeZone,\n      disambiguation,\n      offset,\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n  withPlainDate(temporalDateParam: Params['withPlainDate'][0]): Return['withPlainDate'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n\n    const temporalDate = ES.ToTemporalDate(temporalDateParam);\n\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n    const thisDt = dateTime(this);\n    const hour = GetSlot(thisDt, ISO_HOUR);\n    const minute = GetSlot(thisDt, ISO_MINUTE);\n    const second = GetSlot(thisDt, ISO_SECOND);\n    const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n    const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n    const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n\n    calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n\n    const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    const temporalTime = temporalTimeParam === undefined ? new PlainTime() : ES.ToTemporalTime(temporalTimeParam);\n\n    const thisDt = dateTime(this);\n    const year = GetSlot(thisDt, ISO_YEAR);\n    const month = GetSlot(thisDt, ISO_MONTH);\n    const day = GetSlot(thisDt, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    );\n    const instant = ES.GetInstantFor(timeZone, dt, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ES.ToTemporalTimeZoneSlotValue(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ES.ToTemporalCalendarSlotValue(calendarParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromZonedDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.AddDurationToOrSubtractDurationFromZonedDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.ToTemporalRoundingIncrement(roundTo);\n    const roundingMode = ES.ToTemporalRoundingMode(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnit(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    // first, round the underlying DateTime fields\n    const dt = dateTime(this);\n    let year = GetSlot(dt, ISO_YEAR);\n    let month = GetSlot(dt, ISO_MONTH);\n    let day = GetSlot(dt, ISO_DAY);\n    let hour = GetSlot(dt, ISO_HOUR);\n    let minute = GetSlot(dt, ISO_MINUTE);\n    let second = GetSlot(dt, ISO_SECOND);\n    let millisecond = GetSlot(dt, ISO_MILLISECOND);\n    let microsecond = GetSlot(dt, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n    const instantStart = ES.GetInstantFor(timeZone, dtStart, 'compatible');\n    const endNs = ES.AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = JSBI.subtract(endNs, JSBI.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n    if (JSBI.lessThanOrEqual(dayLengthNs, ZERO)) {\n      throw new RangeError('cannot round a ZonedDateTime in a calendar with zero or negative length days');\n    }\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      roundingIncrement,\n      smallestUnit,\n      roundingMode,\n      // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n      // (which can hold up to 104 days in nanoseconds)\n      JSBI.toNumber(dayLengthNs)\n    ));\n\n    // Now reset all DateTime fields but leave the TimeZone. The offset will\n    // also be retained if the new date/time values are still OK with the old\n    // offset. Otherwise the offset will be changed to be compatible with the\n    // new date/time values. If DST disambiguation is required, the `compatible`\n    // disambiguation algorithm will be used.\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      'option',\n      offsetNs,\n      timeZone,\n      'compatible',\n      'prefer',\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ES.ToTemporalZonedDateTime(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(optionsParam: Params['toString'][0] = undefined): string {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n    const showCalendar = ES.ToCalendarNameOption(options);\n    const digits = ES.ToFractionalSecondDigits(options);\n    const showOffset = ES.ToShowOffsetOption(options);\n    const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n    const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const showTimeZone = ES.ToTimeZoneNameOption(options);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    optionsParam: Params['toLocaleString'][1] = undefined\n  ): string {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const options = ES.GetOptionsObject(optionsParam);\n\n    const optionsCopy = ObjectCreate(null);\n    // This is not quite per specification, but this polyfill's DateTimeFormat\n    // already doesn't match the InitializeDateTimeFormat operation, and the\n    // access order might change anyway;\n    // see https://github.com/tc39/ecma402/issues/747\n    ES.CopyDataProperties(optionsCopy, options, ['timeZone']);\n\n    if (options.timeZone !== undefined) {\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\n    }\n\n    if (\n      optionsCopy.year === undefined &&\n      optionsCopy.month === undefined &&\n      optionsCopy.day === undefined &&\n      optionsCopy.weekday === undefined &&\n      optionsCopy.dateStyle === undefined &&\n      optionsCopy.hour === undefined &&\n      optionsCopy.minute === undefined &&\n      optionsCopy.second === undefined &&\n      optionsCopy.timeStyle === undefined &&\n      optionsCopy.dayPeriod === undefined &&\n      optionsCopy.timeZoneName === undefined\n    ) {\n      optionsCopy.timeZoneName = 'short';\n      // The rest of the defaults will be filled in by formatting the Instant\n    }\n\n    let timeZone = ES.ToTemporalTimeZoneIdentifier(GetSlot(this, TIME_ZONE));\n    if (ES.IsTimeZoneOffsetString(timeZone)) {\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\n      throw new RangeError('toLocaleString does not support offset string time zones');\n    }\n    timeZone = ES.GetCanonicalTimeZoneIdentifier(timeZone);\n    optionsCopy.timeZone = timeZone;\n\n    const formatter = new DateTimeFormat(locales, optionsCopy);\n\n    const localeCalendarIdentifier = ES.Call(customResolvedOptions, formatter, []).calendar;\n    const calendarIdentifier = ES.ToTemporalCalendarIdentifier(GetSlot(this, CALENDAR));\n    if (\n      calendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== calendarIdentifier\n    ) {\n      throw new RangeError(\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\n          ` in locale with calendar ${localeCalendarIdentifier}`\n      );\n    }\n\n    return formatter.format(GetSlot(this, INSTANT));\n  }\n  toJSON(): Return['toJSON'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\n  }\n  valueOf(): never {\n    throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n  }\n  startOfDay(): Return['startOfDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(\n      GetSlot(dt, ISO_YEAR),\n      GetSlot(dt, ISO_MONTH),\n      GetSlot(dt, ISO_DAY),\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      calendar\n    );\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const instant = ES.GetInstantFor(timeZone, dtStart, 'compatible');\n    return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n  toInstant(): Return['toInstant'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToDate(dateTime(this));\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.TemporalDateTimeToTime(dateTime(this));\n  }\n  toPlainDateTime(): Return['toPlainDateTime'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return dateTime(this);\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarYearMonthFromFields(calendar, fields);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode'] as const);\n    const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n    return ES.CalendarMonthDayFromFields(calendar, fields);\n  }\n  getISOFields(): Return['getISOFields'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const tz = GetSlot(this, TIME_ZONE);\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(dt, ISO_DAY),\n      isoHour: GetSlot(dt, ISO_HOUR),\n      isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n      isoMinute: GetSlot(dt, ISO_MINUTE),\n      isoMonth: GetSlot(dt, ISO_MONTH),\n      isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n      isoSecond: GetSlot(dt, ISO_SECOND),\n      isoYear: GetSlot(dt, ISO_YEAR),\n      offset: ES.GetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n      timeZone: tz\n    };\n  }\n  getCalendar(): Return['getCalendar'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalCalendarObject(GetSlot(this, CALENDAR));\n  }\n  getTimeZone(): Return['getTimeZone'] {\n    if (!ES.IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ES.ToTemporalTimeZoneObject(GetSlot(this, TIME_ZONE));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    const options = ES.GetOptionsObject(optionsParam);\n    if (ES.IsTemporalZonedDateTime(item)) {\n      ES.ToTemporalDisambiguation(options); // validate and ignore\n      ES.ToTemporalOffset(options, 'reject');\n      ES.ToTemporalOverflow(options);\n      return ES.CreateTemporalZonedDateTime(\n        GetSlot(item, EPOCHNANOSECONDS),\n        GetSlot(item, TIME_ZONE),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    return ES.ToTemporalZonedDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalZonedDateTime(oneParam);\n    const two = ES.ToTemporalZonedDateTime(twoParam);\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\n}\n\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\n\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\n  return ES.GetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n", "import { Instant } from './instant';\n\nimport JSBI from 'jsbi';\nimport { MILLION } from './ecmascript';\n\nexport function toTemporalInstant(this: Date) {\n  // Observable access to valueOf is not correct here, but unavoidable\n  const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n  return new Instant(epochNanoseconds);\n}\n", "// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\n\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n  Temporal.Instant,\n  Temporal.Calendar,\n  Temporal.PlainDate,\n  Temporal.PlainDateTime,\n  Temporal.Duration,\n  Temporal.PlainMonthDay,\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\n  Temporal.PlainTime,\n  Temporal.TimeZone,\n  Temporal.PlainYearMonth,\n  Temporal.ZonedDateTime\n];\nfor (const type of types) {\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n    descriptor.configurable = false;\n    descriptor.enumerable = false;\n    descriptor.writable = false;\n    Object.defineProperty(type, 'prototype', descriptor);\n  }\n}\n\nexport { Temporal, Intl, toTemporalInstant };\n"],
  "mappings": "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",
  "names": ["JSBI", "Array", "constructor", "length", "sign", "Object", "setPrototypeOf", "prototype", "__kMaxLength", "RangeError", "BigInt", "arg", "_", "Math", "floor", "t", "Number", "isFinite", "__zero", "__isOneDigitInt", "__oneDigit", "__fromDouble", "result", "__fromString", "SyntaxError", "primitive", "__toPrimitive", "TypeError", "toDebugString", "digit", "push", "toString", "join", "radix", "__toStringBasePowerOfTwo", "__toStringGeneric", "valueOf", "Error", "toNumber", "x", "xLength", "value", "__unsignedDigit", "xMsd", "__digit", "msdLeadingZeros", "__clz30", "xBitLength", "exponent", "currentDigit", "digitIndex", "shift", "mantissaHigh", "mantissaHighBitsUnset", "mantissaLow", "mantissaLowBitsUnset", "rounding", "__decideRounding", "signBit", "__kBitConversionInts", "__kBitConversionDouble", "unaryMinus", "__copy", "bitwiseNot", "__absoluteSubOne", "__trim", "__absoluteAddOne", "exponentiate", "y", "expValue", "__kMaxLengthBits", "neededDigits", "__initializeDigits", "msd", "__setDigit", "runningSquare", "multiply", "resultLength", "__clzmsd", "i", "__multiplyAccumulate", "divide", "__absoluteCompare", "resultSign", "divisor", "quotient", "__absoluteDivSmall", "__absoluteDivLarge", "remainder", "remainderDigit", "__absoluteModSmall", "add", "__absoluteAdd", "__absoluteSub", "subtract", "leftShift", "__rightShiftByAbsolute", "__leftShiftByAbsolute", "signedRightShift", "unsignedRightShift", "lessThan", "__compareToBigInt", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual", "equal", "notEqual", "bitwiseAnd", "max", "__absoluteAnd", "y1", "__absoluteOr", "__absoluteAndNot", "bitwiseXor", "__absoluteXor", "bitwiseOr", "asIntN", "n", "neededLength", "topDigit", "compareDigit", "__truncateToNBits", "__truncateAndSubFromPowerOfTwo", "asUintN", "bitsInTopDigit", "ADD", "__toNumeric", "__isBigInt", "LT", "__compare", "LE", "GT", "GE", "EQ", "__equalToNumber", "NE", "DataViewGetBigInt64", "dataview", "byteOffset", "littleEndian", "DataViewGetBigUint64", "h", "l", "high", "getUint32", "low", "DataViewSetBigInt64", "DataViewSetBigUint64", "d1", "setUint32", "newLength", "last", "pop", "mantissaBitsUnset", "topUnconsumedBit", "mask", "rawExponent", "digits", "kMantissaHighTopBit", "msdTopBit", "remainingMantissaBits", "__isWhitespace", "c", "string", "cursor", "current", "charCodeAt", "chars", "bitsPerChar", "__kMaxBitsPerChar", "roundup", "__kBitsPerCharTableMultiplier", "bitsMin", "__kBitsPerCharTableShift", "limDigit", "limAlpha", "parts", "partsBits", "done", "part", "bits", "d", "__fillFromParts", "charsSoFar", "multiplier", "m", "digitsSoFar", "__inplaceMultiplyAdd", "bitsInDigit", "partBits", "charMask", "charsRequired", "pos", "availableBits", "newDigit", "__kConversionChars", "consumedBits", "isRecursiveCall", "bitLength", "maxBitsPerChar", "minBitsPerChar", "secondHalfChars", "conqueror", "secondHalf", "input", "__halfDigit", "__setHalfDigit", "divisionResult", "firstHalf", "__unequalSign", "leftNegative", "__absoluteGreater", "bothNegative", "__absoluteLess", "xSign", "__compareToNumber", "ySign", "yAbs", "abs", "xDigit", "__compareToDouble", "yBitLength", "compareMantissa", "__comparisonResultToBool", "op", "carry", "r", "borrow", "inputLength", "__setDigitGrow", "yLength", "numPairs", "tmp", "tmpLength", "diff", "multiplicand", "accumulator", "accumulatorIndex", "m2Low", "m2High", "acc", "m1", "m1Low", "m1High", "rLow", "__imul", "rMid1", "rMid2", "rHigh", "__internalMultiplyAdd", "source", "factor", "summand", "rx", "ry", "mLow", "mHigh", "dLow", "dHigh", "pLow", "pMid1", "pMid2", "pHigh", "upperHalf", "lowerHalf", "dividend", "wantQuotient", "wantRemainder", "__halfDigitLength", "n2", "q", "qhatv", "__clz15", "__specialLeftShift", "u", "vn1", "halfDigitBuffer", "qhat", "j", "ujn", "rhat", "vn2", "ujn2", "__inplaceSub", "__inplaceAdd", "__inplaceRightShift", "startIndex", "halfDigits", "sum", "subtrahend", "r0", "sub", "r15", "addDigit", "__toShiftAmount", "digitShift", "bitsShift", "grow", "__rightShiftByMaximum", "mustRoundDown", "obj", "hint", "Symbol", "toPrimitive", "exoticToPrim", "call", "drop", "min", "limit", "msdBitsConsumed", "resultMsd", "minuendMsd", "len", "previous", "updated", "__digitPow", "base", "__kBitConversionBuffer", "ArrayBuffer", "Float64Array", "Int32Array", "clz32", "log", "LN2", "imul", "a", "b", "INTRINSICS", "MakeIntrinsicClass", "Class", "name", "Object", "defineProperty", "prototype", "Symbol", "toStringTag", "value", "writable", "enumerable", "configurable", "prop", "getOwnPropertyNames", "desc", "getOwnPropertyDescriptor", "DefineIntrinsic", "key", "Error", "GetIntrinsic", "intrinsic", "EPOCHNANOSECONDS", "TIMEZONE_ID", "ISO_YEAR", "ISO_MONTH", "ISO_DAY", "ISO_HOUR", "ISO_MINUTE", "ISO_SECOND", "ISO_MILLISECOND", "ISO_MICROSECOND", "ISO_NANOSECOND", "CALENDAR", "DATE_BRAND", "YEAR_MONTH_BRAND", "MONTH_DAY_BRAND", "INSTANT", "TIME_ZONE", "YEARS", "MONTHS", "WEEKS", "DAYS", "HOURS", "MINUTES", "SECONDS", "MILLISECONDS", "MICROSECONDS", "NANOSECONDS", "CALENDAR_ID", "globalSlots", "WeakMap", "GetSlotsSymbol", "for", "_a", "globalThis", "_GetSlots", "container", "get", "GetSlots", "CreateSlotsSymbol", "_b", "_CreateSlots", "set", "create", "CreateSlots", "HasSlot", "ids", "myslots", "every", "id", "GetSlot", "TypeError", "SetSlot", "slots", "tzComponent", "timeZoneID", "RegExp", "source", "join", "yearpart", "monthpart", "daypart", "datesplit", "timesplit", "offset", "offsetpart", "annotation", "zoneddatetime", "time", "yearmonth", "monthday", "fraction", "durationTime", "duration", "ArrayIncludes", "Array", "includes", "ArrayPrototypePush", "push", "IntlDateTimeFormat", "Intl", "DateTimeFormat", "MathMin", "Math", "min", "MathMax", "max", "MathAbs", "abs", "MathFloor", "floor", "MathSign", "sign", "MathTrunc", "trunc", "NumberIsNaN", "Number", "isNaN", "NumberIsFinite", "isFinite", "NumberCtor", "StringCtor", "String", "NumberMaxSafeInteger", "MAX_SAFE_INTEGER", "ObjectCreate", "ObjectGetOwnPropertyDescriptor", "ReflectApply", "Reflect", "apply", "ReflectOwnKeys", "ownKeys", "ZERO", "JSBI", "BigInt", "ONE", "SIXTY", "TWENTY_FOUR", "THOUSAND", "MILLION", "BILLION", "NEGATIVE_ONE", "HOUR_NANOS", "multiply", "MINUTE_NANOS", "DAY_NANOS", "NS_MIN", "NS_MAX", "YEAR_MIN", "YEAR_MAX", "BEFORE_FIRST_OFFSET_TRANSITION", "ABOUT_TEN_YEARS_NANOS", "ABOUT_ONE_YEAR_NANOS", "TWO_WEEKS_NANOS", "BUILTIN_CALENDAR_IDS", "isZero", "equal", "GetMethod", "obj", "methodName", "result", "Call", "target", "thisArgument", "argumentsList", "args", "arguments", "length", "IsObject", "ToNumber", "ToIntegerOrInfinity", "number", "integer", "IsIntegralNumber", "argument", "absValue", "ToString", "ToIntegerWithTruncation", "RangeError", "ToPositiveIntegerWithTruncation", "valueParam", "property", "ToIntegerIfIntegral", "divmod", "x", "y", "quotient", "divide", "remainder", "isNegativeJSBI", "lessThan", "signJSBI", "BUILTIN_CASTS", "Map", "BUILTIN_DEFAULTS", "SINGULAR_PLURAL_UNITS", "SINGULAR_FOR", "map", "e", "PLURAL_FOR", "p", "s", "UNITS_DESCENDING", "DURATION_FIELDS", "from", "keys", "sort", "IntlDateTimeFormatEnUsCache", "getIntlDateTimeFormatEnUsForTimeZone", "timeZoneIdentifier", "instance", "timeZone", "hour12", "era", "year", "month", "day", "hour", "minute", "second", "ToObject", "CopyDataProperties", "excludedKeys", "excludedValues", "nextKey", "some", "is", "propertyIsEnumerable", "call", "propValue", "IsTemporalInstant", "item", "IsTemporalTimeZone", "IsTemporalCalendar", "IsTemporalDuration", "IsTemporalDate", "IsTemporalTime", "IsTemporalDateTime", "IsTemporalYearMonth", "IsTemporalMonthDay", "IsTemporalZonedDateTime", "RejectTemporalLikeObject", "calendar", "ParseTemporalTimeZone", "stringIdent", "ianaName", "z", "ParseTemporalTimeZoneString", "PARSE.timeZoneID", "test", "ParseISODateTime", "GetCanonicalTimeZoneIdentifier", "FormatTimeZoneOffsetString", "ParseTimeZoneOffsetString", "MaybeFormatCalendarAnnotation", "showCalendar", "FormatCalendarAnnotation", "ToTemporalCalendarIdentifier", "isoString", "match", "PARSE.zoneddatetime", "exec", "yearString", "slice", "hasTime", "millisecond", "microsecond", "nanosecond", "offsetSign", "offsetHours", "offsetMinutes", "offsetSeconds", "offsetFraction", "endsWith", "annotations", "critical", "matchAll", "PARSE.annotation", "RejectDateTime", "ParseTemporalYearMonthString", "PARSE.yearmonth", "referenceISODay", "ParseTemporalMonthDayString", "PARSE.monthday", "referenceISOYear", "ParseTemporalInstant", "ParseTemporalInstantString", "offsetNs", "BalanceISODateTime", "epochNs", "GetUTCEpochNanoseconds", "RegulateISODate", "yearParam", "monthParam", "dayParam", "overflow", "RejectISODate", "ConstrainISODate", "RegulateTime", "hourParam", "minuteParam", "secondParam", "millisecondParam", "microsecondParam", "nanosecondParam", "RejectTime", "ConstrainTime", "ConstrainToRange", "ToTemporalDurationRecord", "ParseTemporalDurationString", "PARSE.duration", "element", "years", "months", "weeks", "days", "hours", "fHours", "minutesStr", "fMinutes", "secondsStr", "fSeconds", "minutes", "seconds", "excessNanoseconds", "nanoseconds", "microseconds", "milliseconds", "RejectDuration", "partial", "ToTemporalPartialDurationRecord", "temporalDurationLike", "undefined", "any", "ToTemporalOverflow", "options", "GetOption", "ToTemporalDisambiguation", "ToTemporalRoundingMode", "fallback", "ToTemporalOffset", "ToCalendarNameOption", "ToTemporalRoundingIncrement", "increment", "roundingIncrement", "integerIncrement", "ValidateTemporalRoundingIncrement", "dividend", "inclusive", "maximum", "ToFractionalSecondDigits", "normalizedOptions", "digitsValue", "fractionalSecondDigits", "digitCount", "ToSecondsStringPrecisionRecord", "smallestUnit", "precision", "unit", "REQUIRED", "GetTemporalUnit", "unitGroup", "requiredOrDefault", "extraValues", "allowedSingular", "singular", "category", "defaultVal", "allowedValues", "plural", "retval", "has", "ToRelativeTemporalObject", "relativeTo", "offsetBehaviour", "matchMinutes", "TemporalDateTimeToDate", "GetTemporalCalendarSlotValueWithISODefault", "fieldNames", "CalendarFields", "fields", "PrepareTemporalFields", "dateOptions", "InterpretTemporalDateTimeFields", "ToTemporalTimeZoneSlotValue", "IsBuiltinCalendar", "ASCIILowercase", "CreateTemporalDate", "CreateTemporalZonedDateTime", "InterpretISODateTimeOffset", "DefaultTemporalLargestUnit", "v", "LargerOfTwoTemporalUnits", "unit1", "unit2", "indexOf", "bag", "requiredFields", "emptySourceErrorMessage", "ToTemporalTimeRecord", "completeness", "field", "valueDesc", "ToTemporalDate", "itemParam", "GetPlainDateTimeFor", "CalendarDateFromFields", "ParseTemporalDateString", "date", "ToTemporalDateTime", "CreateTemporalDateTime", "ParseTemporalDateTimeString", "ToTemporalDuration", "ToTemporalInstant", "ns", "ToTemporalMonthDay", "calendarAbsent", "calendarFromItem", "ToTemporalCalendarSlotValue", "monthCode", "CalendarMonthDayFromFields", "CreateTemporalMonthDay", "ToTemporalTime", "ParseTemporalTimeString", "PARSE.time", "ToTemporalYearMonth", "CalendarYearMonthFromFields", "CreateTemporalYearMonth", "disambiguation", "offsetOpt", "matchMinute", "dt", "GetInstantFor", "subtract", "possibleInstants", "GetPossibleInstantsFor", "candidate", "candidateOffset", "GetOffsetNanosecondsFor", "roundedCandidateOffset", "toNumber", "RoundNumberToIncrement", "offsetStr", "timeZoneString", "toString", "DisambiguatePossibleInstants", "ToTemporalZonedDateTime", "ParseTemporalZonedDateTimeString", "CreateTemporalDateSlots", "isoYear", "isoMonth", "isoDay", "RejectDateRange", "TemporalPlainDate", "CreateTemporalDateTimeSlots", "h", "ms", "I", "RejectDateTimeRange", "TemporalPlainDateTime", "CreateTemporalMonthDaySlots", "TemporalPlainMonthDay", "CreateTemporalYearMonthSlots", "RejectYearMonthRange", "RejectToRange", "TemporalPlainYearMonth", "CreateTemporalZonedDateTimeSlots", "epochNanoseconds", "ValidateEpochNanoseconds", "instant", "TemporalZonedDateTime", "fieldNamesParam", "calendarObj", "CalendarMergeFields", "additionalFields", "CalendarDateAdd", "dateAddParam", "dateAdd", "CalendarDateUntil", "otherDate", "dateUntilParam", "dateUntil", "CalendarYear", "dateLike", "CalendarMonth", "CalendarMonthCode", "CalendarDay", "CalendarEra", "CalendarEraYear", "CalendarDayOfWeek", "CalendarDayOfYear", "CalendarWeekOfYear", "CalendarYearOfWeek", "CalendarDaysInWeek", "CalendarDaysInMonth", "CalendarDaysInYear", "CalendarMonthsInYear", "CalendarInLeapYear", "calendarLike", "ObjectImplementsTemporalCalendarProtocol", "object", "identifier", "slotValue", "ToTemporalCalendarObject", "CalendarEquals", "one", "two", "ThrowIfCalendarsNotEqual", "errorMessageAction", "cal1", "cal2", "ConsolidateCalendars", "sOne", "sTwo", "dateFromFieldsParam", "temporalTimeZoneLike", "ObjectImplementsTemporalTimeZoneProtocol", "ToTemporalTimeZoneIdentifier", "ToTemporalTimeZoneObject", "TimeZoneEquals", "dateTime", "TemporalDateTimeToTime", "getOffsetNanosecondsForParam", "timeZoneObject", "GetOffsetStringFor", "GetISOPartsFromEpoch", "Instant", "numInstants", "utcns", "dayBefore", "dayAfter", "add", "offsetBefore", "PlainDateTime", "earlier", "AddDateTime", "later", "possible", "getPossibleInstantsForParam", "ISOYearString", "ISODateTimePartString", "part", "FormatSecondsStringPart", "secs", "fractionNumber", "padStart", "TemporalInstantToString", "outputTimeZone", "FormatISOTimeZoneOffsetString", "TemporalDurationToString", "formatNumber", "num", "DurationSign", "roundingMode", "RoundDuration", "dateParts", "timeParts", "secondParts", "nsBigInt", "S", "msBigInt", "secondsBigInt", "total", "TotalDurationNanoseconds", "decimalPart", "unshift", "TemporalDateToString", "TemporalDateTimeToString", "RoundISODateTime", "TemporalMonthDayToString", "monthDay", "resultString", "calendarID", "calendarString", "TemporalYearMonthToString", "yearMonth", "TemporalZonedDateTimeToString", "zdt", "showTimeZone", "showOffset", "RoundInstant", "tz", "IsTimeZoneOffsetString", "string", "OFFSET", "resolvedOptions", "GetNamedTimeZoneOffsetNanoseconds", "GetNamedTimeZoneDateTimeParts", "reducedYear", "yearCycles", "nsIn400YearCycle", "reducedUTC", "utc", "offsetNanosecondsParam", "offsetNanoseconds", "hourString", "minuteString", "secondString", "post", "legacyDate", "Date", "setUTCHours", "setUTCFullYear", "getTime", "greaterThan", "epochMilliseconds", "nanos", "getUTCFullYear", "getUTCMonth", "getUTCDate", "getUTCHours", "getUTCMinutes", "getUTCSeconds", "getUTCMilliseconds", "GetFormatterParts", "datetime", "format", "parseFromEnUsFormat", "parts", "split", "toUpperCase", "maxJSBI", "afterLatestPossibleTzdbRuleChange", "SystemUTCEpochNanoSeconds", "GetNamedTimeZoneNextTransition", "oneYearLater", "uppercap", "leftNanos", "leftOffsetNs", "rightNanos", "rightOffsetNs", "bisect", "GetNamedTimeZonePreviousTransition", "afterLatestRule", "isFarFuture", "lowercap", "lastPrecomputed", "newTimeToCheck", "LeapYear", "ISODaysInMonth", "standard", "leapyear", "DayOfWeek", "m", "Y", "c", "dow", "DayOfYear", "WeekOfYear", "doy", "doj", "week", "mon", "w", "d", "l", "BalanceISOYearMonth", "BalanceISODate", "daysIn400YearCycle", "nCycles", "daysInYear", "testYear", "deltaDays", "BalanceTime", "NonNegativeBigIntDivmod", "daysParam", "hoursParam", "minutesParam", "secondsParam", "millisecondsParam", "microsecondsParam", "nanosecondsParam", "offsetShift", "NanosecondsToDays", "TemporalInstant", "dayLengthNs", "startNs", "start", "endNs", "end", "dtStart", "dtEnd", "daysNumber", "DifferenceISODateTime", "intermediateNs", "AddZonedDateTime", "daysBigInt", "isOverflow", "relativeInstant", "oneDayFartherNs", "relativeNs", "greaterThanOrEqual", "BalanceDuration", "largestUnit", "BalancePossiblyInfiniteDuration", "nanosecondsBigInt", "microsecondsBigInt", "millisecondsBigInt", "minutesBigInt", "hoursBigInt", "UnbalanceDurationRelative", "yearsParam", "monthsParam", "weeksParam", "relativeToParam", "TemporalDuration", "signBI", "oneYear", "oneMonth", "oneWeek", "newRelativeTo", "untilOptions", "untilResult", "oneYearMonths", "oneYearDays", "MoveRelativeDate", "oneMonthDays", "oneWeekDays", "CalculateOffsetShift", "after", "CreateNegatedTemporalDuration", "propSign", "DifferenceISODate", "y1", "m1", "d1", "y2", "m2", "d2", "CompareISODate", "mid", "AddISODate", "midSign", "larger", "smaller", "DifferenceTime", "h1", "min1", "s1", "ms1", "n", "ns1", "h2", "min2", "s2", "ms2", "ns2", "DifferenceInstant", "diff", "y1Param", "mon1Param", "d1Param", "mon2", "f", "mon1", "timeSign", "date1", "date2", "dateLargestUnit", "CopyOptions", "DifferenceZonedDateTime", "nsDiff", "timeRemainderNs", "intermediate", "GetDifferenceSettings", "op", "group", "disallowed", "fallbackSmallest", "smallestLargestDefaultUnit", "ALLOWED_UNITS", "reduce", "allowed", "unitInfo", "NegateTemporalRoundingMode", "defaultLargestUnit", "DifferenceTemporalInstant", "operation", "otherParam", "other", "settings", "onens", "twons", "DifferenceTemporalPlainDate", "plainDate", "DifferenceTemporalPlainDateTime", "plainDateTime", "DifferenceTemporalPlainTime", "plainTime", "DifferenceTemporalPlainYearMonth", "thisFields", "thisDate", "otherFields", "DifferenceTemporalZonedDateTime", "zonedDateTime", "AdjustRoundedDurationDays", "AddTime", "AddDuration", "w1", "w2", "G", "dateDuration1", "dateDuration2", "differenceOptions", "AddInstant", "i", "sum", "addedDate", "dtIntermediate", "AddDurationToOrSubtractDurationFromDuration", "optionsParam", "GetOptionsObject", "AddDurationToOrSubtractDurationFromInstant", "durationLike", "ToLimitedTemporalDuration", "disallowedProperties", "record", "AddDurationToOrSubtractDurationFromPlainDateTime", "AddDurationToOrSubtractDurationFromPlainTime", "temporalTime", "AddDurationToOrSubtractDurationFromPlainYearMonth", "fieldsCopy", "startDate", "Duration", "nextMonth", "endOfMonth", "durationToAdd", "optionsCopy", "AddDurationToOrSubtractDurationFromZonedDateTime", "quantity", "mode", "tiebreaker", "tie", "expandIsNearer", "wholeDays", "roundedRemainder", "nsPerTimeUnit", "RoundTime", "nsPerUnit", "rounded", "DaysUntil", "MoveRelativeZonedDateTime", "direction", "dayStart", "dayEnd", "zdtRelative", "dayLength", "yearsDuration", "yearsLater", "yearsMonthsWeeksLater", "wholeDaysLater", "yearsPassed", "oldRelativeTo", "divisor", "BigIntDivideToNumber", "yearsMonths", "yearsMonthsLater", "allNanoseconds", "ComparisonResult", "BigIntFloorDiv", "left", "right", "ToBigIntExternal", "arg", "jsbiBI", "ToBigInt", "prim", "toPrimFn", "toPrimitive", "now", "DefaultTimeZone", "CreateOnePropObject", "propName", "o", "str", "replace", "code", "charCodeAt", "fromCharCode", "PARSE.offset", "getState", "leftParam", "rightParam", "lstateParam", "rstateParam", "lstate", "rstate", "middle", "mstate", "DATE", "YM", "MD", "TIME", "DATETIME", "INST", "ORIGINAL", "TZ_RESOLVED", "CAL_ID", "LOCALE", "OPTIONS", "descriptor", "ObjectAssign", "assign", "ObjectHasOwnProperty", "hasOwnProperty", "getPropLazy", "val", "DateTimeFormatImpl", "locale", "this", "hasOptions", "original", "ro", "clonedResolved", "dateAmend", "yearMonthAmend", "monthDayAmend", "timeAmend", "datetimeAmend", "instantAmend", "supportedLocalesOf", "locales", "propertyDescriptors", "rest", "formatter", "extractOverrides", "formatRange", "a", "b", "isTemporalObject", "sameTemporalType", "aa", "aformatter", "bb", "bformatter", "formatToParts", "formatRangeToParts", "amend", "amended", "opt", "weekday", "timeZoneName", "dateStyle", "hasTimeOptions", "dayPeriod", "timeStyle", "hasDateOptions", "ES.IsTemporalDate", "ES.IsTemporalTime", "ES.IsTemporalDateTime", "ES.IsTemporalZonedDateTime", "ES.IsTemporalYearMonth", "ES.IsTemporalMonthDay", "ES.IsTemporalInstant", "temporalObj", "main", "DateTime", "ES.GetInstantFor", "ES.ToTemporalCalendarIdentifier", "constructor", "ES.ToBigInt", "ES.ValidateEpochNanoseconds", "epochSeconds", "ES.BigIntFloorDiv", "epochMicroseconds", "ES.ToBigIntExternal", "ES.AddDurationToOrSubtractDurationFromInstant", "until", "ES.DifferenceTemporalInstant", "since", "round", "roundToParam", "roundTo", "ES.CreateOnePropObject", "ES.GetOptionsObject", "ES.ToTemporalRoundingIncrement", "ES.ToTemporalRoundingMode", "ES.GetTemporalUnit", "ES.REQUIRED", "ES.ValidateTemporalRoundingIncrement", "roundedNs", "ES.RoundInstant", "equals", "ES.ToTemporalInstant", "digits", "ES.ToFractionalSecondDigits", "ES.ToTemporalTimeZoneSlotValue", "ES.ToSecondsStringPrecisionRecord", "ES.TemporalInstantToString", "toJSON", "toLocaleString", "valueOf", "toZonedDateTime", "ES.IsObject", "ES.ToTemporalCalendarSlotValue", "ES.CreateTemporalZonedDateTime", "toZonedDateTimeISO", "timeZoneParam", "static", "epochSecondsParam", "ES.ToNumber", "epochMillisecondsParam", "epochMicrosecondsParam", "epochNanosecondsParam", "oneParam", "twoParam", "oneNs", "twoNs", "ArraySort", "ObjectEntries", "entries", "OriginalSet", "Set", "SetPrototypeAdd", "SetPrototypeValues", "values", "impl", "Calendar", "idParam", "ES.ToString", "ES.IsBuiltinCalendar", "ES.ASCIILowercase", "ES.IsTemporalCalendar", "dateFromFields", "yearMonthFromFields", "monthDayFromFields", "fieldsArray", "delete", "mergeFields", "fieldsParam", "additionalFieldsParam", "ES.ToObject", "ES.CopyDataProperties", "additionalFieldsCopy", "additionalKeys", "overriddenKeys", "fieldKeysToIgnore", "merged", "fieldsKeys", "ES.Call", "dateParam", "durationParam", "ES.ToTemporalDate", "ES.ToTemporalDuration", "ES.ToTemporalOverflow", "ES.BalanceDuration", "eraYear", "dayOfWeek", "dayOfYear", "weekOfYear", "yearOfWeek", "daysInWeek", "daysInMonth", "monthsInYear", "inLeapYear", "ES.ToTemporalCalendarObject", "monthCodeNumberPart", "startsWith", "buildMonthCode", "leap", "resolveNonLunisolarMonth", "calendarDate", "monthsPerYear", "ES.RejectToRange", "ES.ConstrainToRange", "numberPart", "calendarSlotValue", "ES.PrepareTemporalFields", "ES.RegulateISODate", "ES.CreateTemporalDate", "RegulateISOYearMonth", "ES.CreateTemporalYearMonth", "useYear", "ES.CreateTemporalMonthDay", "ix", "ES.AddISODate", "ES.DifferenceISODate", "ES.DayOfWeek", "ES.DayOfYear", "ES.WeekOfYear", "ES.ISODaysInMonth", "ES.LeapYear", "OneObjectCache", "cacheToClone", "calls", "hits", "misses", "performance", "entry", "MAX_CACHE_ENTRIES", "report", "setObject", "objectMap", "cache", "toUtcIsoDateString", "ES.ISOYearString", "ES.ISODateTimePartString", "simpleDateDiff", "HelperBase", "eraLength", "hasEra", "erasBeginMidYear", "getFormatter", "isoToCalendarDate", "isoDate", "JSON", "stringify", "func", "cached", "dateTimeFormat", "type", "matches", "monthExtra", "normalize", "toLowerCase", "reviseIntlEra", "checkIcuBugs", "adjustCalendarDate", "forEach", "keyReverse", "validateCalendarDate", "constantEra", "calendarDateParam", "fromLegacyDate", "calendarType", "largestMonth", "regulateMonthDayNaive", "maximumMonthLength", "calendarToIsoDate", "originalDate", "keyOriginal", "isoEstimate", "estimateIsoDate", "calculateSameMonthResult", "diffDays", "testIsoEstimate", "addDaysIso", "minimumMonthLength", "testCalendarDate", "roundtripEstimate", "diffTotalDaysEstimate", "compareCalendarDates", "oldRoundtripEstimate", "oldSign", "temporalToCalendarDate", "date1Param", "date2Param", "ES.ComparisonResult", "regulateDate", "addDaysCalendar", "addedIso", "addMonthsCalendar", "absMonths", "oldCalendarDate", "daysInPreviousMonth", "monthsInOldYear", "addCalendar", "addedYears", "addedMonths", "initialDays", "untilCalendar", "calendarOne", "calendarTwo", "calendarDaysUntil", "totalDays", "diffYears", "diffInYearSign", "current", "next", "addedIsoDate", "addedCalendarDate", "endOfMonthIso", "previousMonthDate", "previousMonth", "lastDayOfPreviousMonthIso", "startOfCalendarYear", "startOfCalendarMonth", "oneIso", "twoIso", "isoDaysUntil", "closestCalendar", "closestIso", "calendarOfStartDateIso", "calendarYear", "roundTripCalendarDate", "HebrewHelper", "Tishri", "regular", "Heshvan", "Kislev", "Tevet", "Shevat", "Adar", "Nisan", "Iyar", "Sivan", "Tamuz", "Av", "Elul", "minMaxMonthLength", "minOrMax", "getMonthCode", "monthInfo", "find", "IslamicBaseHelper", "DAYS_PER_ISLAMIC_YEAR", "DAYS_PER_ISO_YEAR", "IslamicHelper", "IslamicUmalquraHelper", "IslamicTblaHelper", "IslamicCivilHelper", "IslamicRgsaHelper", "IslamicCcHelper", "PersianHelper", "IndianHelper", "nextYear", "vulnerableToBceBug", "toLocaleDateString", "isGregorianLeapYear", "getMonthInfo", "GregorianBaseHelper", "originalEras", "super", "v8IsVulnerableToJulianBug", "calendarIsVulnerableToJulianBug", "eras", "anchorEra", "adjustEras", "erasParam", "reverseOf", "filter", "isAnchor", "anchorEpoch", "hasYearZero", "reversedEra", "isoEpoch", "e1", "e2", "lastEraReversed", "genericName", "completeEraYear", "checkField", "currentValue", "eraFromYear", "adjustedCalendarDate", "matchingEra", "ES.CompareISODate", "OrthodoxBaseHelper", "EthioaaHelper", "CopticHelper", "EthiopicHelper", "RocHelper", "BuddhistHelper", "GregoryHelper", "JapaneseHelper", "ChineseBaseHelper", "getMonthList", "getCalendarDate", "daysPastFeb1", "isoStringFeb1", "setUTCDate", "newYearGuess", "calendarMonthString", "tv", "calendarDay", "calendarYearToVerify", "isoDaysDelta", "oldCalendarDay", "oldMonthString", "monthIndex", "done", "monthString", "withoutML", "monthEntries", "matchingMonthEntry", "ChineseHelper", "DangiHelper", "NonIsoCalendar", "helper", "getCacheForObject", "added", "isoAdded", "newTemporalObject", "cacheOne", "cacheTwo", "startOfYear", "startOfMonthCalendar", "startOfNextMonthCalendar", "startOfYearCalendar", "startOfNextYearCalendar", "Helper", "PlainDate", "isoYearParam", "isoMonthParam", "isoDayParam", "calendarParam", "ES.CreateTemporalDateSlots", "ES.ToIntegerWithTruncation", "calendarId", "ES.CalendarEra", "ES.CalendarEraYear", "ES.CalendarYear", "ES.CalendarMonth", "ES.CalendarMonthCode", "ES.CalendarDay", "ES.CalendarDayOfWeek", "ES.CalendarDayOfYear", "ES.CalendarWeekOfYear", "ES.CalendarYearOfWeek", "ES.CalendarDaysInWeek", "ES.CalendarDaysInMonth", "ES.CalendarDaysInYear", "ES.CalendarMonthsInYear", "ES.CalendarInLeapYear", "with", "temporalDateLike", "ES.RejectTemporalLikeObject", "ES.CalendarFields", "ES.CalendarMergeFields", "ES.CalendarDateFromFields", "withCalendar", "ES.CalendarDateAdd", "ES.CreateNegatedTemporalDuration", "ES.DifferenceTemporalPlainDate", "slot", "ES.CalendarEquals", "ES.TemporalDateToString", "ES.ToCalendarNameOption", "toPlainDateTime", "temporalTimeParam", "ES.CreateTemporalDateTime", "ES.ToTemporalTime", "ES.IsTemporalTimeZone", "timeZoneLike", "toPlainYearMonth", "ES.CalendarYearMonthFromFields", "toPlainMonthDay", "ES.CalendarMonthDayFromFields", "getISOFields", "getCalendar", "ES.CreateTemporalDateTimeSlots", "temporalDateTimeLike", "ES.InterpretTemporalDateTimeFields", "withPlainTime", "withPlainDate", "temporalDateParam", "temporalDate", "ES.ConsolidateCalendars", "ES.AddDurationToOrSubtractDurationFromPlainDateTime", "ES.DifferenceTemporalPlainDateTime", "ES.RoundISODateTime", "ES.ToTemporalDateTime", "ES.TemporalDateTimeToString", "ES.ToTemporalDisambiguation", "toPlainDate", "ES.TemporalDateTimeToDate", "toPlainTime", "ES.TemporalDateTimeToTime", "isoHour", "isoMicrosecond", "isoMillisecond", "isoMinute", "isoNanosecond", "isoSecond", "val1", "val2", "ES.ToIntegerIfIntegral", "ES.RejectDuration", "ES.IsTemporalDuration", "ES.DurationSign", "blank", "partialDuration", "negated", "ES.AddDurationToOrSubtractDurationFromDuration", "ES.DefaultTemporalLargestUnit", "ES.ToRelativeTemporalObject", "smallestUnitPresent", "ES.LargerOfTwoTemporalUnits", "largestUnitPresent", "ES.UnbalanceDurationRelative", "ES.RoundDuration", "ES.AdjustRoundedDurationDays", "BalanceDurationRelative", "ES.MoveRelativeZonedDateTime", "balanceResult", "ES.BalancePossiblyInfiniteDuration", "Infinity", "ES.TemporalDurationToString", "DurationFormat", "console", "warn", "B", "shift1", "ES.CalculateOffsetShift", "shift2", "totalNs1", "ES.TotalDurationNanoseconds", "totalNs2", "PlainMonthDay", "referenceISOYearParam", "ES.CreateTemporalMonthDaySlots", "temporalMonthDayLike", "ES.ToTemporalMonthDay", "ES.TemporalMonthDayToString", "receiverFieldNames", "inputFieldNames", "mergedFields", "ES.SystemUTCEpochNanoSeconds", "ES.DefaultTimeZone", "tZ", "ES.GetPlainDateTimeFor", "plainDateTimeISO", "Now", "plainDateISO", "plainTimeISO", "timeZoneId", "zonedDateTimeISO", "TemporalTimeToString", "ES.RoundTime", "ES.FormatSecondsStringPart", "PlainTime", "isoHourParam", "isoMinuteParam", "isoSecondParam", "isoMillisecondParam", "isoMicrosecondParam", "isoNanosecondParam", "ES.RejectTime", "temporalTimeLike", "partialTime", "ES.ToTemporalTimeRecord", "ES.RegulateTime", "ES.AddDurationToOrSubtractDurationFromPlainTime", "ES.DifferenceTemporalPlainTime", "TimeZone", "timeZoneIdentifierParam", "ES.GetCanonicalTimeZoneIdentifier", "getOffsetNanosecondsFor", "instantParam", "ES.IsTimeZoneOffsetString", "ES.ParseTimeZoneOffsetString", "ES.GetNamedTimeZoneOffsetNanoseconds", "getOffsetStringFor", "ES.GetOffsetStringFor", "getPlainDateTimeFor", "getInstantFor", "dateTimeParam", "getPossibleInstantsFor", "ES.GetUTCEpochNanoseconds", "possibleEpochNs", "GetNamedTimeZoneEpochNanoseconds", "nsEarlier", "nsLater", "earliest", "latest", "getNextTransition", "startingPointParam", "startingPoint", "ES.GetNamedTimeZoneNextTransition", "getPreviousTransition", "ES.GetNamedTimeZonePreviousTransition", "ES.ToTemporalTimeZoneObject", "PlainYearMonth", "referenceISODayParam", "ES.CreateTemporalYearMonthSlots", "temporalYearMonthLike", "ES.AddDurationToOrSubtractDurationFromPlainYearMonth", "ES.DifferenceTemporalPlainYearMonth", "ES.ToTemporalYearMonth", "ES.TemporalYearMonthToString", "customResolvedOptions", "ZonedDateTime", "ES.CreateTemporalZonedDateTimeSlots", "ES.ToTemporalTimeZoneIdentifier", "hoursInDay", "today", "tomorrowFields", "tomorrow", "todayNs", "tomorrowNs", "ES.BigIntDivideToNumber", "ES.GetOffsetNanosecondsFor", "temporalZonedDateTimeLike", "ES.ToTemporalOffset", "ES.InterpretISODateTimeOffset", "thisDt", "withTimeZone", "ES.AddDurationToOrSubtractDurationFromZonedDateTime", "ES.DifferenceTemporalZonedDateTime", "instantStart", "ES.AddZonedDateTime", "lessThanOrEqual", "ES.ToTemporalZonedDateTime", "ES.TimeZoneEquals", "ToShowOffsetOption", "ToTimeZoneNameOption", "ES.TemporalZonedDateTimeToString", "localeCalendarIdentifier", "calendarIdentifier", "startOfDay", "toInstant", "getTimeZone", "toTemporalInstant", "types", "Temporal.Instant", "Temporal.Calendar", "Temporal.PlainDate", "Temporal.PlainDateTime", "Temporal.Duration", "Temporal.PlainMonthDay", "Temporal.PlainTime", "Temporal.TimeZone", "Temporal.PlainYearMonth", "Temporal.ZonedDateTime"]
}
