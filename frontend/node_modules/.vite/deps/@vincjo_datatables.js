import "./chunk-AYNHEKRI.js";
import {
  derived,
  writable
} from "./chunk-T4PJOUKD.js";
import {
  HtmlTagHydration,
  SvelteComponent,
  add_iframe_resize_listener,
  add_render_callback,
  append_hydration,
  append_styles,
  assign,
  attr,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  component_subscribe,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach,
  element,
  empty,
  ensure_array_like,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  get_svelte_dataset,
  group_outros,
  init,
  insert_hydration,
  listen,
  mount_component,
  noop,
  null_to_empty,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  set_data,
  set_input_value,
  set_style,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base
} from "./chunk-UU6HQWOC.js";
import "./chunk-2GBBIY5G.js";
import {
  __publicField
} from "./chunk-EQCVQC35.js";

// node_modules/@vincjo/datatables/dist/local/utils.js
var isNull = (value) => {
  if (value === null || value === void 0 || value === "")
    return true;
  return false;
};
var isNotNull = (value) => {
  return !isNull(value);
};
var parseField = (field, uid) => {
  const identifier = uid ?? field.toString();
  if (typeof field === "string") {
    return {
      callback: (row) => row[field],
      identifier,
      key: field
    };
  } else if (typeof field === "function") {
    return {
      callback: field,
      identifier,
      key: void 0
    };
  }
  throw new Error(`Invalid field argument: ${String(field)}`);
};

// node_modules/@vincjo/datatables/dist/local/Comparator.js
var check = {
  isLike: (entry, value) => {
    return stringify(entry).indexOf(stringify(value)) > -1;
  },
  isNotLike: (entry, value) => {
    return stringify(entry).indexOf(stringify(value)) === -1;
  },
  startsWith: (entry, value) => {
    return stringify(entry).startsWith(stringify(value));
  },
  endsWith: (entry, value) => {
    return stringify(entry).endsWith(stringify(value));
  },
  isEqualTo: (entry, value) => {
    return stringify(entry) === stringify(value);
  },
  isNotEqualTo: (entry, value) => {
    return stringify(entry) !== stringify(value);
  },
  isGreaterThan: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry > value;
  },
  isGreaterThanOrEqualTo: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry >= value;
  },
  isLessThan: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry < value;
  },
  isLessThanOrEqualTo: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry <= value;
  },
  isBetween: (entry, value) => {
    if (isNull2(entry))
      return false;
    const [min, max] = value;
    return entry >= min && entry <= max;
  },
  isStrictlyBetween: (entry, value) => {
    if (isNull2(entry))
      return false;
    const [min, max] = value;
    return entry > min && entry < max;
  },
  isTrue: (entry, _) => {
    return entry === true;
  },
  isFalse: (entry, _) => {
    return entry === false;
  },
  isNull: (entry, _) => {
    return entry === null || entry === void 0;
  },
  isNotNull: (entry, _) => {
    return entry === null || entry === void 0 ? false : true;
  },
  whereIn: (entry, values = []) => {
    if (isNull2(entry))
      return false;
    if (values.length === 0)
      return false;
    for (const { value, comparator } of values) {
      if (comparator(entry, value)) {
        return true;
      }
    }
    return false;
  },
  /**
   * @deprecated use "isLike" instead
   * @since 1.12.7 2023-09-27
   */
  contains: (entry, value) => {
    return check.isLike(entry, value);
  }
};
function stringify(value = null) {
  return String(value).toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function isNull2(entry) {
  if (entry === null || entry === void 0)
    return true;
}

// node_modules/@vincjo/datatables/dist/local/handlers/EventHandler.js
var EventHandler = class {
  constructor() {
    __publicField(this, "events", {
      change: [],
      clearFilters: [],
      clearSearch: []
    });
    __publicField(this, "triggerChange", writable(0));
  }
  // legacy
  add(event, callback) {
    this.events[event].push(callback);
  }
  trigger(event) {
    for (const callback of this.events[event]) {
      callback();
    }
    if (event === "change") {
      this.triggerChange.update((store) => {
        return store + 1;
      });
    }
  }
};

// node_modules/@vincjo/datatables/dist/local/Context.js
var Context = class {
  constructor(data, params) {
    __publicField(this, "event");
    __publicField(this, "rowsPerPage");
    __publicField(this, "pageNumber");
    __publicField(this, "search");
    __publicField(this, "filters");
    __publicField(this, "filterCount");
    __publicField(this, "rawRows");
    __publicField(this, "filteredRows");
    __publicField(this, "pagedRows");
    __publicField(this, "rowCount");
    __publicField(this, "pages");
    __publicField(this, "pagesWithEllipsis");
    __publicField(this, "pageCount");
    __publicField(this, "sort");
    __publicField(this, "selected");
    __publicField(this, "selectScope");
    __publicField(this, "isAllSelected");
    this.event = new EventHandler();
    this.rowsPerPage = writable(params.rowsPerPage);
    this.pageNumber = writable(1);
    this.search = writable({});
    this.filters = writable([]);
    this.filterCount = this.createFilterCount();
    this.rawRows = writable(data);
    this.filteredRows = this.createFilteredRows();
    this.pagedRows = this.createPagedRows();
    this.rowCount = this.createRowCount();
    this.pages = this.createPages();
    this.pagesWithEllipsis = this.createPagesWithEllipsis();
    this.pageCount = this.createPageCount();
    this.sort = writable({});
    this.selected = writable([]);
    this.selectScope = writable("all");
    this.isAllSelected = this.createIsAllSelected();
  }
  createFilterCount() {
    return derived(this.filters, ($filters) => $filters.length);
  }
  createFilteredRows() {
    return derived([this.rawRows, this.search, this.filters], ([$rawRows, $search, $filters]) => {
      if ($search.value) {
        $rawRows = $rawRows.filter((row) => {
          const fields = $search.scope ?? Object.keys(row);
          const scope = fields.map((field) => {
            const { callback } = parseField(field);
            return callback;
          });
          return scope.some((callback) => {
            return this.match(callback(row), $search.value);
          });
        });
        this.pageNumber.set(1);
        this.selected.set([]);
        this.event.trigger("change");
      }
      if ($filters.length > 0) {
        $filters.forEach((filter) => {
          return $rawRows = $rawRows.filter((row) => {
            const entry = filter.callback(row);
            return this.match(entry, filter.value, filter.comparator);
          });
        });
        this.pageNumber.set(1);
        this.selected.set([]);
        this.event.trigger("change");
      }
      return $rawRows;
    });
  }
  match(entry, value, compare = null) {
    if (isNull(value)) {
      return true;
    }
    if (!entry && compare) {
      return compare(entry, value);
    }
    if (!entry)
      return check.isLike(entry, value);
    else if (typeof entry === "object") {
      return Object.keys(entry).some((k) => {
        return this.match(entry[k], value, compare);
      });
    }
    if (!compare)
      return check.isLike(entry, value);
    return compare(entry, value);
  }
  createPagedRows() {
    return derived([this.filteredRows, this.rowsPerPage, this.pageNumber], ([$filteredRows, $rowsPerPage, $pageNumber]) => {
      if (!$rowsPerPage) {
        return $filteredRows;
      }
      return $filteredRows.slice(($pageNumber - 1) * $rowsPerPage, $pageNumber * $rowsPerPage);
    });
  }
  createRowCount() {
    return derived([this.filteredRows, this.pageNumber, this.rowsPerPage], ([$filteredRows, $pageNumber, $rowsPerPage]) => {
      const total = $filteredRows.length;
      if (!$rowsPerPage) {
        return { total, start: 1, end: total };
      }
      return {
        total,
        start: $pageNumber * $rowsPerPage - $rowsPerPage + 1,
        end: Math.min($pageNumber * $rowsPerPage, $filteredRows.length)
      };
    });
  }
  createPages() {
    return derived([this.rowsPerPage, this.filteredRows], ([$rowsPerPage, $filteredRows]) => {
      if (!$rowsPerPage) {
        return [1];
      }
      const pages = Array.from(Array(Math.ceil($filteredRows.length / $rowsPerPage)));
      return pages.map((_, i) => i + 1);
    });
  }
  createPagesWithEllipsis() {
    return derived([this.pages, this.pageNumber], ([$pages, $pageNumber]) => {
      if ($pages.length <= 7) {
        return $pages;
      }
      const ellipse = null;
      const firstPage = 1;
      const lastPage = $pages.length;
      if ($pageNumber <= 4) {
        return [
          ...$pages.slice(0, 5),
          ellipse,
          lastPage
        ];
      } else if ($pageNumber < $pages.length - 3) {
        return [
          firstPage,
          ellipse,
          ...$pages.slice($pageNumber - 2, $pageNumber + 1),
          ellipse,
          lastPage
        ];
      } else {
        return [
          firstPage,
          ellipse,
          ...$pages.slice($pages.length - 5, $pages.length)
        ];
      }
    });
  }
  createPageCount() {
    return derived(this.pages, ($pages) => {
      return $pages.length;
    });
  }
  createIsAllSelected() {
    return derived([this.selected, this.pagedRows, this.filteredRows, this.selectScope], ([$selected, $pagedRows, $filteredRows, $selectScope]) => {
      const rowCount = $selectScope === "currentPage" ? $pagedRows.length : $filteredRows.length;
      if (rowCount === $selected.length && rowCount !== 0) {
        return true;
      }
      return false;
    });
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/SortHandler.js
var SortHandler = class {
  constructor(context) {
    __publicField(this, "rawRows");
    __publicField(this, "event");
    __publicField(this, "sort");
    __publicField(this, "backup");
    this.rawRows = context.rawRows;
    this.event = context.event;
    this.sort = context.sort;
    this.backup = [];
  }
  set(orderBy = null, uid) {
    if (!orderBy)
      return;
    const sort = get_store_value(this.sort);
    const { identifier } = parseField(orderBy, uid);
    if (sort.identifier !== identifier) {
      this.sort.update((store) => store.direction = null);
    }
    if (sort.direction === null || sort.direction === "desc") {
      this.asc(orderBy, uid);
    } else if (sort.direction === "asc") {
      this.desc(orderBy, uid);
    }
  }
  asc(orderBy, uid) {
    if (!orderBy)
      return;
    const { identifier, callback, key } = parseField(orderBy, uid);
    this.sort.set({ identifier, callback, direction: "asc", key });
    this.rawRows.update((store) => {
      store.sort((x, y) => {
        const [a, b] = [callback(x), callback(y)];
        if (a === b)
          return 0;
        if (a === null)
          return 1;
        if (b === null)
          return -1;
        if (typeof a === "boolean")
          return a === false ? 1 : -1;
        if (typeof a === "string")
          return a.localeCompare(b);
        if (typeof a === "number")
          return a - b;
        if (typeof a === "object")
          return JSON.stringify(a).localeCompare(JSON.stringify(b));
        else
          return String(a).localeCompare(String(b));
      });
      return store;
    });
    this.log({ identifier, callback, direction: "asc" });
    this.event.trigger("change");
  }
  desc(orderBy, uid) {
    if (!orderBy)
      return;
    const { identifier, callback, key } = parseField(orderBy, uid);
    this.sort.set({ identifier, callback, direction: "desc", key });
    this.rawRows.update((store) => {
      store.sort((x, y) => {
        const [a, b] = [callback(x), callback(y)];
        if (a === b)
          return 0;
        if (a === null)
          return 1;
        if (b === null)
          return -1;
        if (typeof b === "boolean")
          return b === false ? 1 : -1;
        if (typeof b === "string")
          return b.localeCompare(a);
        if (typeof b === "number")
          return b - a;
        if (typeof b === "object")
          return JSON.stringify(b).localeCompare(JSON.stringify(a));
        else
          return String(b).localeCompare(String(a));
      });
      return store;
    });
    this.log({ identifier, callback, direction: "desc" });
    this.event.trigger("change");
  }
  apply(params = null) {
    if (params) {
      switch (params.direction) {
        case "asc":
          return this.asc(params.orderBy);
        case "desc":
          return this.desc(params.orderBy);
        default:
          return this.set(params.orderBy);
      }
    } else {
      this.restore();
    }
  }
  clear() {
    this.backup = [];
    this.sort.set({});
  }
  define(orderBy, direction = "asc") {
    if (!orderBy)
      return;
    const { identifier, callback, key } = parseField(orderBy);
    this.sort.set({ identifier, callback, direction, key });
  }
  restore() {
    for (const sort of this.backup) {
      const { key, callback, direction } = sort;
      const param = key ?? callback;
      this[direction](param);
    }
  }
  log(sort) {
    this.backup = this.backup.filter((item) => item.identifier !== sort.identifier);
    if (this.backup.length >= 3) {
      const [_, slot2, slot3] = this.backup;
      this.backup = [slot2, slot3, sort];
    } else {
      this.backup = [...this.backup, sort];
    }
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/SelectHandler.js
var SelectHandler = class {
  constructor(context) {
    __publicField(this, "filteredRows");
    __publicField(this, "pagedRows");
    __publicField(this, "selected");
    __publicField(this, "scope");
    __publicField(this, "isAllSelected");
    __publicField(this, "event");
    this.filteredRows = context.filteredRows;
    this.pagedRows = context.pagedRows;
    this.selected = context.selected;
    this.scope = context.selectScope;
    this.isAllSelected = context.isAllSelected;
    this.event = context.event;
  }
  set(value) {
    const selected = get_store_value(this.selected);
    if (selected.includes(value)) {
      this.selected.set(selected.filter((item) => item !== value));
    } else {
      this.selected.set([value, ...selected]);
    }
  }
  all(selectBy = null) {
    const isAllSelected = get_store_value(this.isAllSelected);
    if (isAllSelected) {
      return this.clear();
    }
    const scope = get_store_value(this.scope);
    const rows = scope === "currentPage" ? get_store_value(this.pagedRows) : get_store_value(this.filteredRows);
    if (scope === "currentPage") {
      this.event.add("change", () => this.clear());
    }
    if (selectBy) {
      this.selected.set(rows.map((row) => row[selectBy]));
    } else {
      this.selected.set(rows);
    }
  }
  clear() {
    this.selected.set([]);
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/PageHandler.js
var PageHandler = class {
  constructor(context) {
    __publicField(this, "pageNumber");
    __publicField(this, "rowCount");
    __publicField(this, "rowsPerPage");
    __publicField(this, "event");
    this.pageNumber = context.pageNumber;
    this.rowCount = context.rowCount;
    this.rowsPerPage = context.rowsPerPage;
    this.event = context.event;
  }
  goto(number) {
    this.pageNumber.update((store) => {
      const rowsPerPage = get_store_value(this.rowsPerPage);
      if (rowsPerPage) {
        const total = get_store_value(this.rowCount).total;
        if (number >= 1 && number <= Math.ceil(total / rowsPerPage)) {
          store = number;
          this.event.trigger("change");
        }
      }
      return store;
    });
  }
  previous() {
    const number = get_store_value(this.pageNumber) - 1;
    this.goto(number);
  }
  next() {
    const number = get_store_value(this.pageNumber) + 1;
    this.goto(number);
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/SearchHandler.js
var SearchHandler = class {
  constructor(context) {
    __publicField(this, "search");
    __publicField(this, "event");
    this.search = context.search;
    this.event = context.event;
  }
  set(value, scope = null) {
    this.search.update((store) => {
      store = {
        value: value ?? "",
        scope: scope ?? null
      };
      return store;
    });
  }
  clear() {
    this.search.set({ value: null, scope: null });
    this.event.trigger("change");
    this.event.trigger("clearSearch");
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/FilterHandler.js
var FilterHandler = class {
  constructor(context) {
    __publicField(this, "filters");
    __publicField(this, "event");
    __publicField(this, "collection");
    this.filters = context.filters;
    this.event = context.event;
  }
  set(value, filterBy, comparator = null, name) {
    const { callback, identifier, key } = parseField(filterBy, name);
    const filter = { value, identifier, callback, comparator, key };
    this.filters.update((store) => {
      store = store.filter((item) => item.identifier !== identifier);
      if (isNotNull(value)) {
        store.push(filter);
      }
      return store;
    });
  }
  clear() {
    this.filters.set([]);
    this.event.trigger("change");
    this.event.trigger("clearFilters");
  }
  get() {
    if (this.collection) {
      return this.collection;
    }
    this.collection = this.createCollection();
    return this.collection;
  }
  createCollection() {
    return derived(this.filters, ($filters) => {
      return $filters.map(({ value, callback, key, comparator }) => {
        const filterBy = key ?? callback;
        return {
          value,
          filterBy,
          check: comparator ? comparator.name : "isLike"
          // set: (value: Value, comparator: Comparator<Row> = check.isLike) => {
          //     this.set(value, filterBy, comparator)
          // },
          // clear: () => {
          //     this.set(undefined, filterBy)
          // }
        };
      });
    });
  }
};

// node_modules/@vincjo/datatables/dist/local/helpers/FilterHelper.js
var FilterHelper = class {
  constructor(filterHandler, filterBy, comparator) {
    __publicField(this, "filterHandler");
    __publicField(this, "filterBy");
    __publicField(this, "uid");
    __publicField(this, "comparator");
    __publicField(this, "callback");
    this.filterHandler = filterHandler;
    this.filterBy = filterBy;
    this.uid = "f_" + Math.random().toString(28).substring(2);
    this.comparator = comparator ?? check.isLike;
    this.callback = () => null;
  }
  set(value, comparator) {
    if (comparator) {
      this.comparator = comparator;
    }
    this.filterHandler.set(value, this.filterBy, this.comparator, this.uid);
  }
  clear() {
    this.callback();
    this.filterHandler.set(void 0, this.filterBy);
  }
  on(event, callback) {
    this.callback = callback;
  }
};

// node_modules/@vincjo/datatables/dist/local/helpers/AdvancedFilterHelper.js
var AdvancedFilterHandler = class {
  constructor(filterHandler, filterBy) {
    __publicField(this, "filterHandler");
    __publicField(this, "criteria");
    __publicField(this, "filterBy");
    __publicField(this, "selected");
    this.filterHandler = filterHandler;
    this.filterBy = filterBy;
    this.criteria = [];
    this.selected = writable([]);
  }
  set(value, comparator = check.isLike) {
    if (this.criteria.find((criterion) => criterion.value === value)) {
      this.criteria = this.criteria.filter((criterion) => criterion.value !== value);
    } else {
      this.criteria = [{ value, comparator }, ...this.criteria];
    }
    if (this.criteria.length === 0) {
      return this.clear();
    }
    this.filterHandler.set(this.criteria, this.filterBy, check.whereIn);
    this.selected.set(this.criteria.map((criterion) => criterion.value));
  }
  getSelected() {
    return this.selected;
  }
  clear() {
    this.criteria = [];
    this.selected.set([]);
    this.filterHandler.set(void 0, this.filterBy, check.whereIn);
  }
};

// node_modules/@vincjo/datatables/dist/local/helpers/CalculationHelper.js
var CalcultationHandler = class {
  constructor(context, field, param) {
    __publicField(this, "rawRows");
    __publicField(this, "filteredRows");
    __publicField(this, "callback");
    __publicField(this, "precision");
    this.rawRows = context.rawRows;
    this.filteredRows = context.filteredRows;
    this.callback = parseField(field).callback;
    this.precision = param.precision;
  }
  distinct(callback = null) {
    const rawRows = get_store_value(this.rawRows);
    const values = rawRows.map((row) => this.callback(row));
    const array = callback ? callback(values) : values;
    const result = array.reduce((acc, curr) => {
      acc[curr] = (acc[curr] ?? 0) + 1;
      return acc;
    }, {});
    return Object.entries(result).map(([value, count]) => ({ value, count }));
  }
  avg(callback = null) {
    return derived(this.filteredRows, ($filteredRows) => {
      if ($filteredRows.length === 0)
        return 0;
      const values = $filteredRows.map((row) => this.callback(row)).filter(Boolean);
      const array = callback ? callback(values) : values;
      return this.round(array.reduce((acc, curr) => acc + curr, 0) / array.length);
    });
  }
  sum(callback = null) {
    return derived(this.filteredRows, ($filteredRows) => {
      const values = $filteredRows.map((row) => this.callback(row));
      const array = callback ? callback(values) : values;
      return this.round(array.reduce((acc, curr) => acc + curr, 0));
    });
  }
  bounds(callback = null) {
    const rawRows = get_store_value(this.rawRows);
    const values = rawRows.map((row) => this.callback(row));
    const numbers = callback ? callback(values) : values;
    return [
      Math.min(...numbers.filter(Boolean)),
      Math.max(...numbers.filter(Boolean))
    ];
  }
  setPrecision(value) {
    this.precision = value;
  }
  round(value) {
    if (this.precision === 0) {
      return Math.round(value);
    }
    const denominator = Math.pow(10, this.precision);
    return Math.round((value + Number.EPSILON) * denominator) / denominator;
  }
};

// node_modules/@vincjo/datatables/dist/local/DataHandler.js
var DataHandler = class {
  constructor(data = [], params = { rowsPerPage: null }) {
    __publicField(this, "context");
    __publicField(this, "sortHandler");
    __publicField(this, "selectHandler");
    __publicField(this, "pageHandler");
    __publicField(this, "searchHandler");
    __publicField(this, "filterHandler");
    __publicField(this, "i18n");
    this.i18n = this.translate(params.i18n);
    this.context = new Context(data, params);
    this.sortHandler = new SortHandler(this.context);
    this.selectHandler = new SelectHandler(this.context);
    this.pageHandler = new PageHandler(this.context);
    this.searchHandler = new SearchHandler(this.context);
    this.filterHandler = new FilterHandler(this.context);
  }
  setRows(data) {
    this.context.rawRows.set(data);
    this.context.event.trigger("change");
    this.applySort();
  }
  getRows() {
    return this.context.pagedRows;
  }
  getAllRows() {
    return this.context.filteredRows;
  }
  getRowCount() {
    return this.context.rowCount;
  }
  getRowsPerPage() {
    return this.context.rowsPerPage;
  }
  getPages(param = { ellipsis: false }) {
    if (param.ellipsis) {
      return this.context.pagesWithEllipsis;
    }
    return this.context.pages;
  }
  getPageCount() {
    return this.context.pageCount;
  }
  getPageNumber() {
    return this.context.pageNumber;
  }
  setPage(value) {
    switch (value) {
      case "previous":
        return this.pageHandler.previous();
      case "next":
        return this.pageHandler.next();
      default:
        return this.pageHandler.goto(value);
    }
  }
  search(value, scope = null) {
    this.searchHandler.set(value, scope);
  }
  clearSearch() {
    this.searchHandler.clear();
  }
  sort(orderBy, identifier) {
    this.setPage(1);
    this.sortHandler.set(orderBy, identifier);
  }
  sortAsc(orderBy, identifier) {
    this.setPage(1);
    this.sortHandler.asc(orderBy, identifier);
  }
  sortDesc(orderBy, identifier) {
    this.setPage(1);
    this.sortHandler.desc(orderBy, identifier);
  }
  getSort() {
    return this.context.sort;
  }
  applySort(params = null) {
    this.sortHandler.apply(params);
  }
  defineSort(orderBy, direction) {
    this.sortHandler.define(orderBy, direction);
  }
  clearSort() {
    this.sortHandler.clear();
  }
  filter(value, filterBy, comparator = null) {
    this.filterHandler.set(value, filterBy, comparator);
  }
  getFilters() {
    return this.filterHandler.get();
  }
  createFilter(filterBy, comparator) {
    return new FilterHelper(this.filterHandler, filterBy, comparator);
  }
  createAdvancedFilter(filterBy) {
    return new AdvancedFilterHandler(this.filterHandler, filterBy);
  }
  getFilterCount() {
    return this.context.filterCount;
  }
  clearFilters() {
    this.filterHandler.clear();
  }
  select(value) {
    this.selectHandler.set(value);
  }
  getSelected() {
    return this.context.selected;
  }
  selectAll(params = {}) {
    this.context.selectScope.set(params.scope === "currentPage" ? "currentPage" : "all");
    this.selectHandler.all(params.selectBy ?? null);
  }
  isAllSelected() {
    return this.context.isAllSelected;
  }
  on(event, callback) {
    this.context.event.add(event, callback);
  }
  createCalculation(field, param = null) {
    return new CalcultationHandler(this.context, field, { precision: (param == null ? void 0 : param.precision) ?? 2 });
  }
  translate(i18n) {
    return {
      ...{
        search: "Search...",
        show: "Show",
        entries: "entries",
        filter: "Filter",
        rowCount: "Showing {start} to {end} of {total} entries",
        noRows: "No entries found",
        previous: "Previous",
        next: "Next"
      },
      ...i18n
    };
  }
  /**
   * @deprecated use setRows() instead
   * @since v0.9.99 2023-01-16
   */
  update(data) {
    console.log("%c%s", "color:#e65100;background:#fff3e0;font-size:12px;border-radius:4px;padding:4px;text-align:center;", `DataHandler.update(data) method is deprecated. Please use DataHandler.setRows(data) instead`);
    this.context.rawRows.set(data);
  }
  /**
   * @deprecated use applySort() instead
   * @since v1.11.0 2023-07-11
   */
  applySorting(params = null) {
    this.applySort(params);
  }
  /**
   * @deprecated use getSort() instead
   * @since v1.11.0 2023-07-11
   */
  getSorted() {
    return this.getSort();
  }
  getTriggerChange() {
    return this.context.event.triggerChange;
  }
};

// node_modules/@vincjo/datatables/dist/local/Th.svelte
function add_css(target) {
  append_styles(target, "svelte-1znt79", "th.svelte-1znt79.svelte-1znt79{background:inherit;padding:8px 20px;white-space:nowrap;font-size:13px;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-bottom:1px solid #e0e0e0}th.sortable.svelte-1znt79.svelte-1znt79{cursor:pointer}th.svelte-1znt79 strong.svelte-1znt79{white-space:pre-wrap;font-size:13.5px;line-height:16px}th.sortable.svelte-1znt79 div.flex.svelte-1znt79{padding:0;display:flex;align-items:center;height:100%}th.sortable.svelte-1znt79 span.svelte-1znt79{padding-left:8px}th.sortable.svelte-1znt79 span.svelte-1znt79:before,th.sortable.svelte-1znt79 span.svelte-1znt79:after{border:4px solid transparent;content:'';display:block;height:0;width:0}th.sortable.svelte-1znt79 span.svelte-1znt79:before{border-bottom-color:#e0e0e0;margin-top:2px}th.sortable.svelte-1znt79 span.svelte-1znt79:after{border-top-color:#e0e0e0;margin-top:2px}th.active.sortable.svelte-1znt79 span.asc.svelte-1znt79:before{border-bottom-color:#9e9e9e}th.active.sortable.svelte-1znt79 span.desc.svelte-1znt79:after{border-top-color:#9e9e9e}th.svelte-1znt79:not(.sortable) span.svelte-1znt79{visibility:hidden}");
}
function create_fragment(ctx) {
  let th;
  let div;
  let strong;
  let t;
  let span;
  let th_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      th = element("th");
      div = element("div");
      strong = element("strong");
      if (default_slot) default_slot.c();
      t = space();
      span = element("span");
      this.h();
    },
    l(nodes) {
      th = claim_element(nodes, "TH", { class: true, rowspan: true });
      var th_nodes = children(th);
      div = claim_element(th_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      strong = claim_element(div_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      if (default_slot) default_slot.l(strong_nodes);
      strong_nodes.forEach(detach);
      t = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      children(span).forEach(detach);
      div_nodes.forEach(detach);
      th_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(strong, "class", "svelte-1znt79");
      attr(span, "class", "svelte-1znt79");
      toggle_class(
        span,
        "asc",
        /*$sort*/
        ctx[5].direction === "asc"
      );
      toggle_class(
        span,
        "desc",
        /*$sort*/
        ctx[5].direction === "desc"
      );
      attr(div, "class", "flex svelte-1znt79");
      set_style(
        div,
        "justify-content",
        /*align*/
        ctx[3] === "left" ? "flex-start" : (
          /*align*/
          ctx[3] === "right" ? "flex-end" : "center"
        )
      );
      attr(th, "class", th_class_value = null_to_empty(
        /*$$props*/
        ctx[7].class ?? ""
      ) + " svelte-1znt79");
      attr(
        th,
        "rowspan",
        /*rowSpan*/
        ctx[4]
      );
      toggle_class(
        th,
        "sortable",
        /*orderBy*/
        ctx[1]
      );
      toggle_class(
        th,
        "active",
        /*$sort*/
        ctx[5].identifier === /*identifier*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, th, anchor);
      append_hydration(th, div);
      append_hydration(div, strong);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      append_hydration(div, t);
      append_hydration(div, span);
      current = true;
      if (!mounted) {
        dispose = listen(
          th,
          "click",
          /*click_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$sort*/
      32) {
        toggle_class(
          span,
          "asc",
          /*$sort*/
          ctx2[5].direction === "asc"
        );
      }
      if (!current || dirty & /*$sort*/
      32) {
        toggle_class(
          span,
          "desc",
          /*$sort*/
          ctx2[5].direction === "desc"
        );
      }
      if (dirty & /*align*/
      8) {
        set_style(
          div,
          "justify-content",
          /*align*/
          ctx2[3] === "left" ? "flex-start" : (
            /*align*/
            ctx2[3] === "right" ? "flex-end" : "center"
          )
        );
      }
      if (!current || dirty & /*$$props*/
      128 && th_class_value !== (th_class_value = null_to_empty(
        /*$$props*/
        ctx2[7].class ?? ""
      ) + " svelte-1znt79")) {
        attr(th, "class", th_class_value);
      }
      if (!current || dirty & /*rowSpan*/
      16) {
        attr(
          th,
          "rowspan",
          /*rowSpan*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$$props, orderBy*/
      130) {
        toggle_class(
          th,
          "sortable",
          /*orderBy*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$$props, $sort, identifier*/
      164) {
        toggle_class(
          th,
          "active",
          /*$sort*/
          ctx2[5].identifier === /*identifier*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $sort;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { handler } = $$props;
  let { orderBy } = $$props;
  let { identifier = orderBy == null ? void 0 : orderBy.toString() } = $$props;
  let { align = "left" } = $$props;
  let { rowSpan = 1 } = $$props;
  const sort = handler.getSort();
  component_subscribe($$self, sort, (value) => $$invalidate(5, $sort = value));
  const click_handler = () => handler.sort(orderBy, identifier);
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props) $$invalidate(0, handler = $$new_props.handler);
    if ("orderBy" in $$new_props) $$invalidate(1, orderBy = $$new_props.orderBy);
    if ("identifier" in $$new_props) $$invalidate(2, identifier = $$new_props.identifier);
    if ("align" in $$new_props) $$invalidate(3, align = $$new_props.align);
    if ("rowSpan" in $$new_props) $$invalidate(4, rowSpan = $$new_props.rowSpan);
    if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    handler,
    orderBy,
    identifier,
    align,
    rowSpan,
    $sort,
    sort,
    $$props,
    $$scope,
    slots,
    click_handler
  ];
}
var Th = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        handler: 0,
        orderBy: 1,
        identifier: 2,
        align: 3,
        rowSpan: 4
      },
      add_css
    );
  }
};
var Th_default = Th;

// node_modules/@vincjo/datatables/dist/local/ThFilter.svelte
function add_css2(target) {
  append_styles(target, "svelte-1ri3ua3", "th.svelte-1ri3ua3{border-bottom:1px solid #e0e0e0}input.svelte-1ri3ua3{width:100%;height:24px;border:none;text-align:left;padding:0 20px;background:inherit;outline:none;border-radius:0;font-size:14px;font-family:Arial, Helvetica, sans-serif}input.svelte-1ri3ua3::-moz-placeholder{color:#bdbdbd;font-style:italic;font-size:13px}input.svelte-1ri3ua3::placeholder{color:#bdbdbd;font-style:italic;font-size:13px}input.svelte-1ri3ua3:focus{outline:none;border:none}");
}
function create_fragment2(ctx) {
  let th;
  let input;
  let input_placeholder_value;
  let th_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      th = element("th");
      input = element("input");
      this.h();
    },
    l(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      input = claim_element(th_nodes, "INPUT", {
        type: true,
        placeholder: true,
        spellcheck: true,
        class: true
      });
      th_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input, "type", "text");
      attr(input, "placeholder", input_placeholder_value = /*handler*/
      ctx[0].i18n.filter);
      attr(input, "spellcheck", "false");
      attr(input, "class", "svelte-1ri3ua3");
      set_style(
        input,
        "text-align",
        /*align*/
        ctx[2]
      );
      attr(th, "class", th_class_value = null_to_empty(
        /*$$props*/
        ctx[5].class ?? ""
      ) + " svelte-1ri3ua3");
    },
    m(target, anchor) {
      insert_hydration(target, th, anchor);
      append_hydration(th, input);
      set_input_value(
        input,
        /*value*/
        ctx[4]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*handler*/
      1 && input_placeholder_value !== (input_placeholder_value = /*handler*/
      ctx2[0].i18n.filter)) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*value*/
      16 && input.value !== /*value*/
      ctx2[4]) {
        set_input_value(
          input,
          /*value*/
          ctx2[4]
        );
      }
      if (dirty & /*align*/
      4) {
        set_style(
          input,
          "text-align",
          /*align*/
          ctx2[2]
        );
      }
      if (dirty & /*$$props*/
      32 && th_class_value !== (th_class_value = null_to_empty(
        /*$$props*/
        ctx2[5].class ?? ""
      ) + " svelte-1ri3ua3")) {
        attr(th, "class", th_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(th);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { handler } = $$props;
  let { filterBy } = $$props;
  let { align = "left" } = $$props;
  let { comparator = null } = $$props;
  let value = "";
  handler.on("clearFilters", () => $$invalidate(4, value = ""));
  function input_input_handler() {
    value = this.value;
    $$invalidate(4, value);
  }
  const input_handler = () => handler.filter(value, filterBy, comparator);
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props) $$invalidate(0, handler = $$new_props.handler);
    if ("filterBy" in $$new_props) $$invalidate(1, filterBy = $$new_props.filterBy);
    if ("align" in $$new_props) $$invalidate(2, align = $$new_props.align);
    if ("comparator" in $$new_props) $$invalidate(3, comparator = $$new_props.comparator);
  };
  $$props = exclude_internal_props($$props);
  return [
    handler,
    filterBy,
    align,
    comparator,
    value,
    $$props,
    input_input_handler,
    input_handler
  ];
}
var ThFilter = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        handler: 0,
        filterBy: 1,
        align: 2,
        comparator: 3
      },
      add_css2
    );
  }
};
var ThFilter_default = ThFilter;

// node_modules/@vincjo/datatables/dist/local/Pagination.svelte
function add_css3(target) {
  append_styles(target, "svelte-9sqfh3", "section.svelte-9sqfh3{display:flex}button.svelte-9sqfh3{background:inherit;height:32px;width:32px;color:#616161;cursor:pointer;font-size:13px;margin:0;padding:0;transition:all, 0.2s;line-height:32px;border:1px solid #e0e0e0;border-right:none;border-radius:0;outline:none}button.svelte-9sqfh3:first-child{border-radius:4px 0 0 4px}button.svelte-9sqfh3:last-child{border-right:1px solid #e0e0e0;border-radius:0 4px 4px 0}button.svelte-9sqfh3:first-child:not(.small),button.svelte-9sqfh3:last-child:not(.small){min-width:72px}button.svelte-9sqfh3:not(.active):hover{background:#eee}button.ellipse.svelte-9sqfh3:hover{background:inherit;cursor:default}button.active.svelte-9sqfh3{background:#eee;font-weight:bold;cursor:default}button.disabled.svelte-9sqfh3:hover{background:inherit;cursor:default}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let button0;
  let html_tag;
  let raw0_value = (
    /*handler*/
    ctx[0].i18n.previous + ""
  );
  let t0;
  let t1;
  let button1;
  let html_tag_1;
  let raw1_value = (
    /*handler*/
    ctx[0].i18n.next + ""
  );
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$pages*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      button0 = element("button");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      button1 = element("button");
      html_tag_1 = new HtmlTagHydration(false);
      this.h();
    },
    l(nodes) {
      button0 = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      html_tag = claim_html_tag(button0_nodes, false);
      button0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      html_tag_1 = claim_html_tag(button1_nodes, false);
      button1_nodes.forEach(detach);
      this.h();
    },
    h() {
      html_tag.a = null;
      attr(button0, "type", "button");
      attr(button0, "class", "svelte-9sqfh3");
      toggle_class(
        button0,
        "disabled",
        /*$pageNumber*/
        ctx[2] === 1
      );
      html_tag_1.a = null;
      attr(button1, "type", "button");
      attr(button1, "class", "svelte-9sqfh3");
      toggle_class(
        button1,
        "disabled",
        /*$pageNumber*/
        ctx[2] === /*$pageCount*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert_hydration(target, button0, anchor);
      html_tag.m(raw0_value, button0);
      insert_hydration(target, t0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration(target, t1, anchor);
      insert_hydration(target, button1, anchor);
      html_tag_1.m(raw1_value, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_4*/
            ctx[13]
          ),
          listen(
            button1,
            "click",
            /*click_handler_6*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && raw0_value !== (raw0_value = /*handler*/
      ctx2[0].i18n.previous + "")) html_tag.p(raw0_value);
      if (dirty & /*$pageNumber*/
      4) {
        toggle_class(
          button0,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === 1
        );
      }
      if (dirty & /*$pageNumber, $pages, handler*/
      21) {
        each_value = ensure_array_like(
          /*$pages*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(t1.parentNode, t1);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*handler*/
      1 && raw1_value !== (raw1_value = /*handler*/
      ctx2[0].i18n.next + "")) html_tag_1.p(raw1_value);
      if (dirty & /*$pageNumber, $pageCount*/
      12) {
        toggle_class(
          button1,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === /*$pageCount*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t0);
        detach(t1);
        detach(button1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let button0;
  let textContent = "❬❬";
  let t1;
  let button1;
  let textContent_1 = "❮";
  let t3;
  let button2;
  let textContent_2 = "❯";
  let t5;
  let button3;
  let textContent_3 = "❭❭";
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = textContent;
      t1 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      t3 = space();
      button2 = element("button");
      button2.textContent = textContent_2;
      t5 = space();
      button3 = element("button");
      button3.textContent = textContent_3;
      this.h();
    },
    l(nodes) {
      button0 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-16n9ron") button0.textContent = textContent;
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-1phz6f1") button1.textContent = textContent_1;
      t3 = claim_space(nodes);
      button2 = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button2) !== "svelte-d0zv7q") button2.textContent = textContent_2;
      t5 = claim_space(nodes);
      button3 = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button3) !== "svelte-1rg1h5c") button3.textContent = textContent_3;
      this.h();
    },
    h() {
      attr(button0, "type", "button");
      attr(button0, "class", "small svelte-9sqfh3");
      toggle_class(
        button0,
        "disabled",
        /*$pageNumber*/
        ctx[2] === 1
      );
      attr(button1, "type", "button");
      attr(button1, "class", "svelte-9sqfh3");
      toggle_class(
        button1,
        "disabled",
        /*$pageNumber*/
        ctx[2] === 1
      );
      attr(button2, "class", "svelte-9sqfh3");
      toggle_class(
        button2,
        "disabled",
        /*$pageNumber*/
        ctx[2] === /*$pageCount*/
        ctx[3]
      );
      attr(button3, "class", "small svelte-9sqfh3");
      toggle_class(
        button3,
        "disabled",
        /*$pageNumber*/
        ctx[2] === /*$pageCount*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert_hydration(target, button0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, button1, anchor);
      insert_hydration(target, t3, anchor);
      insert_hydration(target, button2, anchor);
      insert_hydration(target, t5, anchor);
      insert_hydration(target, button3, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[10]
          ),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[11]
          ),
          listen(
            button3,
            "click",
            /*click_handler_3*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$pageNumber*/
      4) {
        toggle_class(
          button0,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === 1
        );
      }
      if (dirty & /*$pageNumber*/
      4) {
        toggle_class(
          button1,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === 1
        );
      }
      if (dirty & /*$pageNumber, $pageCount*/
      12) {
        toggle_class(
          button2,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === /*$pageCount*/
          ctx2[3]
        );
      }
      if (dirty & /*$pageNumber, $pageCount*/
      12) {
        toggle_class(
          button3,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === /*$pageCount*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t1);
        detach(button1);
        detach(t3);
        detach(button2);
        detach(t5);
        detach(button3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(ctx) {
  let button;
  let t_value = (
    /*page*/
    (ctx[16] ?? "...") + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[14](
        /*page*/
        ctx[16]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "type", "button");
      attr(button, "class", "svelte-9sqfh3");
      toggle_class(
        button,
        "active",
        /*$pageNumber*/
        ctx[2] === /*page*/
        ctx[16]
      );
      toggle_class(
        button,
        "ellipse",
        /*page*/
        ctx[16] === null
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, t);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_5);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$pages*/
      16 && t_value !== (t_value = /*page*/
      (ctx[16] ?? "...") + "")) set_data(t, t_value);
      if (dirty & /*$pageNumber, $pages*/
      20) {
        toggle_class(
          button,
          "active",
          /*$pageNumber*/
          ctx[2] === /*page*/
          ctx[16]
        );
      }
      if (dirty & /*$pages*/
      16) {
        toggle_class(
          button,
          "ellipse",
          /*page*/
          ctx[16] === null
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment3(ctx) {
  let section;
  let section_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*small*/
      ctx2[1]
    ) return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      section = element("section");
      if_block.c();
      this.h();
    },
    l(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if_block.l(section_nodes);
      section_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(section, "class", section_class_value = null_to_empty(
        /*$$props*/
        ctx[8].class ?? ""
      ) + " svelte-9sqfh3");
    },
    m(target, anchor) {
      insert_hydration(target, section, anchor);
      if_block.m(section, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(section, null);
        }
      }
      if (dirty & /*$$props*/
      256 && section_class_value !== (section_class_value = null_to_empty(
        /*$$props*/
        ctx2[8].class ?? ""
      ) + " svelte-9sqfh3")) {
        attr(section, "class", section_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if_block.d();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let $pageNumber;
  let $pageCount;
  let $pages;
  let { handler } = $$props;
  let { small = false } = $$props;
  const pageNumber = handler.getPageNumber();
  component_subscribe($$self, pageNumber, (value) => $$invalidate(2, $pageNumber = value));
  const pageCount = handler.getPageCount();
  component_subscribe($$self, pageCount, (value) => $$invalidate(3, $pageCount = value));
  const pages = handler.getPages({ ellipsis: true });
  component_subscribe($$self, pages, (value) => $$invalidate(4, $pages = value));
  const click_handler = () => handler.setPage(1);
  const click_handler_1 = () => handler.setPage("previous");
  const click_handler_2 = () => handler.setPage("next");
  const click_handler_3 = () => handler.setPage($pageCount);
  const click_handler_4 = () => handler.setPage("previous");
  const click_handler_5 = (page) => handler.setPage(page);
  const click_handler_6 = () => handler.setPage("next");
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props) $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props) $$invalidate(1, small = $$new_props.small);
  };
  $$props = exclude_internal_props($$props);
  return [
    handler,
    small,
    $pageNumber,
    $pageCount,
    $pages,
    pageNumber,
    pageCount,
    pages,
    $$props,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6
  ];
}
var Pagination = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { handler: 0, small: 1 }, add_css3);
  }
};
var Pagination_default = Pagination;

// node_modules/@vincjo/datatables/dist/local/RowCount.svelte
function add_css4(target) {
  append_styles(target, "svelte-1tjrquk", "aside.svelte-1tjrquk{color:#616161;line-height:32px;font-size:14px}");
}
function create_else_block_1(ctx) {
  let t_value = (
    /*handler*/
    ctx[0].i18n.noRows + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.noRows + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let html_tag;
  let raw_value = (
    /*handler*/
    ctx[0].i18n.rowCount.replace("{start}", `<b>${/*$rowCount*/
    ctx[2].start}</b>`).replace("{end}", `<b>${/*$rowCount*/
    ctx[2].end}</b>`).replace("{total}", `<b>${/*$rowCount*/
    ctx[2].total}</b>`) + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*handler, $rowCount*/
      5 && raw_value !== (raw_value = /*handler*/
      ctx2[0].i18n.rowCount.replace("{start}", `<b>${/*$rowCount*/
      ctx2[2].start}</b>`).replace("{end}", `<b>${/*$rowCount*/
      ctx2[2].end}</b>`).replace("{total}", `<b>${/*$rowCount*/
      ctx2[2].total}</b>`) + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block2(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$rowCount*/
      ctx2[2].total > 0
    ) return create_if_block_1;
    return create_else_block2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block2(ctx) {
  let t_value = (
    /*handler*/
    ctx[0].i18n.noRows + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    l(nodes) {
      t = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.noRows + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_1(ctx) {
  let b0;
  let t0_value = (
    /*$rowCount*/
    ctx[2].start + ""
  );
  let t0;
  let t1;
  let b1;
  let t2_value = (
    /*$rowCount*/
    ctx[2].end + ""
  );
  let t2;
  let t3;
  let b2;
  let t4_value = (
    /*$rowCount*/
    ctx[2].total + ""
  );
  let t4;
  return {
    c() {
      b0 = element("b");
      t0 = text(t0_value);
      t1 = text("-\r\n            ");
      b1 = element("b");
      t2 = text(t2_value);
      t3 = text("/\r\n            ");
      b2 = element("b");
      t4 = text(t4_value);
    },
    l(nodes) {
      b0 = claim_element(nodes, "B", {});
      var b0_nodes = children(b0);
      t0 = claim_text(b0_nodes, t0_value);
      b0_nodes.forEach(detach);
      t1 = claim_text(nodes, "-\r\n            ");
      b1 = claim_element(nodes, "B", {});
      var b1_nodes = children(b1);
      t2 = claim_text(b1_nodes, t2_value);
      b1_nodes.forEach(detach);
      t3 = claim_text(nodes, "/\r\n            ");
      b2 = claim_element(nodes, "B", {});
      var b2_nodes = children(b2);
      t4 = claim_text(b2_nodes, t4_value);
      b2_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, b0, anchor);
      append_hydration(b0, t0);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, b1, anchor);
      append_hydration(b1, t2);
      insert_hydration(target, t3, anchor);
      insert_hydration(target, b2, anchor);
      append_hydration(b2, t4);
    },
    p(ctx2, dirty) {
      if (dirty & /*$rowCount*/
      4 && t0_value !== (t0_value = /*$rowCount*/
      ctx2[2].start + "")) set_data(t0, t0_value);
      if (dirty & /*$rowCount*/
      4 && t2_value !== (t2_value = /*$rowCount*/
      ctx2[2].end + "")) set_data(t2, t2_value);
      if (dirty & /*$rowCount*/
      4 && t4_value !== (t4_value = /*$rowCount*/
      ctx2[2].total + "")) set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching) {
        detach(b0);
        detach(t1);
        detach(b1);
        detach(t3);
        detach(b2);
      }
    }
  };
}
function create_fragment4(ctx) {
  let aside;
  let aside_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*small*/
      ctx2[1]
    ) return create_if_block2;
    if (
      /*$rowCount*/
      ctx2[2].total > 0
    ) return create_if_block_2;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      aside = element("aside");
      if_block.c();
      this.h();
    },
    l(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      if_block.l(aside_nodes);
      aside_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(aside, "class", aside_class_value = null_to_empty(
        /*$$props*/
        ctx[4].class ?? ""
      ) + " svelte-1tjrquk");
    },
    m(target, anchor) {
      insert_hydration(target, aside, anchor);
      if_block.m(aside, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(aside, null);
        }
      }
      if (dirty & /*$$props*/
      16 && aside_class_value !== (aside_class_value = null_to_empty(
        /*$$props*/
        ctx2[4].class ?? ""
      ) + " svelte-1tjrquk")) {
        attr(aside, "class", aside_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(aside);
      }
      if_block.d();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let $rowCount;
  let { handler } = $$props;
  let { small = false } = $$props;
  const rowCount = handler.getRowCount();
  component_subscribe($$self, rowCount, (value) => $$invalidate(2, $rowCount = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props) $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props) $$invalidate(1, small = $$new_props.small);
  };
  $$props = exclude_internal_props($$props);
  return [handler, small, $rowCount, rowCount, $$props];
}
var RowCount = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { handler: 0, small: 1 }, add_css4);
  }
};
var RowCount_default = RowCount;

// node_modules/@vincjo/datatables/dist/local/RowsPerPage.svelte
function add_css5(target) {
  append_styles(target, "svelte-18tth2v", "aside.svelte-18tth2v{display:flex;justify-content:flex-start;align-items:center;height:32px;color:#757575}select.svelte-18tth2v{margin:0 4px}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let span;
  let t_value = (
    /*handler*/
    ctx[0].i18n.show + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.show + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block2(ctx) {
  let option_1;
  let t0_value = (
    /*option*/
    ctx[8] + ""
  );
  let t0;
  let t1;
  let option_1_value_value;
  return {
    c() {
      option_1 = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l(nodes) {
      option_1 = claim_element(nodes, "OPTION", {});
      var option_1_nodes = children(option_1);
      t0 = claim_text(option_1_nodes, t0_value);
      t1 = claim_space(option_1_nodes);
      option_1_nodes.forEach(detach);
      this.h();
    },
    h() {
      option_1.__value = option_1_value_value = /*option*/
      ctx[8];
      set_input_value(option_1, option_1.__value);
    },
    m(target, anchor) {
      insert_hydration(target, option_1, anchor);
      append_hydration(option_1, t0);
      append_hydration(option_1, t1);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
function create_if_block3(ctx) {
  let span;
  let t_value = (
    /*handler*/
    ctx[0].i18n.entries + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.entries + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment5(ctx) {
  let aside;
  let t0;
  let select;
  let t1;
  let aside_class_value;
  let mounted;
  let dispose;
  let if_block0 = !/*small*/
  ctx[1] && create_if_block_12(ctx);
  let each_value = ensure_array_like(
    /*options*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  let if_block1 = !/*small*/
  ctx[1] && create_if_block3(ctx);
  return {
    c() {
      aside = element("aside");
      if (if_block0) if_block0.c();
      t0 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      if (if_block0) if_block0.l(aside_nodes);
      t0 = claim_space(aside_nodes);
      select = claim_element(aside_nodes, "SELECT", { class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach);
      t1 = claim_space(aside_nodes);
      if (if_block1) if_block1.l(aside_nodes);
      aside_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(select, "class", "svelte-18tth2v");
      if (
        /*$rowsPerPage*/
        ctx[2] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[6].call(select)
      ));
      attr(aside, "class", aside_class_value = null_to_empty(
        /*$$props*/
        ctx[5].class ?? ""
      ) + " svelte-18tth2v");
    },
    m(target, anchor) {
      insert_hydration(target, aside, anchor);
      if (if_block0) if_block0.m(aside, null);
      append_hydration(aside, t0);
      append_hydration(aside, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*$rowsPerPage*/
        ctx[2],
        true
      );
      append_hydration(aside, t1);
      if (if_block1) if_block1.m(aside, null);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[6]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!/*small*/
      ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(aside, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*options*/
      16) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$rowsPerPage, options*/
      20) {
        select_option(
          select,
          /*$rowsPerPage*/
          ctx2[2]
        );
      }
      if (!/*small*/
      ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          if_block1.m(aside, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$$props*/
      32 && aside_class_value !== (aside_class_value = null_to_empty(
        /*$$props*/
        ctx2[5].class ?? ""
      ) + " svelte-18tth2v")) {
        attr(aside, "class", aside_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(aside);
      }
      if (if_block0) if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let $rowsPerPage;
  let { handler } = $$props;
  let { small = false } = $$props;
  const rowsPerPage = handler.getRowsPerPage();
  component_subscribe($$self, rowsPerPage, (value) => $$invalidate(2, $rowsPerPage = value));
  const options = [5, 10, 20, 50, 100];
  function select_change_handler() {
    $rowsPerPage = select_value(this);
    rowsPerPage.set($rowsPerPage);
    $$invalidate(4, options);
  }
  const change_handler = () => handler.setPage(1);
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props) $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props) $$invalidate(1, small = $$new_props.small);
  };
  $$props = exclude_internal_props($$props);
  return [
    handler,
    small,
    $rowsPerPage,
    rowsPerPage,
    options,
    $$props,
    select_change_handler,
    change_handler
  ];
}
var RowsPerPage = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { handler: 0, small: 1 }, add_css5);
  }
};
var RowsPerPage_default = RowsPerPage;

// node_modules/@vincjo/datatables/dist/local/Search.svelte
function add_css6(target) {
  append_styles(target, "svelte-7e9n7g", "input.svelte-7e9n7g{border:1px solid #e0e0e0;border-radius:4px;outline:none;padding:0 8px;line-height:24px;margin:0;height:24px;background:transparent;width:40%;max-width:176px;min-width:96px;transition:all, 0.1s}input.svelte-7e9n7g:focus{border:1px solid #bdbdbd}input.svelte-7e9n7g::-moz-placeholder{color:#9e9e9e;line-height:24px}input.svelte-7e9n7g::placeholder{color:#9e9e9e;line-height:24px}");
}
function create_fragment6(ctx) {
  let input;
  let input_class_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      this.h();
    },
    l(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        placeholder: true,
        spellcheck: true
      });
      this.h();
    },
    h() {
      attr(input, "class", input_class_value = null_to_empty(
        /*$$props*/
        ctx[2].class ?? ""
      ) + " svelte-7e9n7g");
      attr(input, "placeholder", input_placeholder_value = /*handler*/
      ctx[0].i18n.search);
      attr(input, "spellcheck", "false");
    },
    m(target, anchor) {
      insert_hydration(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$$props*/
      4 && input_class_value !== (input_class_value = null_to_empty(
        /*$$props*/
        ctx2[2].class ?? ""
      ) + " svelte-7e9n7g")) {
        attr(input, "class", input_class_value);
      }
      if (dirty & /*handler*/
      1 && input_placeholder_value !== (input_placeholder_value = /*handler*/
      ctx2[0].i18n.search)) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        set_input_value(
          input,
          /*value*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { handler } = $$props;
  let value = "";
  handler.on("clearSearch", () => $$invalidate(1, value = ""));
  function input_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  const input_handler = () => handler.search(value);
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props) $$invalidate(0, handler = $$new_props.handler);
  };
  $$props = exclude_internal_props($$props);
  return [handler, value, $$props, input_input_handler, input_handler];
}
var Search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { handler: 0 }, add_css6);
  }
};
var Search_default = Search;

// node_modules/@vincjo/datatables/dist/local/Datatable.svelte
function add_css7(target) {
  append_styles(target, "svelte-1ere01f", "section.svelte-1ere01f{height:100%}section.svelte-1ere01f table{border-collapse:separate;border-spacing:0;width:100%}section.svelte-1ere01f thead{position:sticky;inset-block-start:0;z-index:1}header.svelte-1ere01f,footer.svelte-1ere01f{min-height:8px;padding:0 16px;display:flex;justify-content:space-between;align-items:center}header.container.svelte-1ere01f,footer.container.svelte-1ere01f{height:48px}footer.svelte-1ere01f{border-top:1px solid #e0e0e0}article.svelte-1ere01f{position:relative;overflow:auto;scrollbar-width:thin}article.svelte-1ere01f::-webkit-scrollbar{width:6px;height:6px}article.svelte-1ere01f::-webkit-scrollbar-track{background:#f5f5f5}article.svelte-1ere01f::-webkit-scrollbar-thumb{background:#c2c2c2}article.svelte-1ere01f::-webkit-scrollbar-thumb:hover{background:#9e9e9e}");
}
function create_if_block_3(ctx) {
  let search_1;
  let current;
  search_1 = new Search_default({ props: { handler: (
    /*handler*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(search_1.$$.fragment);
    },
    l(nodes) {
      claim_component(search_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(search_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_1_changes = {};
      if (dirty & /*handler*/
      1) search_1_changes.handler = /*handler*/
      ctx2[0];
      search_1.$set(search_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(search_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(search_1, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let rowsperpage;
  let current;
  rowsperpage = new RowsPerPage_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[6] < 600
      )
    }
  });
  return {
    c() {
      create_component(rowsperpage.$$.fragment);
    },
    l(nodes) {
      claim_component(rowsperpage.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(rowsperpage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rowsperpage_changes = {};
      if (dirty & /*handler*/
      1) rowsperpage_changes.handler = /*handler*/
      ctx2[0];
      if (dirty & /*clientWidth*/
      64) rowsperpage_changes.small = /*clientWidth*/
      ctx2[6] < 600;
      rowsperpage.$set(rowsperpage_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rowsperpage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rowsperpage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rowsperpage, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let rowcount;
  let current;
  rowcount = new RowCount_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[6] < 600
      )
    }
  });
  return {
    c() {
      create_component(rowcount.$$.fragment);
    },
    l(nodes) {
      claim_component(rowcount.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(rowcount, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rowcount_changes = {};
      if (dirty & /*handler*/
      1) rowcount_changes.handler = /*handler*/
      ctx2[0];
      if (dirty & /*clientWidth*/
      64) rowcount_changes.small = /*clientWidth*/
      ctx2[6] < 600;
      rowcount.$set(rowcount_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rowcount.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rowcount.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rowcount, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let pagination_1;
  let current;
  pagination_1 = new Pagination_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[6] < 600
      )
    }
  });
  return {
    c() {
      create_component(pagination_1.$$.fragment);
    },
    l(nodes) {
      claim_component(pagination_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(pagination_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pagination_1_changes = {};
      if (dirty & /*handler*/
      1) pagination_1_changes.handler = /*handler*/
      ctx2[0];
      if (dirty & /*clientWidth*/
      64) pagination_1_changes.small = /*clientWidth*/
      ctx2[6] < 600;
      pagination_1.$set(pagination_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(pagination_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pagination_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pagination_1, detaching);
    }
  };
}
function create_fragment7(ctx) {
  let section;
  let header;
  let t0;
  let t1;
  let article;
  let t2;
  let footer;
  let t3;
  let section_class_value;
  let section_resize_listener;
  let current;
  let if_block0 = (
    /*search*/
    ctx[1] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*rowsPerPage*/
    ctx[2] && create_if_block_22(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block2 = (
    /*rowCount*/
    ctx[3] && create_if_block_13(ctx)
  );
  let if_block3 = (
    /*pagination*/
    ctx[4] && create_if_block4(ctx)
  );
  return {
    c() {
      section = element("section");
      header = element("header");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      article = element("article");
      if (default_slot) default_slot.c();
      t2 = space();
      footer = element("footer");
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      this.h();
    },
    l(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      header = claim_element(section_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (if_block0) if_block0.l(header_nodes);
      t0 = claim_space(header_nodes);
      if (if_block1) if_block1.l(header_nodes);
      header_nodes.forEach(detach);
      t1 = claim_space(section_nodes);
      article = claim_element(section_nodes, "ARTICLE", { style: true, class: true });
      var article_nodes = children(article);
      if (default_slot) default_slot.l(article_nodes);
      article_nodes.forEach(detach);
      t2 = claim_space(section_nodes);
      footer = claim_element(section_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (if_block2) if_block2.l(footer_nodes);
      t3 = claim_space(footer_nodes);
      if (if_block3) if_block3.l(footer_nodes);
      footer_nodes.forEach(detach);
      section_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(header, "class", "svelte-1ere01f");
      toggle_class(
        header,
        "container",
        /*search*/
        ctx[1] || /*rowsPerPage*/
        ctx[2]
      );
      set_style(article, "height", "calc(100% - " + /*height*/
      ctx[7] + "px)");
      attr(article, "class", "svelte-1ere01f");
      attr(footer, "class", "svelte-1ere01f");
      toggle_class(
        footer,
        "container",
        /*rowCount*/
        ctx[3] || /*pagination*/
        ctx[4]
      );
      attr(section, "class", section_class_value = null_to_empty(
        /*$$props*/
        ctx[8].class ?? ""
      ) + " svelte-1ere01f");
      add_render_callback(() => (
        /*section_elementresize_handler*/
        ctx[12].call(section)
      ));
    },
    m(target, anchor) {
      insert_hydration(target, section, anchor);
      append_hydration(section, header);
      if (if_block0) if_block0.m(header, null);
      append_hydration(header, t0);
      if (if_block1) if_block1.m(header, null);
      append_hydration(section, t1);
      append_hydration(section, article);
      if (default_slot) {
        default_slot.m(article, null);
      }
      ctx[11](article);
      append_hydration(section, t2);
      append_hydration(section, footer);
      if (if_block2) if_block2.m(footer, null);
      append_hydration(footer, t3);
      if (if_block3) if_block3.m(footer, null);
      section_resize_listener = add_iframe_resize_listener(
        section,
        /*section_elementresize_handler*/
        ctx[12].bind(section)
      );
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*search*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*search*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(header, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*rowsPerPage*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*rowsPerPage*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(header, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*search, rowsPerPage*/
      6) {
        toggle_class(
          header,
          "container",
          /*search*/
          ctx2[1] || /*rowsPerPage*/
          ctx2[2]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*rowCount*/
        ctx2[3]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*rowCount*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(footer, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*pagination*/
        ctx2[4]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*pagination*/
          16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block4(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(footer, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*rowCount, pagination*/
      24) {
        toggle_class(
          footer,
          "container",
          /*rowCount*/
          ctx2[3] || /*pagination*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$$props*/
      256 && section_class_value !== (section_class_value = null_to_empty(
        /*$$props*/
        ctx2[8].class ?? ""
      ) + " svelte-1ere01f")) {
        attr(section, "class", section_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
      ctx[11](null);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      section_resize_listener();
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { handler } = $$props;
  let { search = true } = $$props;
  let { rowsPerPage = true } = $$props;
  let { rowCount = true } = $$props;
  let { pagination = true } = $$props;
  let element2;
  let clientWidth = 1e3;
  const height = (search || rowsPerPage ? 48 : 8) + (rowCount || pagination ? 48 : 8);
  handler.on("change", () => {
    if (element2) $$invalidate(5, element2.scrollTop = 0, element2);
  });
  function article_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  function section_elementresize_handler() {
    clientWidth = this.clientWidth;
    $$invalidate(6, clientWidth);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props) $$invalidate(0, handler = $$new_props.handler);
    if ("search" in $$new_props) $$invalidate(1, search = $$new_props.search);
    if ("rowsPerPage" in $$new_props) $$invalidate(2, rowsPerPage = $$new_props.rowsPerPage);
    if ("rowCount" in $$new_props) $$invalidate(3, rowCount = $$new_props.rowCount);
    if ("pagination" in $$new_props) $$invalidate(4, pagination = $$new_props.pagination);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    handler,
    search,
    rowsPerPage,
    rowCount,
    pagination,
    element2,
    clientWidth,
    height,
    $$props,
    $$scope,
    slots,
    article_binding,
    section_elementresize_handler
  ];
}
var Datatable = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        handler: 0,
        search: 1,
        rowsPerPage: 2,
        rowCount: 3,
        pagination: 4
      },
      add_css7
    );
  }
};
var Datatable_default = Datatable;
export {
  DataHandler,
  Datatable_default as Datatable,
  Pagination_default as Pagination,
  RowCount_default as RowCount,
  RowsPerPage_default as RowsPerPage,
  Search_default as Search,
  Th_default as Th,
  ThFilter_default as ThFilter,
  check
};
//# sourceMappingURL=@vincjo_datatables.js.map
