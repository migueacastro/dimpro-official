import "./chunk-V6TY7KAL.js";

// node_modules/jsbi/dist/jsbi.mjs
var JSBI = class _JSBI extends Array {
  constructor(i2, _2) {
    if (super(i2), this.sign = _2, Object.setPrototypeOf(this, _JSBI.prototype), i2 > _JSBI.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded");
  }
  static BigInt(i2) {
    var _2 = Math.floor, t2 = Number.isFinite;
    if ("number" == typeof i2) {
      if (0 === i2) return _JSBI.__zero();
      if (_JSBI.__isOneDigitInt(i2)) return 0 > i2 ? _JSBI.__oneDigit(-i2, true) : _JSBI.__oneDigit(i2, false);
      if (!t2(i2) || _2(i2) !== i2) throw new RangeError("The number " + i2 + " cannot be converted to BigInt because it is not an integer");
      return _JSBI.__fromDouble(i2);
    }
    if ("string" == typeof i2) {
      const _3 = _JSBI.__fromString(i2);
      if (null === _3) throw new SyntaxError("Cannot convert " + i2 + " to a BigInt");
      return _3;
    }
    if ("boolean" == typeof i2) return true === i2 ? _JSBI.__oneDigit(1, false) : _JSBI.__zero();
    if ("object" == typeof i2) {
      if (i2.constructor === _JSBI) return i2;
      const _3 = _JSBI.__toPrimitive(i2);
      return _JSBI.BigInt(_3);
    }
    throw new TypeError("Cannot convert " + i2 + " to a BigInt");
  }
  toDebugString() {
    const i2 = ["BigInt["];
    for (const _2 of this) i2.push((_2 ? (_2 >>> 0).toString(16) : _2) + ", ");
    return i2.push("]"), i2.join("");
  }
  toString(i2 = 10) {
    if (2 > i2 || 36 < i2) throw new RangeError("toString() radix argument must be between 2 and 36");
    return 0 === this.length ? "0" : 0 == (i2 & i2 - 1) ? _JSBI.__toStringBasePowerOfTwo(this, i2) : _JSBI.__toStringGeneric(this, i2, false);
  }
  valueOf() {
    throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
  }
  static toNumber(i2) {
    const _2 = i2.length;
    if (0 === _2) return 0;
    if (1 === _2) {
      const _3 = i2.__unsignedDigit(0);
      return i2.sign ? -_3 : _3;
    }
    const t2 = i2.__digit(_2 - 1), e = _JSBI.__clz30(t2), n2 = 30 * _2 - e;
    if (1024 < n2) return i2.sign ? -Infinity : 1 / 0;
    let g2 = n2 - 1, s2 = t2, o2 = _2 - 1;
    const l2 = e + 3;
    let r2 = 32 === l2 ? 0 : s2 << l2;
    r2 >>>= 12;
    const a2 = l2 - 12;
    let u2 = 12 <= l2 ? 0 : s2 << 20 + l2, d2 = 20 + l2;
    for (0 < a2 && 0 < o2 && (o2--, s2 = i2.__digit(o2), r2 |= s2 >>> 30 - a2, u2 = s2 << a2 + 2, d2 = a2 + 2); 0 < d2 && 0 < o2; ) o2--, s2 = i2.__digit(o2), u2 |= 30 <= d2 ? s2 << d2 - 30 : s2 >>> 30 - d2, d2 -= 30;
    const h2 = _JSBI.__decideRounding(i2, d2, o2, s2);
    if ((1 === h2 || 0 === h2 && 1 == (1 & u2)) && (u2 = u2 + 1 >>> 0, 0 === u2 && (r2++, 0 != r2 >>> 20 && (r2 = 0, g2++, 1023 < g2)))) return i2.sign ? -Infinity : 1 / 0;
    const m2 = i2.sign ? -2147483648 : 0;
    return g2 = g2 + 1023 << 20, _JSBI.__kBitConversionInts[1] = m2 | g2 | r2, _JSBI.__kBitConversionInts[0] = u2, _JSBI.__kBitConversionDouble[0];
  }
  static unaryMinus(i2) {
    if (0 === i2.length) return i2;
    const _2 = i2.__copy();
    return _2.sign = !i2.sign, _2;
  }
  static bitwiseNot(i2) {
    return i2.sign ? _JSBI.__absoluteSubOne(i2).__trim() : _JSBI.__absoluteAddOne(i2, true);
  }
  static exponentiate(i2, _2) {
    if (_2.sign) throw new RangeError("Exponent must be positive");
    if (0 === _2.length) return _JSBI.__oneDigit(1, false);
    if (0 === i2.length) return i2;
    if (1 === i2.length && 1 === i2.__digit(0)) return i2.sign && 0 == (1 & _2.__digit(0)) ? _JSBI.unaryMinus(i2) : i2;
    if (1 < _2.length) throw new RangeError("BigInt too big");
    let t2 = _2.__unsignedDigit(0);
    if (1 === t2) return i2;
    if (t2 >= _JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
    if (1 === i2.length && 2 === i2.__digit(0)) {
      const _3 = 1 + (0 | t2 / 30), e2 = i2.sign && 0 != (1 & t2), n3 = new _JSBI(_3, e2);
      n3.__initializeDigits();
      const g2 = 1 << t2 % 30;
      return n3.__setDigit(_3 - 1, g2), n3;
    }
    let e = null, n2 = i2;
    for (0 != (1 & t2) && (e = i2), t2 >>= 1; 0 !== t2; t2 >>= 1) n2 = _JSBI.multiply(n2, n2), 0 != (1 & t2) && (null === e ? e = n2 : e = _JSBI.multiply(e, n2));
    return e;
  }
  static multiply(_2, t2) {
    if (0 === _2.length) return _2;
    if (0 === t2.length) return t2;
    let i2 = _2.length + t2.length;
    30 <= _2.__clzmsd() + t2.__clzmsd() && i2--;
    const e = new _JSBI(i2, _2.sign !== t2.sign);
    e.__initializeDigits();
    for (let n2 = 0; n2 < _2.length; n2++) _JSBI.__multiplyAccumulate(t2, _2.__digit(n2), e, n2);
    return e.__trim();
  }
  static divide(i2, _2) {
    if (0 === _2.length) throw new RangeError("Division by zero");
    if (0 > _JSBI.__absoluteCompare(i2, _2)) return _JSBI.__zero();
    const t2 = i2.sign !== _2.sign, e = _2.__unsignedDigit(0);
    let n2;
    if (1 === _2.length && 32767 >= e) {
      if (1 === e) return t2 === i2.sign ? i2 : _JSBI.unaryMinus(i2);
      n2 = _JSBI.__absoluteDivSmall(i2, e, null);
    } else n2 = _JSBI.__absoluteDivLarge(i2, _2, true, false);
    return n2.sign = t2, n2.__trim();
  }
  static remainder(i2, _2) {
    if (0 === _2.length) throw new RangeError("Division by zero");
    if (0 > _JSBI.__absoluteCompare(i2, _2)) return i2;
    const t2 = _2.__unsignedDigit(0);
    if (1 === _2.length && 32767 >= t2) {
      if (1 === t2) return _JSBI.__zero();
      const _3 = _JSBI.__absoluteModSmall(i2, t2);
      return 0 === _3 ? _JSBI.__zero() : _JSBI.__oneDigit(_3, i2.sign);
    }
    const e = _JSBI.__absoluteDivLarge(i2, _2, false, true);
    return e.sign = i2.sign, e.__trim();
  }
  static add(i2, _2) {
    const t2 = i2.sign;
    return t2 === _2.sign ? _JSBI.__absoluteAdd(i2, _2, t2) : 0 <= _JSBI.__absoluteCompare(i2, _2) ? _JSBI.__absoluteSub(i2, _2, t2) : _JSBI.__absoluteSub(_2, i2, !t2);
  }
  static subtract(i2, _2) {
    const t2 = i2.sign;
    return t2 === _2.sign ? 0 <= _JSBI.__absoluteCompare(i2, _2) ? _JSBI.__absoluteSub(i2, _2, t2) : _JSBI.__absoluteSub(_2, i2, !t2) : _JSBI.__absoluteAdd(i2, _2, t2);
  }
  static leftShift(i2, _2) {
    return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? _JSBI.__rightShiftByAbsolute(i2, _2) : _JSBI.__leftShiftByAbsolute(i2, _2);
  }
  static signedRightShift(i2, _2) {
    return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? _JSBI.__leftShiftByAbsolute(i2, _2) : _JSBI.__rightShiftByAbsolute(i2, _2);
  }
  static unsignedRightShift() {
    throw new TypeError("BigInts have no unsigned right shift; use >> instead");
  }
  static lessThan(i2, _2) {
    return 0 > _JSBI.__compareToBigInt(i2, _2);
  }
  static lessThanOrEqual(i2, _2) {
    return 0 >= _JSBI.__compareToBigInt(i2, _2);
  }
  static greaterThan(i2, _2) {
    return 0 < _JSBI.__compareToBigInt(i2, _2);
  }
  static greaterThanOrEqual(i2, _2) {
    return 0 <= _JSBI.__compareToBigInt(i2, _2);
  }
  static equal(_2, t2) {
    if (_2.sign !== t2.sign) return false;
    if (_2.length !== t2.length) return false;
    for (let e = 0; e < _2.length; e++) if (_2.__digit(e) !== t2.__digit(e)) return false;
    return true;
  }
  static notEqual(i2, _2) {
    return !_JSBI.equal(i2, _2);
  }
  static bitwiseAnd(i2, _2) {
    var t2 = Math.max;
    if (!i2.sign && !_2.sign) return _JSBI.__absoluteAnd(i2, _2).__trim();
    if (i2.sign && _2.sign) {
      const e = t2(i2.length, _2.length) + 1;
      let n2 = _JSBI.__absoluteSubOne(i2, e);
      const g2 = _JSBI.__absoluteSubOne(_2);
      return n2 = _JSBI.__absoluteOr(n2, g2, n2), _JSBI.__absoluteAddOne(n2, true, n2).__trim();
    }
    return i2.sign && ([i2, _2] = [_2, i2]), _JSBI.__absoluteAndNot(i2, _JSBI.__absoluteSubOne(_2)).__trim();
  }
  static bitwiseXor(i2, _2) {
    var t2 = Math.max;
    if (!i2.sign && !_2.sign) return _JSBI.__absoluteXor(i2, _2).__trim();
    if (i2.sign && _2.sign) {
      const e2 = t2(i2.length, _2.length), n3 = _JSBI.__absoluteSubOne(i2, e2), g2 = _JSBI.__absoluteSubOne(_2);
      return _JSBI.__absoluteXor(n3, g2, n3).__trim();
    }
    const e = t2(i2.length, _2.length) + 1;
    i2.sign && ([i2, _2] = [_2, i2]);
    let n2 = _JSBI.__absoluteSubOne(_2, e);
    return n2 = _JSBI.__absoluteXor(n2, i2, n2), _JSBI.__absoluteAddOne(n2, true, n2).__trim();
  }
  static bitwiseOr(i2, _2) {
    var t2 = Math.max;
    const e = t2(i2.length, _2.length);
    if (!i2.sign && !_2.sign) return _JSBI.__absoluteOr(i2, _2).__trim();
    if (i2.sign && _2.sign) {
      let t3 = _JSBI.__absoluteSubOne(i2, e);
      const n3 = _JSBI.__absoluteSubOne(_2);
      return t3 = _JSBI.__absoluteAnd(t3, n3, t3), _JSBI.__absoluteAddOne(t3, true, t3).__trim();
    }
    i2.sign && ([i2, _2] = [_2, i2]);
    let n2 = _JSBI.__absoluteSubOne(_2, e);
    return n2 = _JSBI.__absoluteAndNot(n2, i2, n2), _JSBI.__absoluteAddOne(n2, true, n2).__trim();
  }
  static asIntN(_2, t2) {
    var i2 = Math.floor;
    if (0 === t2.length) return t2;
    if (_2 = i2(_2), 0 > _2) throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === _2) return _JSBI.__zero();
    if (_2 >= _JSBI.__kMaxLengthBits) return t2;
    const e = 0 | (_2 + 29) / 30;
    if (t2.length < e) return t2;
    const g2 = t2.__unsignedDigit(e - 1), s2 = 1 << (_2 - 1) % 30;
    if (t2.length === e && g2 < s2) return t2;
    if (!((g2 & s2) === s2)) return _JSBI.__truncateToNBits(_2, t2);
    if (!t2.sign) return _JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, true);
    if (0 == (g2 & s2 - 1)) {
      for (let n2 = e - 2; 0 <= n2; n2--) if (0 !== t2.__digit(n2)) return _JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
      return t2.length === e && g2 === s2 ? t2 : _JSBI.__truncateToNBits(_2, t2);
    }
    return _JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
  }
  static asUintN(i2, _2) {
    var t2 = Math.floor;
    if (0 === _2.length) return _2;
    if (i2 = t2(i2), 0 > i2) throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === i2) return _JSBI.__zero();
    if (_2.sign) {
      if (i2 > _JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
      return _JSBI.__truncateAndSubFromPowerOfTwo(i2, _2, false);
    }
    if (i2 >= _JSBI.__kMaxLengthBits) return _2;
    const e = 0 | (i2 + 29) / 30;
    if (_2.length < e) return _2;
    const g2 = i2 % 30;
    if (_2.length == e) {
      if (0 === g2) return _2;
      const i3 = _2.__digit(e - 1);
      if (0 == i3 >>> g2) return _2;
    }
    return _JSBI.__truncateToNBits(i2, _2);
  }
  static ADD(i2, _2) {
    if (i2 = _JSBI.__toPrimitive(i2), _2 = _JSBI.__toPrimitive(_2), "string" == typeof i2) return "string" != typeof _2 && (_2 = _2.toString()), i2 + _2;
    if ("string" == typeof _2) return i2.toString() + _2;
    if (i2 = _JSBI.__toNumeric(i2), _2 = _JSBI.__toNumeric(_2), _JSBI.__isBigInt(i2) && _JSBI.__isBigInt(_2)) return _JSBI.add(i2, _2);
    if ("number" == typeof i2 && "number" == typeof _2) return i2 + _2;
    throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
  }
  static LT(i2, _2) {
    return _JSBI.__compare(i2, _2, 0);
  }
  static LE(i2, _2) {
    return _JSBI.__compare(i2, _2, 1);
  }
  static GT(i2, _2) {
    return _JSBI.__compare(i2, _2, 2);
  }
  static GE(i2, _2) {
    return _JSBI.__compare(i2, _2, 3);
  }
  static EQ(i2, _2) {
    for (; ; ) {
      if (_JSBI.__isBigInt(i2)) return _JSBI.__isBigInt(_2) ? _JSBI.equal(i2, _2) : _JSBI.EQ(_2, i2);
      if ("number" == typeof i2) {
        if (_JSBI.__isBigInt(_2)) return _JSBI.__equalToNumber(_2, i2);
        if ("object" != typeof _2) return i2 == _2;
        _2 = _JSBI.__toPrimitive(_2);
      } else if ("string" == typeof i2) {
        if (_JSBI.__isBigInt(_2)) return i2 = _JSBI.__fromString(i2), null !== i2 && _JSBI.equal(i2, _2);
        if ("object" != typeof _2) return i2 == _2;
        _2 = _JSBI.__toPrimitive(_2);
      } else if ("boolean" == typeof i2) {
        if (_JSBI.__isBigInt(_2)) return _JSBI.__equalToNumber(_2, +i2);
        if ("object" != typeof _2) return i2 == _2;
        _2 = _JSBI.__toPrimitive(_2);
      } else if ("symbol" == typeof i2) {
        if (_JSBI.__isBigInt(_2)) return false;
        if ("object" != typeof _2) return i2 == _2;
        _2 = _JSBI.__toPrimitive(_2);
      } else if ("object" == typeof i2) {
        if ("object" == typeof _2 && _2.constructor !== _JSBI) return i2 == _2;
        i2 = _JSBI.__toPrimitive(i2);
      } else return i2 == _2;
    }
  }
  static NE(i2, _2) {
    return !_JSBI.EQ(i2, _2);
  }
  static DataViewGetBigInt64(i2, _2, t2 = false) {
    return _JSBI.asIntN(64, _JSBI.DataViewGetBigUint64(i2, _2, t2));
  }
  static DataViewGetBigUint64(i2, _2, t2 = false) {
    const [e, n2] = t2 ? [4, 0] : [0, 4], g2 = i2.getUint32(_2 + e, t2), s2 = i2.getUint32(_2 + n2, t2), o2 = new _JSBI(3, false);
    return o2.__setDigit(0, 1073741823 & s2), o2.__setDigit(1, (268435455 & g2) << 2 | s2 >>> 30), o2.__setDigit(2, g2 >>> 28), o2.__trim();
  }
  static DataViewSetBigInt64(i2, _2, t2, e = false) {
    _JSBI.DataViewSetBigUint64(i2, _2, t2, e);
  }
  static DataViewSetBigUint64(i2, _2, t2, e = false) {
    t2 = _JSBI.asUintN(64, t2);
    let n2 = 0, g2 = 0;
    if (0 < t2.length && (g2 = t2.__digit(0), 1 < t2.length)) {
      const i3 = t2.__digit(1);
      g2 |= i3 << 30, n2 = i3 >>> 2, 2 < t2.length && (n2 |= t2.__digit(2) << 28);
    }
    const [s2, o2] = e ? [4, 0] : [0, 4];
    i2.setUint32(_2 + s2, n2, e), i2.setUint32(_2 + o2, g2, e);
  }
  static __zero() {
    return new _JSBI(0, false);
  }
  static __oneDigit(i2, _2) {
    const t2 = new _JSBI(1, _2);
    return t2.__setDigit(0, i2), t2;
  }
  __copy() {
    const _2 = new _JSBI(this.length, this.sign);
    for (let t2 = 0; t2 < this.length; t2++) _2[t2] = this[t2];
    return _2;
  }
  __trim() {
    let i2 = this.length, _2 = this[i2 - 1];
    for (; 0 === _2; ) i2--, _2 = this[i2 - 1], this.pop();
    return 0 === i2 && (this.sign = false), this;
  }
  __initializeDigits() {
    for (let _2 = 0; _2 < this.length; _2++) this[_2] = 0;
  }
  static __decideRounding(i2, _2, t2, e) {
    if (0 < _2) return -1;
    let n2;
    if (0 > _2) n2 = -_2 - 1;
    else {
      if (0 === t2) return -1;
      t2--, e = i2.__digit(t2), n2 = 29;
    }
    let g2 = 1 << n2;
    if (0 == (e & g2)) return -1;
    if (g2 -= 1, 0 != (e & g2)) return 1;
    for (; 0 < t2; ) if (t2--, 0 !== i2.__digit(t2)) return 1;
    return 0;
  }
  static __fromDouble(i2) {
    _JSBI.__kBitConversionDouble[0] = i2;
    const _2 = 2047 & _JSBI.__kBitConversionInts[1] >>> 20, t2 = _2 - 1023, e = (0 | t2 / 30) + 1, n2 = new _JSBI(e, 0 > i2);
    let g2 = 1048575 & _JSBI.__kBitConversionInts[1] | 1048576, s2 = _JSBI.__kBitConversionInts[0];
    const o2 = 20, l2 = t2 % 30;
    let r2, a2 = 0;
    if (l2 < 20) {
      const i3 = o2 - l2;
      a2 = i3 + 32, r2 = g2 >>> i3, g2 = g2 << 32 - i3 | s2 >>> i3, s2 <<= 32 - i3;
    } else if (l2 === 20) a2 = 32, r2 = g2, g2 = s2, s2 = 0;
    else {
      const i3 = l2 - o2;
      a2 = 32 - i3, r2 = g2 << i3 | s2 >>> 32 - i3, g2 = s2 << i3, s2 = 0;
    }
    n2.__setDigit(e - 1, r2);
    for (let _3 = e - 2; 0 <= _3; _3--) 0 < a2 ? (a2 -= 30, r2 = g2 >>> 2, g2 = g2 << 30 | s2 >>> 2, s2 <<= 30) : r2 = 0, n2.__setDigit(_3, r2);
    return n2.__trim();
  }
  static __isWhitespace(i2) {
    return !!(13 >= i2 && 9 <= i2) || (159 >= i2 ? 32 == i2 : 131071 >= i2 ? 160 == i2 || 5760 == i2 : 196607 >= i2 ? (i2 &= 131071, 10 >= i2 || 40 == i2 || 41 == i2 || 47 == i2 || 95 == i2 || 4096 == i2) : 65279 == i2);
  }
  static __fromString(i2, _2 = 0) {
    let t2 = 0;
    const e = i2.length;
    let n2 = 0;
    if (n2 === e) return _JSBI.__zero();
    let g2 = i2.charCodeAt(n2);
    for (; _JSBI.__isWhitespace(g2); ) {
      if (++n2 === e) return _JSBI.__zero();
      g2 = i2.charCodeAt(n2);
    }
    if (43 === g2) {
      if (++n2 === e) return null;
      g2 = i2.charCodeAt(n2), t2 = 1;
    } else if (45 === g2) {
      if (++n2 === e) return null;
      g2 = i2.charCodeAt(n2), t2 = -1;
    }
    if (0 === _2) {
      if (_2 = 10, 48 === g2) {
        if (++n2 === e) return _JSBI.__zero();
        if (g2 = i2.charCodeAt(n2), 88 === g2 || 120 === g2) {
          if (_2 = 16, ++n2 === e) return null;
          g2 = i2.charCodeAt(n2);
        } else if (79 === g2 || 111 === g2) {
          if (_2 = 8, ++n2 === e) return null;
          g2 = i2.charCodeAt(n2);
        } else if (66 === g2 || 98 === g2) {
          if (_2 = 2, ++n2 === e) return null;
          g2 = i2.charCodeAt(n2);
        }
      }
    } else if (16 === _2 && 48 === g2) {
      if (++n2 === e) return _JSBI.__zero();
      if (g2 = i2.charCodeAt(n2), 88 === g2 || 120 === g2) {
        if (++n2 === e) return null;
        g2 = i2.charCodeAt(n2);
      }
    }
    if (0 != t2 && 10 !== _2) return null;
    for (; 48 === g2; ) {
      if (++n2 === e) return _JSBI.__zero();
      g2 = i2.charCodeAt(n2);
    }
    const s2 = e - n2;
    let o2 = _JSBI.__kMaxBitsPerChar[_2], l2 = _JSBI.__kBitsPerCharTableMultiplier - 1;
    if (s2 > 1073741824 / o2) return null;
    const r2 = o2 * s2 + l2 >>> _JSBI.__kBitsPerCharTableShift, a2 = new _JSBI(0 | (r2 + 29) / 30, false), u2 = 10 > _2 ? _2 : 10, h2 = 10 < _2 ? _2 - 10 : 0;
    if (0 == (_2 & _2 - 1)) {
      o2 >>= _JSBI.__kBitsPerCharTableShift;
      const _3 = [], t3 = [];
      let s3 = false;
      do {
        let l3 = 0, r3 = 0;
        for (; ; ) {
          let _4;
          if (g2 - 48 >>> 0 < u2) _4 = g2 - 48;
          else if ((32 | g2) - 97 >>> 0 < h2) _4 = (32 | g2) - 87;
          else {
            s3 = true;
            break;
          }
          if (r3 += o2, l3 = l3 << o2 | _4, ++n2 === e) {
            s3 = true;
            break;
          }
          if (g2 = i2.charCodeAt(n2), 30 < r3 + o2) break;
        }
        _3.push(l3), t3.push(r3);
      } while (!s3);
      _JSBI.__fillFromParts(a2, _3, t3);
    } else {
      a2.__initializeDigits();
      let t3 = false, s3 = 0;
      do {
        let r3 = 0, b2 = 1;
        for (; ; ) {
          let o3;
          if (g2 - 48 >>> 0 < u2) o3 = g2 - 48;
          else if ((32 | g2) - 97 >>> 0 < h2) o3 = (32 | g2) - 87;
          else {
            t3 = true;
            break;
          }
          const l3 = b2 * _2;
          if (1073741823 < l3) break;
          if (b2 = l3, r3 = r3 * _2 + o3, s3++, ++n2 === e) {
            t3 = true;
            break;
          }
          g2 = i2.charCodeAt(n2);
        }
        l2 = 30 * _JSBI.__kBitsPerCharTableMultiplier - 1;
        const D2 = 0 | (o2 * s3 + l2 >>> _JSBI.__kBitsPerCharTableShift) / 30;
        a2.__inplaceMultiplyAdd(b2, r3, D2);
      } while (!t3);
    }
    if (n2 !== e) {
      if (!_JSBI.__isWhitespace(g2)) return null;
      for (n2++; n2 < e; n2++) if (g2 = i2.charCodeAt(n2), !_JSBI.__isWhitespace(g2)) return null;
    }
    return a2.sign = -1 == t2, a2.__trim();
  }
  static __fillFromParts(_2, t2, e) {
    let n2 = 0, g2 = 0, s2 = 0;
    for (let o2 = t2.length - 1; 0 <= o2; o2--) {
      const i2 = t2[o2], l2 = e[o2];
      g2 |= i2 << s2, s2 += l2, 30 === s2 ? (_2.__setDigit(n2++, g2), s2 = 0, g2 = 0) : 30 < s2 && (_2.__setDigit(n2++, 1073741823 & g2), s2 -= 30, g2 = i2 >>> l2 - s2);
    }
    if (0 !== g2) {
      if (n2 >= _2.length) throw new Error("implementation bug");
      _2.__setDigit(n2++, g2);
    }
    for (; n2 < _2.length; n2++) _2.__setDigit(n2, 0);
  }
  static __toStringBasePowerOfTwo(_2, i2) {
    const t2 = _2.length;
    let e = i2 - 1;
    e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
    const n2 = e, g2 = i2 - 1, s2 = _2.__digit(t2 - 1), o2 = _JSBI.__clz30(s2);
    let l2 = 0 | (30 * t2 - o2 + n2 - 1) / n2;
    if (_2.sign && l2++, 268435456 < l2) throw new Error("string too long");
    const r2 = Array(l2);
    let a2 = l2 - 1, u2 = 0, d2 = 0;
    for (let e2 = 0; e2 < t2 - 1; e2++) {
      const i3 = _2.__digit(e2), t3 = (u2 | i3 << d2) & g2;
      r2[a2--] = _JSBI.__kConversionChars[t3];
      const s3 = n2 - d2;
      for (u2 = i3 >>> s3, d2 = 30 - s3; d2 >= n2; ) r2[a2--] = _JSBI.__kConversionChars[u2 & g2], u2 >>>= n2, d2 -= n2;
    }
    const h2 = (u2 | s2 << d2) & g2;
    for (r2[a2--] = _JSBI.__kConversionChars[h2], u2 = s2 >>> n2 - d2; 0 !== u2; ) r2[a2--] = _JSBI.__kConversionChars[u2 & g2], u2 >>>= n2;
    if (_2.sign && (r2[a2--] = "-"), -1 != a2) throw new Error("implementation bug");
    return r2.join("");
  }
  static __toStringGeneric(_2, i2, t2) {
    const e = _2.length;
    if (0 === e) return "";
    if (1 === e) {
      let e2 = _2.__unsignedDigit(0).toString(i2);
      return false === t2 && _2.sign && (e2 = "-" + e2), e2;
    }
    const n2 = 30 * e - _JSBI.__clz30(_2.__digit(e - 1)), g2 = _JSBI.__kMaxBitsPerChar[i2], s2 = g2 - 1;
    let o2 = n2 * _JSBI.__kBitsPerCharTableMultiplier;
    o2 += s2 - 1, o2 = 0 | o2 / s2;
    const l2 = o2 + 1 >> 1, r2 = _JSBI.exponentiate(_JSBI.__oneDigit(i2, false), _JSBI.__oneDigit(l2, false));
    let a2, u2;
    const d2 = r2.__unsignedDigit(0);
    if (1 === r2.length && 32767 >= d2) {
      a2 = new _JSBI(_2.length, false), a2.__initializeDigits();
      let t3 = 0;
      for (let e2 = 2 * _2.length - 1; 0 <= e2; e2--) {
        const i3 = t3 << 15 | _2.__halfDigit(e2);
        a2.__setHalfDigit(e2, 0 | i3 / d2), t3 = 0 | i3 % d2;
      }
      u2 = t3.toString(i2);
    } else {
      const t3 = _JSBI.__absoluteDivLarge(_2, r2, true, true);
      a2 = t3.quotient;
      const e2 = t3.remainder.__trim();
      u2 = _JSBI.__toStringGeneric(e2, i2, true);
    }
    a2.__trim();
    let h2 = _JSBI.__toStringGeneric(a2, i2, true);
    for (; u2.length < l2; ) u2 = "0" + u2;
    return false === t2 && _2.sign && (h2 = "-" + h2), h2 + u2;
  }
  static __unequalSign(i2) {
    return i2 ? -1 : 1;
  }
  static __absoluteGreater(i2) {
    return i2 ? -1 : 1;
  }
  static __absoluteLess(i2) {
    return i2 ? 1 : -1;
  }
  static __compareToBigInt(i2, _2) {
    const t2 = i2.sign;
    if (t2 !== _2.sign) return _JSBI.__unequalSign(t2);
    const e = _JSBI.__absoluteCompare(i2, _2);
    return 0 < e ? _JSBI.__absoluteGreater(t2) : 0 > e ? _JSBI.__absoluteLess(t2) : 0;
  }
  static __compareToNumber(i2, _2) {
    if (_JSBI.__isOneDigitInt(_2)) {
      const t2 = i2.sign, e = 0 > _2;
      if (t2 !== e) return _JSBI.__unequalSign(t2);
      if (0 === i2.length) {
        if (e) throw new Error("implementation bug");
        return 0 === _2 ? 0 : -1;
      }
      if (1 < i2.length) return _JSBI.__absoluteGreater(t2);
      const n2 = Math.abs(_2), g2 = i2.__unsignedDigit(0);
      return g2 > n2 ? _JSBI.__absoluteGreater(t2) : g2 < n2 ? _JSBI.__absoluteLess(t2) : 0;
    }
    return _JSBI.__compareToDouble(i2, _2);
  }
  static __compareToDouble(i2, _2) {
    if (_2 !== _2) return _2;
    if (_2 === 1 / 0) return -1;
    if (_2 === -Infinity) return 1;
    const t2 = i2.sign;
    if (t2 !== 0 > _2) return _JSBI.__unequalSign(t2);
    if (0 === _2) throw new Error("implementation bug: should be handled elsewhere");
    if (0 === i2.length) return -1;
    _JSBI.__kBitConversionDouble[0] = _2;
    const e = 2047 & _JSBI.__kBitConversionInts[1] >>> 20;
    if (2047 == e) throw new Error("implementation bug: handled elsewhere");
    const n2 = e - 1023;
    if (0 > n2) return _JSBI.__absoluteGreater(t2);
    const g2 = i2.length;
    let s2 = i2.__digit(g2 - 1);
    const o2 = _JSBI.__clz30(s2), l2 = 30 * g2 - o2, r2 = n2 + 1;
    if (l2 < r2) return _JSBI.__absoluteLess(t2);
    if (l2 > r2) return _JSBI.__absoluteGreater(t2);
    let a2 = 1048576 | 1048575 & _JSBI.__kBitConversionInts[1], u2 = _JSBI.__kBitConversionInts[0];
    const d2 = 20, h2 = 29 - o2;
    if (h2 !== (0 | (l2 - 1) % 30)) throw new Error("implementation bug");
    let m2, b2 = 0;
    if (20 > h2) {
      const i3 = d2 - h2;
      b2 = i3 + 32, m2 = a2 >>> i3, a2 = a2 << 32 - i3 | u2 >>> i3, u2 <<= 32 - i3;
    } else if (20 === h2) b2 = 32, m2 = a2, a2 = u2, u2 = 0;
    else {
      const i3 = h2 - d2;
      b2 = 32 - i3, m2 = a2 << i3 | u2 >>> 32 - i3, a2 = u2 << i3, u2 = 0;
    }
    if (s2 >>>= 0, m2 >>>= 0, s2 > m2) return _JSBI.__absoluteGreater(t2);
    if (s2 < m2) return _JSBI.__absoluteLess(t2);
    for (let e2 = g2 - 2; 0 <= e2; e2--) {
      0 < b2 ? (b2 -= 30, m2 = a2 >>> 2, a2 = a2 << 30 | u2 >>> 2, u2 <<= 30) : m2 = 0;
      const _3 = i2.__unsignedDigit(e2);
      if (_3 > m2) return _JSBI.__absoluteGreater(t2);
      if (_3 < m2) return _JSBI.__absoluteLess(t2);
    }
    if (0 !== a2 || 0 !== u2) {
      if (0 === b2) throw new Error("implementation bug");
      return _JSBI.__absoluteLess(t2);
    }
    return 0;
  }
  static __equalToNumber(i2, _2) {
    var t2 = Math.abs;
    return _JSBI.__isOneDigitInt(_2) ? 0 === _2 ? 0 === i2.length : 1 === i2.length && i2.sign === 0 > _2 && i2.__unsignedDigit(0) === t2(_2) : 0 === _JSBI.__compareToDouble(i2, _2);
  }
  static __comparisonResultToBool(i2, _2) {
    return 0 === _2 ? 0 > i2 : 1 === _2 ? 0 >= i2 : 2 === _2 ? 0 < i2 : 3 === _2 ? 0 <= i2 : void 0;
  }
  static __compare(i2, _2, t2) {
    if (i2 = _JSBI.__toPrimitive(i2), _2 = _JSBI.__toPrimitive(_2), "string" == typeof i2 && "string" == typeof _2) switch (t2) {
      case 0:
        return i2 < _2;
      case 1:
        return i2 <= _2;
      case 2:
        return i2 > _2;
      case 3:
        return i2 >= _2;
    }
    if (_JSBI.__isBigInt(i2) && "string" == typeof _2) return _2 = _JSBI.__fromString(_2), null !== _2 && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i2, _2), t2);
    if ("string" == typeof i2 && _JSBI.__isBigInt(_2)) return i2 = _JSBI.__fromString(i2), null !== i2 && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i2, _2), t2);
    if (i2 = _JSBI.__toNumeric(i2), _2 = _JSBI.__toNumeric(_2), _JSBI.__isBigInt(i2)) {
      if (_JSBI.__isBigInt(_2)) return _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i2, _2), t2);
      if ("number" != typeof _2) throw new Error("implementation bug");
      return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(i2, _2), t2);
    }
    if ("number" != typeof i2) throw new Error("implementation bug");
    if (_JSBI.__isBigInt(_2)) return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(_2, i2), 2 ^ t2);
    if ("number" != typeof _2) throw new Error("implementation bug");
    return 0 === t2 ? i2 < _2 : 1 === t2 ? i2 <= _2 : 2 === t2 ? i2 > _2 : 3 === t2 ? i2 >= _2 : void 0;
  }
  __clzmsd() {
    return _JSBI.__clz30(this.__digit(this.length - 1));
  }
  static __absoluteAdd(_2, t2, e) {
    if (_2.length < t2.length) return _JSBI.__absoluteAdd(t2, _2, e);
    if (0 === _2.length) return _2;
    if (0 === t2.length) return _2.sign === e ? _2 : _JSBI.unaryMinus(_2);
    let n2 = _2.length;
    (0 === _2.__clzmsd() || t2.length === _2.length && 0 === t2.__clzmsd()) && n2++;
    const g2 = new _JSBI(n2, e);
    let s2 = 0, o2 = 0;
    for (; o2 < t2.length; o2++) {
      const i2 = _2.__digit(o2) + t2.__digit(o2) + s2;
      s2 = i2 >>> 30, g2.__setDigit(o2, 1073741823 & i2);
    }
    for (; o2 < _2.length; o2++) {
      const i2 = _2.__digit(o2) + s2;
      s2 = i2 >>> 30, g2.__setDigit(o2, 1073741823 & i2);
    }
    return o2 < g2.length && g2.__setDigit(o2, s2), g2.__trim();
  }
  static __absoluteSub(_2, t2, e) {
    if (0 === _2.length) return _2;
    if (0 === t2.length) return _2.sign === e ? _2 : _JSBI.unaryMinus(_2);
    const n2 = new _JSBI(_2.length, e);
    let g2 = 0, s2 = 0;
    for (; s2 < t2.length; s2++) {
      const i2 = _2.__digit(s2) - t2.__digit(s2) - g2;
      g2 = 1 & i2 >>> 30, n2.__setDigit(s2, 1073741823 & i2);
    }
    for (; s2 < _2.length; s2++) {
      const i2 = _2.__digit(s2) - g2;
      g2 = 1 & i2 >>> 30, n2.__setDigit(s2, 1073741823 & i2);
    }
    return n2.__trim();
  }
  static __absoluteAddOne(_2, i2, t2 = null) {
    const e = _2.length;
    null === t2 ? t2 = new _JSBI(e, i2) : t2.sign = i2;
    let n2 = 1;
    for (let g2 = 0; g2 < e; g2++) {
      const i3 = _2.__digit(g2) + n2;
      n2 = i3 >>> 30, t2.__setDigit(g2, 1073741823 & i3);
    }
    return 0 != n2 && t2.__setDigitGrow(e, 1), t2;
  }
  static __absoluteSubOne(_2, t2) {
    const e = _2.length;
    t2 = t2 || e;
    const n2 = new _JSBI(t2, false);
    let g2 = 1;
    for (let s2 = 0; s2 < e; s2++) {
      const i2 = _2.__digit(s2) - g2;
      g2 = 1 & i2 >>> 30, n2.__setDigit(s2, 1073741823 & i2);
    }
    if (0 != g2) throw new Error("implementation bug");
    for (let g3 = e; g3 < t2; g3++) n2.__setDigit(g3, 0);
    return n2;
  }
  static __absoluteAnd(_2, t2, e = null) {
    let n2 = _2.length, g2 = t2.length, s2 = g2;
    if (n2 < g2) {
      s2 = n2;
      const i2 = _2, e2 = n2;
      _2 = t2, n2 = g2, t2 = i2, g2 = e2;
    }
    let o2 = s2;
    null === e ? e = new _JSBI(o2, false) : o2 = e.length;
    let l2 = 0;
    for (; l2 < s2; l2++) e.__setDigit(l2, _2.__digit(l2) & t2.__digit(l2));
    for (; l2 < o2; l2++) e.__setDigit(l2, 0);
    return e;
  }
  static __absoluteAndNot(_2, t2, e = null) {
    const n2 = _2.length, g2 = t2.length;
    let s2 = g2;
    n2 < g2 && (s2 = n2);
    let o2 = n2;
    null === e ? e = new _JSBI(o2, false) : o2 = e.length;
    let l2 = 0;
    for (; l2 < s2; l2++) e.__setDigit(l2, _2.__digit(l2) & ~t2.__digit(l2));
    for (; l2 < n2; l2++) e.__setDigit(l2, _2.__digit(l2));
    for (; l2 < o2; l2++) e.__setDigit(l2, 0);
    return e;
  }
  static __absoluteOr(_2, t2, e = null) {
    let n2 = _2.length, g2 = t2.length, s2 = g2;
    if (n2 < g2) {
      s2 = n2;
      const i2 = _2, e2 = n2;
      _2 = t2, n2 = g2, t2 = i2, g2 = e2;
    }
    let o2 = n2;
    null === e ? e = new _JSBI(o2, false) : o2 = e.length;
    let l2 = 0;
    for (; l2 < s2; l2++) e.__setDigit(l2, _2.__digit(l2) | t2.__digit(l2));
    for (; l2 < n2; l2++) e.__setDigit(l2, _2.__digit(l2));
    for (; l2 < o2; l2++) e.__setDigit(l2, 0);
    return e;
  }
  static __absoluteXor(_2, t2, e = null) {
    let n2 = _2.length, g2 = t2.length, s2 = g2;
    if (n2 < g2) {
      s2 = n2;
      const i2 = _2, e2 = n2;
      _2 = t2, n2 = g2, t2 = i2, g2 = e2;
    }
    let o2 = n2;
    null === e ? e = new _JSBI(o2, false) : o2 = e.length;
    let l2 = 0;
    for (; l2 < s2; l2++) e.__setDigit(l2, _2.__digit(l2) ^ t2.__digit(l2));
    for (; l2 < n2; l2++) e.__setDigit(l2, _2.__digit(l2));
    for (; l2 < o2; l2++) e.__setDigit(l2, 0);
    return e;
  }
  static __absoluteCompare(_2, t2) {
    const e = _2.length - t2.length;
    if (0 != e) return e;
    let n2 = _2.length - 1;
    for (; 0 <= n2 && _2.__digit(n2) === t2.__digit(n2); ) n2--;
    return 0 > n2 ? 0 : _2.__unsignedDigit(n2) > t2.__unsignedDigit(n2) ? 1 : -1;
  }
  static __multiplyAccumulate(_2, t2, e, n2) {
    if (0 === t2) return;
    const g2 = 32767 & t2, s2 = t2 >>> 15;
    let o2 = 0, l2 = 0;
    for (let r2, a2 = 0; a2 < _2.length; a2++, n2++) {
      r2 = e.__digit(n2);
      const i2 = _2.__digit(a2), t3 = 32767 & i2, u2 = i2 >>> 15, d2 = _JSBI.__imul(t3, g2), h2 = _JSBI.__imul(t3, s2), m2 = _JSBI.__imul(u2, g2), b2 = _JSBI.__imul(u2, s2);
      r2 += l2 + d2 + o2, o2 = r2 >>> 30, r2 &= 1073741823, r2 += ((32767 & h2) << 15) + ((32767 & m2) << 15), o2 += r2 >>> 30, l2 = b2 + (h2 >>> 15) + (m2 >>> 15), e.__setDigit(n2, 1073741823 & r2);
    }
    for (; 0 != o2 || 0 !== l2; n2++) {
      let i2 = e.__digit(n2);
      i2 += o2 + l2, l2 = 0, o2 = i2 >>> 30, e.__setDigit(n2, 1073741823 & i2);
    }
  }
  static __internalMultiplyAdd(_2, t2, e, g2, s2) {
    let o2 = e, l2 = 0;
    for (let n2 = 0; n2 < g2; n2++) {
      const i2 = _2.__digit(n2), e2 = _JSBI.__imul(32767 & i2, t2), g3 = _JSBI.__imul(i2 >>> 15, t2), a2 = e2 + ((32767 & g3) << 15) + l2 + o2;
      o2 = a2 >>> 30, l2 = g3 >>> 15, s2.__setDigit(n2, 1073741823 & a2);
    }
    if (s2.length > g2) for (s2.__setDigit(g2++, o2 + l2); g2 < s2.length; ) s2.__setDigit(g2++, 0);
    else if (0 !== o2 + l2) throw new Error("implementation bug");
  }
  __inplaceMultiplyAdd(i2, _2, t2) {
    t2 > this.length && (t2 = this.length);
    const e = 32767 & i2, n2 = i2 >>> 15;
    let g2 = 0, s2 = _2;
    for (let o2 = 0; o2 < t2; o2++) {
      const i3 = this.__digit(o2), _3 = 32767 & i3, t3 = i3 >>> 15, l2 = _JSBI.__imul(_3, e), r2 = _JSBI.__imul(_3, n2), a2 = _JSBI.__imul(t3, e), u2 = _JSBI.__imul(t3, n2);
      let d2 = s2 + l2 + g2;
      g2 = d2 >>> 30, d2 &= 1073741823, d2 += ((32767 & r2) << 15) + ((32767 & a2) << 15), g2 += d2 >>> 30, s2 = u2 + (r2 >>> 15) + (a2 >>> 15), this.__setDigit(o2, 1073741823 & d2);
    }
    if (0 != g2 || 0 !== s2) throw new Error("implementation bug");
  }
  static __absoluteDivSmall(_2, t2, e = null) {
    null === e && (e = new _JSBI(_2.length, false));
    let n2 = 0;
    for (let g2, s2 = 2 * _2.length - 1; 0 <= s2; s2 -= 2) {
      g2 = (n2 << 15 | _2.__halfDigit(s2)) >>> 0;
      const i2 = 0 | g2 / t2;
      n2 = 0 | g2 % t2, g2 = (n2 << 15 | _2.__halfDigit(s2 - 1)) >>> 0;
      const o2 = 0 | g2 / t2;
      n2 = 0 | g2 % t2, e.__setDigit(s2 >>> 1, i2 << 15 | o2);
    }
    return e;
  }
  static __absoluteModSmall(_2, t2) {
    let e = 0;
    for (let n2 = 2 * _2.length - 1; 0 <= n2; n2--) {
      const i2 = (e << 15 | _2.__halfDigit(n2)) >>> 0;
      e = 0 | i2 % t2;
    }
    return e;
  }
  static __absoluteDivLarge(i2, _2, t2, e) {
    const g2 = _2.__halfDigitLength(), n2 = _2.length, s2 = i2.__halfDigitLength() - g2;
    let o2 = null;
    t2 && (o2 = new _JSBI(s2 + 2 >>> 1, false), o2.__initializeDigits());
    const l2 = new _JSBI(g2 + 2 >>> 1, false);
    l2.__initializeDigits();
    const r2 = _JSBI.__clz15(_2.__halfDigit(g2 - 1));
    0 < r2 && (_2 = _JSBI.__specialLeftShift(_2, r2, 0));
    const a2 = _JSBI.__specialLeftShift(i2, r2, 1), u2 = _2.__halfDigit(g2 - 1);
    let d2 = 0;
    for (let r3, h2 = s2; 0 <= h2; h2--) {
      r3 = 32767;
      const i3 = a2.__halfDigit(h2 + g2);
      if (i3 !== u2) {
        const t3 = (i3 << 15 | a2.__halfDigit(h2 + g2 - 1)) >>> 0;
        r3 = 0 | t3 / u2;
        let e3 = 0 | t3 % u2;
        const n3 = _2.__halfDigit(g2 - 2), s3 = a2.__halfDigit(h2 + g2 - 2);
        for (; _JSBI.__imul(r3, n3) >>> 0 > (e3 << 16 | s3) >>> 0 && (r3--, e3 += u2, !(32767 < e3)); ) ;
      }
      _JSBI.__internalMultiplyAdd(_2, r3, 0, n2, l2);
      let e2 = a2.__inplaceSub(l2, h2, g2 + 1);
      0 !== e2 && (e2 = a2.__inplaceAdd(_2, h2, g2), a2.__setHalfDigit(h2 + g2, 32767 & a2.__halfDigit(h2 + g2) + e2), r3--), t2 && (1 & h2 ? d2 = r3 << 15 : o2.__setDigit(h2 >>> 1, d2 | r3));
    }
    if (e) return a2.__inplaceRightShift(r2), t2 ? { quotient: o2, remainder: a2 } : a2;
    if (t2) return o2;
    throw new Error("unreachable");
  }
  static __clz15(i2) {
    return _JSBI.__clz30(i2) - 15;
  }
  __inplaceAdd(_2, t2, e) {
    let n2 = 0;
    for (let g2 = 0; g2 < e; g2++) {
      const i2 = this.__halfDigit(t2 + g2) + _2.__halfDigit(g2) + n2;
      n2 = i2 >>> 15, this.__setHalfDigit(t2 + g2, 32767 & i2);
    }
    return n2;
  }
  __inplaceSub(_2, t2, e) {
    let n2 = 0;
    if (1 & t2) {
      t2 >>= 1;
      let g2 = this.__digit(t2), s2 = 32767 & g2, o2 = 0;
      for (; o2 < e - 1 >>> 1; o2++) {
        const i3 = _2.__digit(o2), e2 = (g2 >>> 15) - (32767 & i3) - n2;
        n2 = 1 & e2 >>> 15, this.__setDigit(t2 + o2, (32767 & e2) << 15 | 32767 & s2), g2 = this.__digit(t2 + o2 + 1), s2 = (32767 & g2) - (i3 >>> 15) - n2, n2 = 1 & s2 >>> 15;
      }
      const i2 = _2.__digit(o2), l2 = (g2 >>> 15) - (32767 & i2) - n2;
      n2 = 1 & l2 >>> 15, this.__setDigit(t2 + o2, (32767 & l2) << 15 | 32767 & s2);
      if (t2 + o2 + 1 >= this.length) throw new RangeError("out of bounds");
      0 == (1 & e) && (g2 = this.__digit(t2 + o2 + 1), s2 = (32767 & g2) - (i2 >>> 15) - n2, n2 = 1 & s2 >>> 15, this.__setDigit(t2 + _2.length, 1073709056 & g2 | 32767 & s2));
    } else {
      t2 >>= 1;
      let g2 = 0;
      for (; g2 < _2.length - 1; g2++) {
        const i3 = this.__digit(t2 + g2), e2 = _2.__digit(g2), s3 = (32767 & i3) - (32767 & e2) - n2;
        n2 = 1 & s3 >>> 15;
        const o3 = (i3 >>> 15) - (e2 >>> 15) - n2;
        n2 = 1 & o3 >>> 15, this.__setDigit(t2 + g2, (32767 & o3) << 15 | 32767 & s3);
      }
      const i2 = this.__digit(t2 + g2), s2 = _2.__digit(g2), o2 = (32767 & i2) - (32767 & s2) - n2;
      n2 = 1 & o2 >>> 15;
      let l2 = 0;
      0 == (1 & e) && (l2 = (i2 >>> 15) - (s2 >>> 15) - n2, n2 = 1 & l2 >>> 15), this.__setDigit(t2 + g2, (32767 & l2) << 15 | 32767 & o2);
    }
    return n2;
  }
  __inplaceRightShift(_2) {
    if (0 === _2) return;
    let t2 = this.__digit(0) >>> _2;
    const e = this.length - 1;
    for (let n2 = 0; n2 < e; n2++) {
      const i2 = this.__digit(n2 + 1);
      this.__setDigit(n2, 1073741823 & i2 << 30 - _2 | t2), t2 = i2 >>> _2;
    }
    this.__setDigit(e, t2);
  }
  static __specialLeftShift(_2, t2, e) {
    const g2 = _2.length, n2 = new _JSBI(g2 + e, false);
    if (0 === t2) {
      for (let t3 = 0; t3 < g2; t3++) n2.__setDigit(t3, _2.__digit(t3));
      return 0 < e && n2.__setDigit(g2, 0), n2;
    }
    let s2 = 0;
    for (let o2 = 0; o2 < g2; o2++) {
      const i2 = _2.__digit(o2);
      n2.__setDigit(o2, 1073741823 & i2 << t2 | s2), s2 = i2 >>> 30 - t2;
    }
    return 0 < e && n2.__setDigit(g2, s2), n2;
  }
  static __leftShiftByAbsolute(_2, i2) {
    const t2 = _JSBI.__toShiftAmount(i2);
    if (0 > t2) throw new RangeError("BigInt too big");
    const e = 0 | t2 / 30, n2 = t2 % 30, g2 = _2.length, s2 = 0 !== n2 && 0 != _2.__digit(g2 - 1) >>> 30 - n2, o2 = g2 + e + (s2 ? 1 : 0), l2 = new _JSBI(o2, _2.sign);
    if (0 === n2) {
      let t3 = 0;
      for (; t3 < e; t3++) l2.__setDigit(t3, 0);
      for (; t3 < o2; t3++) l2.__setDigit(t3, _2.__digit(t3 - e));
    } else {
      let t3 = 0;
      for (let _3 = 0; _3 < e; _3++) l2.__setDigit(_3, 0);
      for (let s3 = 0; s3 < g2; s3++) {
        const i3 = _2.__digit(s3);
        l2.__setDigit(s3 + e, 1073741823 & i3 << n2 | t3), t3 = i3 >>> 30 - n2;
      }
      if (s2) l2.__setDigit(g2 + e, t3);
      else if (0 !== t3) throw new Error("implementation bug");
    }
    return l2.__trim();
  }
  static __rightShiftByAbsolute(_2, i2) {
    const t2 = _2.length, e = _2.sign, n2 = _JSBI.__toShiftAmount(i2);
    if (0 > n2) return _JSBI.__rightShiftByMaximum(e);
    const g2 = 0 | n2 / 30, s2 = n2 % 30;
    let o2 = t2 - g2;
    if (0 >= o2) return _JSBI.__rightShiftByMaximum(e);
    let l2 = false;
    if (e) {
      if (0 != (_2.__digit(g2) & (1 << s2) - 1)) l2 = true;
      else for (let t3 = 0; t3 < g2; t3++) if (0 !== _2.__digit(t3)) {
        l2 = true;
        break;
      }
    }
    if (l2 && 0 === s2) {
      const i3 = _2.__digit(t2 - 1);
      0 == ~i3 && o2++;
    }
    let r2 = new _JSBI(o2, e);
    if (0 === s2) {
      r2.__setDigit(o2 - 1, 0);
      for (let e2 = g2; e2 < t2; e2++) r2.__setDigit(e2 - g2, _2.__digit(e2));
    } else {
      let e2 = _2.__digit(g2) >>> s2;
      const n3 = t2 - g2 - 1;
      for (let t3 = 0; t3 < n3; t3++) {
        const i3 = _2.__digit(t3 + g2 + 1);
        r2.__setDigit(t3, 1073741823 & i3 << 30 - s2 | e2), e2 = i3 >>> s2;
      }
      r2.__setDigit(n3, e2);
    }
    return l2 && (r2 = _JSBI.__absoluteAddOne(r2, true, r2)), r2.__trim();
  }
  static __rightShiftByMaximum(i2) {
    return i2 ? _JSBI.__oneDigit(1, true) : _JSBI.__zero();
  }
  static __toShiftAmount(i2) {
    if (1 < i2.length) return -1;
    const _2 = i2.__unsignedDigit(0);
    return _2 > _JSBI.__kMaxLengthBits ? -1 : _2;
  }
  static __toPrimitive(i2, _2 = "default") {
    if ("object" != typeof i2) return i2;
    if (i2.constructor === _JSBI) return i2;
    if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
      const t3 = i2[Symbol.toPrimitive];
      if (t3) {
        const i3 = t3(_2);
        if ("object" != typeof i3) return i3;
        throw new TypeError("Cannot convert object to primitive value");
      }
    }
    const t2 = i2.valueOf;
    if (t2) {
      const _3 = t2.call(i2);
      if ("object" != typeof _3) return _3;
    }
    const e = i2.toString;
    if (e) {
      const _3 = e.call(i2);
      if ("object" != typeof _3) return _3;
    }
    throw new TypeError("Cannot convert object to primitive value");
  }
  static __toNumeric(i2) {
    return _JSBI.__isBigInt(i2) ? i2 : +i2;
  }
  static __isBigInt(i2) {
    return "object" == typeof i2 && null !== i2 && i2.constructor === _JSBI;
  }
  static __truncateToNBits(i2, _2) {
    const t2 = 0 | (i2 + 29) / 30, e = new _JSBI(t2, _2.sign), n2 = t2 - 1;
    for (let t3 = 0; t3 < n2; t3++) e.__setDigit(t3, _2.__digit(t3));
    let g2 = _2.__digit(n2);
    if (0 != i2 % 30) {
      const _3 = 32 - i2 % 30;
      g2 = g2 << _3 >>> _3;
    }
    return e.__setDigit(n2, g2), e.__trim();
  }
  static __truncateAndSubFromPowerOfTwo(_2, t2, e) {
    var n2 = Math.min;
    const g2 = 0 | (_2 + 29) / 30, s2 = new _JSBI(g2, e);
    let o2 = 0;
    const l2 = g2 - 1;
    let a2 = 0;
    for (const i2 = n2(l2, t2.length); o2 < i2; o2++) {
      const i3 = 0 - t2.__digit(o2) - a2;
      a2 = 1 & i3 >>> 30, s2.__setDigit(o2, 1073741823 & i3);
    }
    for (; o2 < l2; o2++) s2.__setDigit(o2, 0 | 1073741823 & -a2);
    let u2 = l2 < t2.length ? t2.__digit(l2) : 0;
    const d2 = _2 % 30;
    let h2;
    if (0 == d2) h2 = 0 - u2 - a2, h2 &= 1073741823;
    else {
      const i2 = 32 - d2;
      u2 = u2 << i2 >>> i2;
      const _3 = 1 << 32 - i2;
      h2 = _3 - u2 - a2, h2 &= _3 - 1;
    }
    return s2.__setDigit(l2, h2), s2.__trim();
  }
  __digit(_2) {
    return this[_2];
  }
  __unsignedDigit(_2) {
    return this[_2] >>> 0;
  }
  __setDigit(_2, i2) {
    this[_2] = 0 | i2;
  }
  __setDigitGrow(_2, i2) {
    this[_2] = 0 | i2;
  }
  __halfDigitLength() {
    const i2 = this.length;
    return 32767 >= this.__unsignedDigit(i2 - 1) ? 2 * i2 - 1 : 2 * i2;
  }
  __halfDigit(_2) {
    return 32767 & this[_2 >>> 1] >>> 15 * (1 & _2);
  }
  __setHalfDigit(_2, i2) {
    const t2 = _2 >>> 1, e = this.__digit(t2), n2 = 1 & _2 ? 32767 & e | i2 << 15 : 1073709056 & e | 32767 & i2;
    this.__setDigit(t2, n2);
  }
  static __digitPow(i2, _2) {
    let t2 = 1;
    for (; 0 < _2; ) 1 & _2 && (t2 *= i2), _2 >>>= 1, i2 *= i2;
    return t2;
  }
  static __isOneDigitInt(i2) {
    return (1073741823 & i2) === i2;
  }
};
JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i2) {
  return Math.clz32(i2) - 2;
} : function(i2) {
  return 0 === i2 ? 30 : 0 | 29 - (0 | Math.log(i2 >>> 0) / Math.LN2);
}, JSBI.__imul = Math.imul || function(i2, _2) {
  return 0 | i2 * _2;
};
var jsbi_default = JSBI;

// node_modules/@js-temporal/polyfill/dist/index.esm.js
var t = {};
function MakeIntrinsicClass(e, t2) {
  Object.defineProperty(e.prototype, Symbol.toStringTag, { value: t2, writable: false, enumerable: false, configurable: true });
  for (const t3 of Object.getOwnPropertyNames(e)) {
    const r2 = Object.getOwnPropertyDescriptor(e, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e, t3, r2));
  }
  for (const t3 of Object.getOwnPropertyNames(e.prototype)) {
    const r2 = Object.getOwnPropertyDescriptor(e.prototype, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e.prototype, t3, r2));
  }
  DefineIntrinsic(t2, e), DefineIntrinsic(`${t2}.prototype`, e.prototype);
}
function DefineIntrinsic(e, r2) {
  const o2 = `%${e}%`;
  if (void 0 !== t[o2]) throw new Error(`intrinsic ${e} already exists`);
  t[o2] = r2;
}
function GetIntrinsic(e) {
  return t[e];
}
var r;
var o;
var n = "slot-epochNanoSeconds";
var a = "slot-timezone-identifier";
var i = "slot-year";
var s = "slot-month";
var l = "slot-day";
var d = "slot-hour";
var m = "slot-minute";
var c = "slot-second";
var h = "slot-millisecond";
var u = "slot-microsecond";
var T = "slot-nanosecond";
var p = "slot-calendar";
var f = "slot-date-brand";
var y = "slot-year-month-brand";
var I = "slot-month-day-brand";
var S = "slot-cached-instant";
var g = "slot-time-zone";
var w = "slot-years";
var D = "slot-months";
var G = "slot-weeks";
var v = "slot-days";
var C = "slot-hours";
var O = "slot-minutes";
var b = "slot-seconds";
var E = "slot-milliseconds";
var M = "slot-microseconds";
var R = "slot-nanoseconds";
var F = "slot-calendar-identifier";
var Y = /* @__PURE__ */ new WeakMap();
var P = Symbol.for("@@Temporal__GetSlots");
(r = globalThis)[P] || (r[P] = function _GetSlots(e) {
  return Y.get(e);
});
var Z = globalThis[P];
var B = Symbol.for("@@Temporal__CreateSlots");
(o = globalThis)[B] || (o[B] = function _CreateSlots(e) {
  Y.set(e, /* @__PURE__ */ Object.create(null));
});
var N = globalThis[B];
function HasSlot(e, ...t2) {
  if (!e || "object" != typeof e) return false;
  const r2 = Z(e);
  return !!r2 && t2.every((e2) => e2 in r2);
}
function GetSlot(e, t2) {
  var _a;
  const r2 = (_a = Z(e)) == null ? void 0 : _a[t2];
  if (void 0 === r2) throw new TypeError(`Missing internal slot ${t2}`);
  return r2;
}
function SetSlot(e, t2, r2) {
  const o2 = Z(e);
  if (void 0 === o2) throw new TypeError("Missing slots for the given container");
  if (o2[t2]) throw new TypeError(`${t2} already has set`);
  o2[t2] = r2;
}
var j = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
var $ = new RegExp("(?:" + [`(?:${j.source})(?:\\/(?:${j.source}))*`, "Etc/GMT(?:0|[-+]\\d{1,2})", "GMT[-+]?0", "EST5EDT", "CST6CDT", "MST7MDT", "PST8PDT", /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join("|") + ")");
var k = /(?:[+\u2212-]\d{6}|\d{4})/;
var U = /(?:0[1-9]|1[0-2])/;
var A = /(?:0[1-9]|[12]\d|3[01])/;
var L = new RegExp(`(${k.source})(?:-(${U.source})-(${A.source})|(${U.source})(${A.source}))`);
var x = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
var W = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
var q = new RegExp(`([zZ])|${W.source}?`);
var H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g;
var V = new RegExp([`^${L.source}`, `(?:(?:T|\\s+)${x.source}(?:${q.source})?)?`, `(?:\\[!?(${$.source})\\])?`, `((?:${H.source})*)$`].join(""), "i");
var z = new RegExp([`^T?${x.source}`, `(?:${q.source})?`, `(?:\\[!?${$.source}\\])?`, `((?:${H.source})*)$`].join(""), "i");
var _ = new RegExp(`^(${k.source})-?(${U.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var J = new RegExp(`^(?:--)?(${U.source})-?(${A.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var K = /(\d+)(?:[.,](\d{1,9}))?/;
var X = new RegExp(`(?:${K.source}H)?(?:${K.source}M)?(?:${K.source}S)?`);
var Q = new RegExp(`^([+−-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${X.source})?$`, "i");
var ee = Array.prototype.includes;
var te = Array.prototype.push;
var re = globalThis.Intl.DateTimeFormat;
var oe = Math.min;
var ne = Math.max;
var ae = Math.abs;
var ie = Math.floor;
var se = Math.sign;
var le = Math.trunc;
var de = Number.isNaN;
var me = Number.isFinite;
var ce = Number;
var he = String;
var ue = Number.MAX_SAFE_INTEGER;
var Te = Object.create;
var pe = Object.getOwnPropertyDescriptor;
var fe = Reflect.apply;
var ye = Reflect.ownKeys;
var Ie = jsbi_default.BigInt(0);
var Se = jsbi_default.BigInt(1);
var ge = jsbi_default.BigInt(60);
var we = jsbi_default.BigInt(24);
var De = jsbi_default.BigInt(1e3);
var Ge = jsbi_default.BigInt(1e6);
var ve = jsbi_default.BigInt(1e9);
var Ce = jsbi_default.BigInt(-1);
var Oe = jsbi_default.multiply(jsbi_default.BigInt(3600), ve);
var be = jsbi_default.multiply(ge, ve);
var Ee = jsbi_default.multiply(Oe, we);
var Me = jsbi_default.multiply(jsbi_default.BigInt(-86400), jsbi_default.BigInt(1e17));
var Re = jsbi_default.multiply(jsbi_default.BigInt(86400), jsbi_default.BigInt(1e17));
var Fe = -271821;
var Ye = 275760;
var Pe = jsbi_default.multiply(jsbi_default.BigInt(-388152), jsbi_default.BigInt(1e13));
var Ze = jsbi_default.multiply(Ee, jsbi_default.BigInt(3660));
var Be = jsbi_default.multiply(Ee, jsbi_default.BigInt(366));
var Ne = jsbi_default.multiply(Ee, jsbi_default.BigInt(14));
var je = ["iso8601", "hebrew", "islamic", "islamic-umalqura", "islamic-tbla", "islamic-civil", "islamic-rgsa", "islamicc", "persian", "ethiopic", "ethioaa", "coptic", "chinese", "dangi", "roc", "indian", "buddhist", "japanese", "gregory"];
function isZero(t2) {
  return jsbi_default.equal(t2, Ie);
}
function GetMethod(e, t2) {
  const r2 = e[t2];
  if (void 0 !== r2) return r2;
}
function Call(e, t2, r2) {
  const o2 = arguments.length > 2 ? r2 : [];
  return fe(e, t2, o2);
}
function IsObject(e) {
  return "object" == typeof e && null !== e || "function" == typeof e;
}
function ToNumber(e) {
  if ("bigint" == typeof e) throw new TypeError("Cannot convert BigInt to number");
  return ce(e);
}
function ToIntegerOrInfinity(e) {
  const t2 = ToNumber(e);
  if (de(t2) || 0 === t2) return 0;
  if (!me(t2)) return t2;
  const r2 = ie(ae(t2));
  return 0 === r2 ? 0 : se(t2) * r2;
}
function IsIntegralNumber(e) {
  if ("number" != typeof e || de(e) || !me(e)) return false;
  const t2 = ae(e);
  return ie(t2) === t2;
}
function ToString(e) {
  if ("symbol" == typeof e) throw new TypeError("Cannot convert a Symbol value to a String");
  return he(e);
}
function ToIntegerWithTruncation(e) {
  const t2 = ToNumber(e);
  if (0 === t2) return 0;
  if (de(t2) || !me(t2)) throw new RangeError("invalid number value");
  const r2 = le(t2);
  return 0 === r2 ? 0 : r2;
}
function ToPositiveIntegerWithTruncation(e, t2) {
  const r2 = ToIntegerWithTruncation(e);
  if (r2 <= 0) {
    if (void 0 !== t2) throw new RangeError(`property '${t2}' cannot be a a number less than one`);
    throw new RangeError("Cannot convert a number less than one to a positive integer");
  }
  return r2;
}
function ToIntegerIfIntegral(e) {
  const t2 = ToNumber(e);
  if (!me(t2)) throw new RangeError("infinity is out of range");
  if (!IsIntegralNumber(t2)) throw new RangeError(`unsupported fractional value ${e}`);
  return 0 === t2 ? 0 : t2;
}
function divmod(t2, r2) {
  return { quotient: jsbi_default.divide(t2, r2), remainder: jsbi_default.remainder(t2, r2) };
}
function isNegativeJSBI(t2) {
  return jsbi_default.lessThan(t2, Ie);
}
function signJSBI(e) {
  return isZero(e) ? 0 : isNegativeJSBI(e) ? -1 : 1;
}
function abs(t2) {
  return jsbi_default.lessThan(t2, Ie) ? jsbi_default.multiply(t2, Ce) : t2;
}
var $e = /* @__PURE__ */ new Map([["year", ToIntegerWithTruncation], ["month", ToPositiveIntegerWithTruncation], ["monthCode", ToString], ["day", ToPositiveIntegerWithTruncation], ["hour", ToIntegerWithTruncation], ["minute", ToIntegerWithTruncation], ["second", ToIntegerWithTruncation], ["millisecond", ToIntegerWithTruncation], ["microsecond", ToIntegerWithTruncation], ["nanosecond", ToIntegerWithTruncation], ["years", ToIntegerIfIntegral], ["months", ToIntegerIfIntegral], ["weeks", ToIntegerIfIntegral], ["days", ToIntegerIfIntegral], ["hours", ToIntegerIfIntegral], ["minutes", ToIntegerIfIntegral], ["seconds", ToIntegerIfIntegral], ["milliseconds", ToIntegerIfIntegral], ["microseconds", ToIntegerIfIntegral], ["nanoseconds", ToIntegerIfIntegral], ["era", ToString], ["eraYear", ToIntegerOrInfinity], ["offset", ToString]]);
var ke = /* @__PURE__ */ new Map([["hour", 0], ["minute", 0], ["second", 0], ["millisecond", 0], ["microsecond", 0], ["nanosecond", 0]]);
var Ue = [["years", "year", "date"], ["months", "month", "date"], ["weeks", "week", "date"], ["days", "day", "date"], ["hours", "hour", "time"], ["minutes", "minute", "time"], ["seconds", "second", "time"], ["milliseconds", "millisecond", "time"], ["microseconds", "microsecond", "time"], ["nanoseconds", "nanosecond", "time"]];
var Ae = new Map(Ue.map((e) => [e[0], e[1]]));
var Le = new Map(Ue.map(([e, t2]) => [t2, e]));
var xe = Ue.map(([, e]) => e);
var We = Array.from(Ae.keys()).sort();
var qe = /* @__PURE__ */ new Map();
function getIntlDateTimeFormatEnUsForTimeZone(e) {
  let t2 = qe.get(e);
  return void 0 === t2 && (t2 = new re("en-us", { timeZone: he(e), hour12: false, era: "short", year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), qe.set(e, t2)), t2;
}
function ToObject(e) {
  if (null == e) throw new TypeError(`Expected object not ${e}`);
  return Object(e);
}
function CopyDataProperties(e, t2, r2, o2) {
  if (null == t2) return;
  const n2 = ye(t2);
  for (const a2 of n2) if (!r2.some((e2) => Object.is(e2, a2)) && Object.prototype.propertyIsEnumerable.call(t2, a2)) {
    const r3 = t2[a2];
    if (o2 && o2.some((e2) => Object.is(e2, r3))) continue;
    e[a2] = r3;
  }
}
function IsTemporalInstant(e) {
  return HasSlot(e, n) && !HasSlot(e, g, p);
}
function IsTemporalTimeZone(e) {
  return HasSlot(e, a);
}
function IsTemporalCalendar(e) {
  return HasSlot(e, F);
}
function IsTemporalDuration(e) {
  return HasSlot(e, w, D, v, C, O, b, E, M, R);
}
function IsTemporalDate(e) {
  return HasSlot(e, f);
}
function IsTemporalTime(e) {
  return HasSlot(e, d, m, c, h, u, T) && !HasSlot(e, i, s, l);
}
function IsTemporalDateTime(e) {
  return HasSlot(e, i, s, l, d, m, c, h, u, T);
}
function IsTemporalYearMonth(e) {
  return HasSlot(e, y);
}
function IsTemporalMonthDay(e) {
  return HasSlot(e, I);
}
function IsTemporalZonedDateTime(e) {
  return HasSlot(e, n, g, p);
}
function RejectTemporalLikeObject(e) {
  if (HasSlot(e, p) || HasSlot(e, g)) throw new TypeError("with() does not support a calendar or timeZone property");
  if (IsTemporalTime(e)) throw new TypeError("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
  if (void 0 !== e.calendar) throw new TypeError("with() does not support a calendar property");
  if (void 0 !== e.timeZone) throw new TypeError("with() does not support a timeZone property");
}
function ParseTemporalTimeZone(e) {
  const { ianaName: t2, offset: r2, z: o2 } = function ParseTemporalTimeZoneString(e2) {
    if (new RegExp(`^${$.source}$`, "i").test(e2)) return { ianaName: e2 };
    try {
      const t3 = ParseISODateTime(e2);
      if (t3.z || t3.offset || t3.ianaName) return t3;
    } catch {
    }
    throw new RangeError(`Invalid time zone: ${e2}`);
  }(e);
  if (t2) return GetCanonicalTimeZoneIdentifier(t2);
  if (o2) return "UTC";
  return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r2));
}
function MaybeFormatCalendarAnnotation(e, t2) {
  return "never" === t2 ? "" : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e), t2);
}
function FormatCalendarAnnotation(e, t2) {
  if ("never" === t2) return "";
  if ("auto" === t2 && "iso8601" === e) return "";
  return `[${"critical" === t2 ? "!" : ""}u-ca=${e}]`;
}
function ParseISODateTime(e) {
  const t2 = V.exec(e);
  if (!t2) throw new RangeError(`invalid ISO 8601 string: ${e}`);
  let r2 = t2[1];
  if ("−" === r2[0] && (r2 = `-${r2.slice(1)}`), "-000000" === r2) throw new RangeError(`invalid ISO 8601 string: ${e}`);
  const o2 = ToIntegerOrInfinity(r2), n2 = ToIntegerOrInfinity(t2[2] || t2[4]), a2 = ToIntegerOrInfinity(t2[3] || t2[5]), i2 = ToIntegerOrInfinity(t2[6]), s2 = void 0 !== t2[6], l2 = ToIntegerOrInfinity(t2[7] || t2[10]);
  let d2 = ToIntegerOrInfinity(t2[8] || t2[11]);
  60 === d2 && (d2 = 59);
  const m2 = (t2[9] || t2[12]) + "000000000", c2 = ToIntegerOrInfinity(m2.slice(0, 3)), h2 = ToIntegerOrInfinity(m2.slice(3, 6)), u2 = ToIntegerOrInfinity(m2.slice(6, 9));
  let T2, p2 = false;
  if (t2[13]) T2 = void 0, p2 = true;
  else if (t2[14] && t2[15]) {
    const e2 = "-" === t2[14] || "−" === t2[14] ? "-" : "+", r3 = t2[15] || "00", o3 = t2[16] || "00", n3 = t2[17] || "00";
    let a3 = t2[18] || "0";
    if (T2 = `${e2}${r3}:${o3}`, +a3) {
      for (; a3.endsWith("0"); ) a3 = a3.slice(0, -1);
      T2 += `:${n3}.${a3}`;
    } else +n3 && (T2 += `:${n3}`);
    "-00:00" === T2 && (T2 = "+00:00");
  }
  const f2 = t2[19], y2 = t2[20];
  let I2;
  for (const [, e2, t3, r3] of y2.matchAll(H)) if ("u-ca" === t3) void 0 === I2 && (I2 = r3);
  else if ("!" === e2) throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
  return RejectDateTime(o2, n2, a2, i2, l2, d2, c2, h2, u2), { year: o2, month: n2, day: a2, hasTime: s2, hour: i2, minute: l2, second: d2, millisecond: c2, microsecond: h2, nanosecond: u2, ianaName: f2, offset: T2, z: p2, calendar: I2 };
}
function ParseTemporalYearMonthString(e) {
  const t2 = _.exec(e);
  let r2, o2, n2, a2;
  if (t2) {
    let a3 = t2[1];
    if ("−" === a3[0] && (a3 = `-${a3.slice(1)}`), "-000000" === a3) throw new RangeError(`invalid ISO 8601 string: ${e}`);
    r2 = ToIntegerOrInfinity(a3), o2 = ToIntegerOrInfinity(t2[2]);
    const i2 = t2[3];
    for (const [, e2, t3, r3] of i2.matchAll(H)) if ("u-ca" === t3) void 0 === n2 && (n2 = r3);
    else if ("!" === e2) throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
    if (void 0 !== n2 && "iso8601" !== n2) throw new RangeError("YYYY-MM format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ year: r2, month: o2, calendar: n2, day: a2, z: t3 } = ParseISODateTime(e), t3) throw new RangeError("Z designator not supported for PlainYearMonth");
  }
  return { year: r2, month: o2, calendar: n2, referenceISODay: a2 };
}
function ParseTemporalMonthDayString(e) {
  const t2 = J.exec(e);
  let r2, o2, n2, a2;
  if (t2) {
    r2 = ToIntegerOrInfinity(t2[1]), o2 = ToIntegerOrInfinity(t2[2]);
    const e2 = t2[3];
    for (const [, t3, r3, o3] of e2.matchAll(H)) if ("u-ca" === r3) void 0 === n2 && (n2 = o3);
    else if ("!" === t3) throw new RangeError(`Unrecognized annotation: !${r3}=${o3}`);
    if (void 0 !== n2 && "iso8601" !== n2) throw new RangeError("MM-DD format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ month: r2, day: o2, calendar: n2, year: a2, z: t3 } = ParseISODateTime(e), t3) throw new RangeError("Z designator not supported for PlainMonthDay");
  }
  return { month: r2, day: o2, calendar: n2, referenceISOYear: a2 };
}
function ParseTemporalInstant(e) {
  let { year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2, offset: m2, z: c2 } = function ParseTemporalInstantString(e2) {
    const t3 = ParseISODateTime(e2);
    if (!t3.z && !t3.offset) throw new RangeError("Temporal.Instant requires a time zone offset");
    return t3;
  }(e);
  if (!c2 && !m2) throw new RangeError("Temporal.Instant requires a time zone offset");
  const h2 = c2 ? 0 : ParseTimeZoneOffsetString(m2);
  ({ year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2 } = BalanceISODateTime(t2, r2, o2, n2, a2, i2, s2, l2, d2 - h2));
  const u2 = GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2);
  if (null === u2) throw new RangeError("DateTime outside of supported range");
  return u2;
}
function RegulateISODate(e, t2, r2, o2) {
  let n2 = e, a2 = t2, i2 = r2;
  switch (o2) {
    case "reject":
      RejectISODate(n2, a2, i2);
      break;
    case "constrain":
      ({ year: n2, month: a2, day: i2 } = ConstrainISODate(n2, a2, i2));
  }
  return { year: n2, month: a2, day: i2 };
}
function RegulateTime(e, t2, r2, o2, n2, a2, i2) {
  let s2 = e, l2 = t2, d2 = r2, m2 = o2, c2 = n2, h2 = a2;
  switch (i2) {
    case "reject":
      RejectTime(s2, l2, d2, m2, c2, h2);
      break;
    case "constrain":
      ({ hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 } = function ConstrainTime(e2, t3, r3, o3, n3, a3) {
        const i3 = ConstrainToRange(e2, 0, 23), s3 = ConstrainToRange(t3, 0, 59), l3 = ConstrainToRange(r3, 0, 59), d3 = ConstrainToRange(o3, 0, 999), m3 = ConstrainToRange(n3, 0, 999), c3 = ConstrainToRange(a3, 0, 999);
        return { hour: i3, minute: s3, second: l3, millisecond: d3, microsecond: m3, nanosecond: c3 };
      }(s2, l2, d2, m2, c2, h2));
  }
  return { hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 };
}
function ToTemporalDurationRecord(e) {
  if (!IsObject(e)) return function ParseTemporalDurationString(e2) {
    const t3 = Q.exec(e2);
    if (!t3) throw new RangeError(`invalid duration: ${e2}`);
    if (t3.slice(2).every((e3) => void 0 === e3)) throw new RangeError(`invalid duration: ${e2}`);
    const r3 = "-" === t3[1] || "−" === t3[1] ? -1 : 1, o3 = void 0 === t3[2] ? 0 : ToIntegerWithTruncation(t3[2]) * r3, n3 = void 0 === t3[3] ? 0 : ToIntegerWithTruncation(t3[3]) * r3, a3 = void 0 === t3[4] ? 0 : ToIntegerWithTruncation(t3[4]) * r3, i3 = void 0 === t3[5] ? 0 : ToIntegerWithTruncation(t3[5]) * r3, s3 = void 0 === t3[6] ? 0 : ToIntegerWithTruncation(t3[6]) * r3, l3 = t3[7], d3 = t3[8], m3 = t3[9], c3 = t3[10], h3 = t3[11];
    let u2 = 0, T2 = 0, p2 = 0;
    if (void 0 !== l3) {
      if (d3 ?? m3 ?? c3 ?? h3) throw new RangeError("only the smallest unit can be fractional");
      p2 = 3600 * ToIntegerOrInfinity((l3 + "000000000").slice(0, 9)) * r3;
    } else if (u2 = void 0 === d3 ? 0 : ToIntegerWithTruncation(d3) * r3, void 0 !== m3) {
      if (c3 ?? h3) throw new RangeError("only the smallest unit can be fractional");
      p2 = 60 * ToIntegerOrInfinity((m3 + "000000000").slice(0, 9)) * r3;
    } else T2 = void 0 === c3 ? 0 : ToIntegerWithTruncation(c3) * r3, void 0 !== h3 && (p2 = ToIntegerOrInfinity((h3 + "000000000").slice(0, 9)) * r3);
    const f2 = p2 % 1e3, y2 = le(p2 / 1e3) % 1e3, I2 = le(p2 / 1e6) % 1e3;
    return T2 += le(p2 / 1e9) % 60, u2 += le(p2 / 6e10), RejectDuration(o3, n3, a3, i3, s3, u2, T2, I2, y2, f2), { years: o3, months: n3, weeks: a3, days: i3, hours: s3, minutes: u2, seconds: T2, milliseconds: I2, microseconds: y2, nanoseconds: f2 };
  }(ToString(e));
  if (IsTemporalDuration(e)) return { years: GetSlot(e, w), months: GetSlot(e, D), weeks: GetSlot(e, G), days: GetSlot(e, v), hours: GetSlot(e, C), minutes: GetSlot(e, O), seconds: GetSlot(e, b), milliseconds: GetSlot(e, E), microseconds: GetSlot(e, M), nanoseconds: GetSlot(e, R) };
  const t2 = { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  let r2 = function ToTemporalPartialDurationRecord(e2) {
    if (!IsObject(e2)) throw new TypeError("invalid duration-like");
    const t3 = { years: void 0, months: void 0, weeks: void 0, days: void 0, hours: void 0, minutes: void 0, seconds: void 0, milliseconds: void 0, microseconds: void 0, nanoseconds: void 0 };
    let r3 = false;
    for (const o3 of We) {
      const n3 = e2[o3];
      void 0 !== n3 && (r3 = true, t3[o3] = ToIntegerIfIntegral(n3));
    }
    if (!r3) throw new TypeError("invalid duration-like");
    return t3;
  }(e);
  for (const e2 of We) {
    const o3 = r2[e2];
    void 0 !== o3 && (t2[e2] = o3);
  }
  let { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 } = t2;
  return RejectDuration(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 };
}
function ToTemporalOverflow(e) {
  return void 0 === e ? "constrain" : GetOption(e, "overflow", ["constrain", "reject"], "constrain");
}
function ToTemporalDisambiguation(e) {
  return void 0 === e ? "compatible" : GetOption(e, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
}
function ToTemporalRoundingMode(e, t2) {
  return GetOption(e, "roundingMode", ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"], t2);
}
function ToTemporalOffset(e, t2) {
  return void 0 === e ? t2 : GetOption(e, "offset", ["prefer", "use", "ignore", "reject"], t2);
}
function ToCalendarNameOption(e) {
  return GetOption(e, "calendarName", ["auto", "always", "never", "critical"], "auto");
}
function ToTemporalRoundingIncrement(e) {
  let t2 = e.roundingIncrement;
  if (void 0 === t2) return 1;
  if (t2 = ToNumber(t2), !me(t2)) throw new RangeError("roundingIncrement must be finite");
  const r2 = le(t2);
  if (r2 < 1 || r2 > 1e9) throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${t2}`);
  return r2;
}
function ValidateTemporalRoundingIncrement(e, t2, r2) {
  const o2 = r2 ? t2 : t2 - 1;
  if (e > o2) throw new RangeError(`roundingIncrement must be at least 1 and less than ${o2}, not ${e}`);
  if (t2 % e != 0) throw new RangeError(`Rounding increment must divide evenly into ${t2}`);
}
function ToFractionalSecondDigits(e) {
  const t2 = e.fractionalSecondDigits;
  if (void 0 === t2) return "auto";
  if ("number" != typeof t2) {
    if ("auto" !== ToString(t2)) throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
    return "auto";
  }
  const r2 = ie(t2);
  if (!me(r2) || r2 < 0 || r2 > 9) throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  return r2;
}
function ToSecondsStringPrecisionRecord(e, t2) {
  switch (e) {
    case "minute":
      return { precision: "minute", unit: "minute", increment: 1 };
    case "second":
      return { precision: 0, unit: "second", increment: 1 };
    case "millisecond":
      return { precision: 3, unit: "millisecond", increment: 1 };
    case "microsecond":
      return { precision: 6, unit: "microsecond", increment: 1 };
    case "nanosecond":
      return { precision: 9, unit: "nanosecond", increment: 1 };
  }
  switch (t2) {
    case "auto":
      return { precision: t2, unit: "nanosecond", increment: 1 };
    case 0:
      return { precision: t2, unit: "second", increment: 1 };
    case 1:
    case 2:
    case 3:
      return { precision: t2, unit: "millisecond", increment: 10 ** (3 - t2) };
    case 4:
    case 5:
    case 6:
      return { precision: t2, unit: "microsecond", increment: 10 ** (6 - t2) };
    case 7:
    case 8:
    case 9:
      return { precision: t2, unit: "nanosecond", increment: 10 ** (9 - t2) };
    default:
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  }
}
var He = Symbol("~required~");
function GetTemporalUnit(e, t2, r2, o2, n2 = []) {
  const a2 = [];
  for (const [, e2, t3] of Ue) "datetime" !== r2 && r2 !== t3 || a2.push(e2);
  a2.push(...n2);
  let i2 = o2;
  i2 === He ? i2 = void 0 : void 0 !== i2 && a2.push(i2);
  const s2 = [...a2];
  for (const e2 of a2) {
    const t3 = Le.get(e2);
    void 0 !== t3 && s2.push(t3);
  }
  let l2 = GetOption(e, t2, s2, i2);
  if (void 0 === l2 && o2 === He) throw new RangeError(`${t2} is required`);
  return Ae.has(l2) ? Ae.get(l2) : l2;
}
function ToRelativeTemporalObject(e) {
  const t2 = e.relativeTo;
  if (void 0 === t2) return t2;
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = "option", p2 = false;
  if (IsObject(t2)) {
    if (IsTemporalZonedDateTime(t2) || IsTemporalDate(t2)) return t2;
    if (IsTemporalDateTime(t2)) return TemporalDateTimeToDate(t2);
    c2 = GetTemporalCalendarSlotValueWithISODefault(t2);
    const e2 = CalendarFields(c2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    e2.push("timeZone", "offset");
    const p3 = PrepareTemporalFields(t2, e2, []), f2 = Te(null);
    f2.overflow = "constrain", { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(c2, p3, f2), u2 = p3.offset, void 0 === u2 && (T2 = "wall"), h2 = p3.timeZone, void 0 !== h2 && (h2 = ToTemporalTimeZoneSlotValue(h2));
  } else {
    let e2, f2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, calendar: c2, ianaName: e2, offset: u2, z: f2 } = ParseISODateTime(ToString(t2)), e2) h2 = ToTemporalTimeZoneSlotValue(e2), f2 ? T2 = "exact" : u2 || (T2 = "wall"), p2 = true;
    else if (f2) throw new RangeError("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
    if (c2 || (c2 = "iso8601"), !IsBuiltinCalendar(c2)) throw new RangeError(`invalid calendar identifier ${c2}`);
    c2 = ASCIILowercase(c2);
  }
  if (void 0 === h2) return CreateTemporalDate(r2, o2, n2, c2);
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, T2, "option" === T2 ? ParseTimeZoneOffsetString(u2) : 0, h2, "compatible", "reject", p2), h2, c2);
}
function DefaultTemporalLargestUnit(e, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const [m2, c2] of [["years", e], ["months", t2], ["weeks", r2], ["days", o2], ["hours", n2], ["minutes", a2], ["seconds", i2], ["milliseconds", s2], ["microseconds", l2], ["nanoseconds", d2]]) if (0 !== c2) return Ae.get(m2);
  return "nanosecond";
}
function LargerOfTwoTemporalUnits(e, t2) {
  return xe.indexOf(e) > xe.indexOf(t2) ? t2 : e;
}
function PrepareTemporalFields(e, t2, r2, { emptySourceErrorMessage: o2 } = { emptySourceErrorMessage: "no supported properties found" }) {
  const n2 = Te(null);
  let a2 = false;
  t2.sort();
  for (const o3 of t2) {
    let t3 = e[o3];
    if (void 0 !== t3) a2 = true, $e.has(o3) && (t3 = $e.get(o3)(t3)), n2[o3] = t3;
    else if ("partial" !== r2) {
      if (ee.call(r2, o3)) throw new TypeError(`required property '${o3}' missing or undefined`);
      t3 = ke.get(o3), n2[o3] = t3;
    }
  }
  if ("partial" === r2 && !a2) throw new TypeError(o2);
  return n2;
}
function ToTemporalTimeRecord(e, t2 = "complete") {
  const r2 = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"], o2 = PrepareTemporalFields(e, r2, "partial", { emptySourceErrorMessage: "invalid time-like" }), n2 = {};
  for (const e2 of r2) {
    const r3 = pe(o2, e2);
    void 0 !== r3 ? n2[e2] = r3.value : "complete" === t2 && (n2[e2] = 0);
  }
  return n2;
}
function ToTemporalDate(e, t2) {
  let r2 = e;
  if (IsObject(r2)) {
    if (IsTemporalDate(r2)) return r2;
    if (IsTemporalZonedDateTime(r2) && (ToTemporalOverflow(t2), r2 = GetPlainDateTimeFor(GetSlot(r2, g), GetSlot(r2, S), GetSlot(r2, p))), IsTemporalDateTime(r2)) return ToTemporalOverflow(t2), CreateTemporalDate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, p));
    const e2 = GetTemporalCalendarSlotValueWithISODefault(r2);
    return CalendarDateFromFields(e2, PrepareTemporalFields(r2, CalendarFields(e2, ["day", "month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: o2, month: n2, day: a2, calendar: d2, z: m2 } = function ParseTemporalDateString(e2) {
    return ParseISODateTime(e2);
  }(ToString(r2));
  if (m2) throw new RangeError("Z designator not supported for PlainDate");
  if (d2 || (d2 = "iso8601"), !IsBuiltinCalendar(d2)) throw new RangeError(`invalid calendar identifier ${d2}`);
  return d2 = ASCIILowercase(d2), CreateTemporalDate(o2, n2, a2, d2);
}
function InterpretTemporalDateTimeFields(e, t2, r2) {
  let { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = ToTemporalTimeRecord(t2);
  const h2 = ToTemporalOverflow(r2), u2 = CalendarDateFromFields(e, t2, r2), T2 = GetSlot(u2, i), p2 = GetSlot(u2, s), f2 = GetSlot(u2, l);
  return { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = RegulateTime(o2, n2, a2, d2, m2, c2, h2), { year: T2, month: p2, day: f2, hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 };
}
function ToTemporalDateTime(e, t2) {
  let r2, o2, n2, a2, d2, m2, c2, h2, u2, T2;
  if (IsObject(e)) {
    if (IsTemporalDateTime(e)) return e;
    if (IsTemporalZonedDateTime(e)) return ToTemporalOverflow(t2), GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
    if (IsTemporalDate(e)) return ToTemporalOverflow(t2), CreateTemporalDateTime(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), 0, 0, 0, 0, 0, 0, GetSlot(e, p));
    T2 = GetTemporalCalendarSlotValueWithISODefault(e);
    const f2 = PrepareTemporalFields(e, CalendarFields(T2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []);
    ({ year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2 } = InterpretTemporalDateTimeFields(T2, f2, t2));
  } else {
    let i2;
    if (ToTemporalOverflow(t2), { year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2, calendar: T2, z: i2 } = function ParseTemporalDateTimeString(e2) {
      return ParseISODateTime(e2);
    }(ToString(e)), i2) throw new RangeError("Z designator not supported for PlainDateTime");
    if (RejectDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2), T2 || (T2 = "iso8601"), !IsBuiltinCalendar(T2)) throw new RangeError(`invalid calendar identifier ${T2}`);
    T2 = ASCIILowercase(T2);
  }
  return CreateTemporalDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2, T2);
}
function ToTemporalDuration(e) {
  if (IsTemporalDuration(e)) return e;
  let { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = ToTemporalDurationRecord(e);
  return new (GetIntrinsic("%Temporal.Duration%"))(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
}
function ToTemporalInstant(e) {
  if (IsTemporalInstant(e)) return e;
  if (IsTemporalZonedDateTime(e)) {
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
  }
  const t2 = ParseTemporalInstant(ToString(e));
  return new (GetIntrinsic("%Temporal.Instant%"))(t2);
}
function ToTemporalMonthDay(e, t2) {
  let r2 = e;
  if (IsObject(r2)) {
    if (IsTemporalMonthDay(r2)) return r2;
    let e2, o3;
    if (HasSlot(r2, p)) e2 = GetSlot(r2, p), o3 = false;
    else {
      let t3 = r2.calendar;
      o3 = void 0 === t3, void 0 === t3 && (t3 = "iso8601"), e2 = ToTemporalCalendarSlotValue(t3);
    }
    const n3 = PrepareTemporalFields(r2, CalendarFields(e2, ["day", "month", "monthCode", "year"]), []);
    return o3 && void 0 !== n3.month && void 0 === n3.monthCode && void 0 === n3.year && (n3.year = 1972), CalendarMonthDayFromFields(e2, n3, t2);
  }
  ToTemporalOverflow(t2);
  let { month: o2, day: n2, referenceISOYear: a2, calendar: i2 } = ParseTemporalMonthDayString(ToString(r2));
  if (void 0 === i2 && (i2 = "iso8601"), !IsBuiltinCalendar(i2)) throw new RangeError(`invalid calendar identifier ${i2}`);
  if (i2 = ASCIILowercase(i2), void 0 === a2) return RejectISODate(1972, o2, n2), CreateTemporalMonthDay(o2, n2, i2);
  return CalendarMonthDayFromFields(i2, CreateTemporalMonthDay(o2, n2, i2, a2));
}
function ToTemporalTime(e, t2 = "constrain") {
  let r2, o2, n2, a2, i2, s2, l2 = e;
  if (IsObject(l2)) {
    if (IsTemporalTime(l2)) return l2;
    if (IsTemporalZonedDateTime(l2) && (l2 = GetPlainDateTimeFor(GetSlot(l2, g), GetSlot(l2, S), GetSlot(l2, p))), IsTemporalDateTime(l2)) {
      return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(l2, d), GetSlot(l2, m), GetSlot(l2, c), GetSlot(l2, h), GetSlot(l2, u), GetSlot(l2, T));
    }
    ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = ToTemporalTimeRecord(l2)), { hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = RegulateTime(r2, o2, n2, a2, i2, s2, t2);
  } else ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = function ParseTemporalTimeString(e2) {
    const t3 = z.exec(e2);
    let r3, o3, n3, a3, i3, s3, l3;
    if (t3) {
      r3 = ToIntegerOrInfinity(t3[1]), o3 = ToIntegerOrInfinity(t3[2] || t3[5]), n3 = ToIntegerOrInfinity(t3[3] || t3[6]), 60 === n3 && (n3 = 59);
      const e3 = (t3[4] || t3[7]) + "000000000";
      a3 = ToIntegerOrInfinity(e3.slice(0, 3)), i3 = ToIntegerOrInfinity(e3.slice(3, 6)), s3 = ToIntegerOrInfinity(e3.slice(6, 9)), l3 = t3[14];
      for (const [, e4, t4, r4] of l3.matchAll(H)) if ("u-ca" !== t4 && "!" === e4) throw new RangeError(`Unrecognized annotation: !${t4}=${r4}`);
      if (t3[8]) throw new RangeError("Z designator not supported for PlainTime");
    } else {
      let t4, l4;
      if ({ hasTime: l4, hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3, z: t4 } = ParseISODateTime(e2), !l4) throw new RangeError(`time is missing in string: ${e2}`);
      if (t4) throw new RangeError("Z designator not supported for PlainTime");
    }
    if (/[tT ][0-9][0-9]/.test(e2)) return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3 };
    try {
      const { month: t4, day: r4 } = ParseTemporalMonthDayString(e2);
      RejectISODate(1972, t4, r4);
    } catch {
      try {
        const { year: t4, month: r4 } = ParseTemporalYearMonthString(e2);
        RejectISODate(t4, r4, 1);
      } catch {
        return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3 };
      }
    }
    throw new RangeError(`invalid ISO 8601 time-only string ${e2}; may need a T prefix`);
  }(ToString(l2))), RejectTime(r2, o2, n2, a2, i2, s2);
  return new (GetIntrinsic("%Temporal.PlainTime%"))(r2, o2, n2, a2, i2, s2);
}
function ToTemporalYearMonth(e, t2) {
  if (IsObject(e)) {
    if (IsTemporalYearMonth(e)) return e;
    const r3 = GetTemporalCalendarSlotValueWithISODefault(e);
    return CalendarYearMonthFromFields(r3, PrepareTemporalFields(e, CalendarFields(r3, ["month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: r2, month: o2, referenceISODay: n2, calendar: a2 } = ParseTemporalYearMonthString(ToString(e));
  if (void 0 === a2 && (a2 = "iso8601"), !IsBuiltinCalendar(a2)) throw new RangeError(`invalid calendar identifier ${a2}`);
  if (a2 = ASCIILowercase(a2), void 0 === n2) return RejectISODate(r2, o2, 1), CreateTemporalYearMonth(r2, o2, a2);
  return CalendarYearMonthFromFields(a2, CreateTemporalYearMonth(r2, o2, a2, n2));
}
function InterpretISODateTimeOffset(t2, r2, o2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2) {
  const I2 = new (GetIntrinsic("%Temporal.PlainDateTime%"))(t2, r2, o2, i2, s2, l2, d2, m2, c2);
  if ("wall" === h2 || "ignore" === f2) {
    return GetSlot(GetInstantFor(T2, I2, p2), n);
  }
  if ("exact" === h2 || "use" === f2) {
    const n2 = GetUTCEpochNanoseconds(t2, r2, o2, i2, s2, l2, d2, m2, c2);
    if (null === n2) throw new RangeError("ZonedDateTime outside of supported range");
    return jsbi_default.subtract(n2, jsbi_default.BigInt(u2));
  }
  const S2 = GetPossibleInstantsFor(T2, I2);
  for (const t3 of S2) {
    const r3 = GetOffsetNanosecondsFor(T2, t3), o3 = jsbi_default.toNumber(RoundNumberToIncrement(jsbi_default.BigInt(r3), be, "halfExpand"));
    if (r3 === u2 || y2 && o3 === u2) return GetSlot(t3, n);
  }
  if ("reject" === f2) {
    const e = FormatTimeZoneOffsetString(u2), t3 = IsTemporalTimeZone(T2) ? GetSlot(T2, a) : "time zone";
    throw new RangeError(`Offset ${e} is invalid for ${I2.toString()} in ${t3}`);
  }
  return GetSlot(DisambiguatePossibleInstants(S2, T2, I2, p2), n);
}
function ToTemporalZonedDateTime(e, t2) {
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2 = false, y2 = "option";
  if (IsObject(e)) {
    if (IsTemporalZonedDateTime(e)) return e;
    u2 = GetTemporalCalendarSlotValueWithISODefault(e);
    const f3 = CalendarFields(u2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    f3.push("timeZone", "offset");
    const I3 = PrepareTemporalFields(e, f3, ["timeZone"]);
    c2 = ToTemporalTimeZoneSlotValue(I3.timeZone), h2 = I3.offset, void 0 === h2 && (y2 = "wall"), T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(u2, I3, t2);
  } else {
    let I3, S2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, ianaName: I3, offset: h2, z: S2, calendar: u2 } = function ParseTemporalZonedDateTimeString(e2) {
      const t3 = ParseISODateTime(e2);
      if (!t3.ianaName) throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
      return t3;
    }(ToString(e)), c2 = ToTemporalTimeZoneSlotValue(I3), S2 ? y2 = "exact" : h2 || (y2 = "wall"), u2 || (u2 = "iso8601"), !IsBuiltinCalendar(u2)) throw new RangeError(`invalid calendar identifier ${u2}`);
    u2 = ASCIILowercase(u2), f2 = true, T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), ToTemporalOverflow(t2);
  }
  let I2 = 0;
  "option" === y2 && (I2 = ParseTimeZoneOffsetString(h2));
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, y2, I2, c2, T2, p2, f2), c2, u2);
}
function CreateTemporalDateSlots(e, t2, r2, o2, n2) {
  RejectISODate(t2, r2, o2), RejectDateRange(t2, r2, o2), N(e), SetSlot(e, i, t2), SetSlot(e, s, r2), SetSlot(e, l, o2), SetSlot(e, p, n2), SetSlot(e, f, true);
}
function CreateTemporalDate(e, t2, r2, o2 = "iso8601") {
  const n2 = GetIntrinsic("%Temporal.PlainDate%"), a2 = Te(n2.prototype);
  return CreateTemporalDateSlots(a2, e, t2, r2, o2), a2;
}
function CreateTemporalDateTimeSlots(e, t2, r2, o2, n2, a2, f2, y2, I2, S2, g2) {
  RejectDateTime(t2, r2, o2, n2, a2, f2, y2, I2, S2), RejectDateTimeRange(t2, r2, o2, n2, a2, f2, y2, I2, S2), N(e), SetSlot(e, i, t2), SetSlot(e, s, r2), SetSlot(e, l, o2), SetSlot(e, d, n2), SetSlot(e, m, a2), SetSlot(e, c, f2), SetSlot(e, h, y2), SetSlot(e, u, I2), SetSlot(e, T, S2), SetSlot(e, p, g2);
}
function CreateTemporalDateTime(e, t2, r2, o2, n2, a2, i2, s2, l2, d2 = "iso8601") {
  const m2 = GetIntrinsic("%Temporal.PlainDateTime%"), c2 = Te(m2.prototype);
  return CreateTemporalDateTimeSlots(c2, e, t2, r2, o2, n2, a2, i2, s2, l2, d2), c2;
}
function CreateTemporalMonthDaySlots(e, t2, r2, o2, n2) {
  RejectISODate(n2, t2, r2), RejectDateRange(n2, t2, r2), N(e), SetSlot(e, s, t2), SetSlot(e, l, r2), SetSlot(e, i, n2), SetSlot(e, p, o2), SetSlot(e, I, true);
}
function CreateTemporalMonthDay(e, t2, r2 = "iso8601", o2 = 1972) {
  const n2 = GetIntrinsic("%Temporal.PlainMonthDay%"), a2 = Te(n2.prototype);
  return CreateTemporalMonthDaySlots(a2, e, t2, r2, o2), a2;
}
function CreateTemporalYearMonthSlots(e, t2, r2, o2, n2) {
  RejectISODate(t2, r2, n2), function RejectYearMonthRange(e2, t3) {
    RejectToRange(e2, Fe, Ye), e2 === Fe ? RejectToRange(t3, 4, 12) : e2 === Ye && RejectToRange(t3, 1, 9);
  }(t2, r2), N(e), SetSlot(e, i, t2), SetSlot(e, s, r2), SetSlot(e, l, n2), SetSlot(e, p, o2), SetSlot(e, y, true);
}
function CreateTemporalYearMonth(e, t2, r2 = "iso8601", o2 = 1) {
  const n2 = GetIntrinsic("%Temporal.PlainYearMonth%"), a2 = Te(n2.prototype);
  return CreateTemporalYearMonthSlots(a2, e, t2, r2, o2), a2;
}
function CreateTemporalZonedDateTimeSlots(e, t2, r2, o2) {
  ValidateEpochNanoseconds(t2), N(e), SetSlot(e, n, t2), SetSlot(e, g, r2), SetSlot(e, p, o2);
  const a2 = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
  SetSlot(e, S, a2);
}
function CreateTemporalZonedDateTime(e, t2, r2 = "iso8601") {
  const o2 = GetIntrinsic("%Temporal.ZonedDateTime%"), n2 = Te(o2.prototype);
  return CreateTemporalZonedDateTimeSlots(n2, e, t2, r2), n2;
}
function CalendarFields(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.fields%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "fields"), e, [t2]), o2 = [];
  for (const e2 of r2) {
    if ("string" != typeof e2) throw new TypeError("bad return from calendar.fields()");
    te.call(o2, e2);
  }
  return o2;
}
function CalendarMergeFields(e, t2, r2) {
  if ("string" == typeof e) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"), o3, [t2, r2]);
  }
  const o2 = Call(GetMethod(e, "mergeFields"), e, [t2, r2]);
  if (!IsObject(o2)) throw new TypeError("bad return from calendar.mergeFields()");
  return o2;
}
function CalendarDateAdd(e, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"), n3, [t2, r2, o2]);
  }
  void 0 === a2 && (a2 = GetMethod(e, "dateAdd"));
  const i2 = fe(a2, e, [t2, r2, o2]);
  if (!IsTemporalDate(i2)) throw new TypeError("invalid result");
  return i2;
}
function CalendarDateUntil(e, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"), n3, [t2, r2, o2]);
  }
  void 0 === a2 && (a2 = GetMethod(e, "dateUntil"));
  const i2 = fe(a2, e, [t2, r2, o2]);
  if (!IsTemporalDuration(i2)) throw new TypeError("invalid result");
  return i2;
}
function CalendarYear(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.year%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e, "year"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar year result must be an integer");
  if (!IsIntegralNumber(r2)) throw new RangeError("calendar year result must be an integer");
  return r2;
}
function CalendarMonth(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.month%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e, "month"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar month result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar month result must be a positive integer");
  return r2;
}
function CalendarMonthCode(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e, "monthCode"), e, [t2]);
  if ("string" != typeof r2) throw new TypeError("calendar monthCode result must be a string");
  return r2;
}
function CalendarDay(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "day"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar day result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar day result must be a positive integer");
  return r2;
}
function CalendarEra(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e, "era"), e, [t2]);
  if (void 0 === r2) return r2;
  if ("string" != typeof r2) throw new TypeError("calendar era result must be a string or undefined");
  return r2;
}
function CalendarEraYear(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e, "eraYear"), e, [t2]);
  if (void 0 === r2) return r2;
  if ("number" != typeof r2) throw new TypeError("calendar eraYear result must be an integer or undefined");
  if (!IsIntegralNumber(r2)) throw new RangeError("calendar eraYear result must be an integer or undefined");
  return r2;
}
function CalendarDayOfWeek(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "dayOfWeek"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar dayOfWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar dayOfWeek result must be a positive integer");
  return r2;
}
function CalendarDayOfYear(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "dayOfYear"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar dayOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar dayOfYear result must be a positive integer");
  return r2;
}
function CalendarWeekOfYear(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "weekOfYear"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar weekOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar weekOfYear result must be a positive integer");
  return r2;
}
function CalendarYearOfWeek(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "yearOfWeek"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar yearOfWeek result must be an integer");
  if (!IsIntegralNumber(r2)) throw new RangeError("calendar yearOfWeek result must be an integer");
  return r2;
}
function CalendarDaysInWeek(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "daysInWeek"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar daysInWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar daysInWeek result must be a positive integer");
  return r2;
}
function CalendarDaysInMonth(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "daysInMonth"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar daysInMonth result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar daysInMonth result must be a positive integer");
  return r2;
}
function CalendarDaysInYear(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "daysInYear"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar daysInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar daysInYear result must be a positive integer");
  return r2;
}
function CalendarMonthsInYear(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "monthsInYear"), e, [t2]);
  if ("number" != typeof r2) throw new TypeError("calendar monthsInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar monthsInYear result must be a positive integer");
  return r2;
}
function CalendarInLeapYear(e, t2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e, "inLeapYear"), e, [t2]);
  if ("boolean" != typeof r2) throw new TypeError("calendar inLeapYear result must be a boolean");
  return r2;
}
function ToTemporalCalendarSlotValue(e) {
  if (IsObject(e)) {
    if (HasSlot(e, p)) return GetSlot(e, p);
    if (!function ObjectImplementsTemporalCalendarProtocol(e2) {
      return !!IsTemporalCalendar(e2) || "dateAdd" in e2 && "dateFromFields" in e2 && "dateUntil" in e2 && "day" in e2 && "dayOfWeek" in e2 && "dayOfYear" in e2 && "daysInMonth" in e2 && "daysInWeek" in e2 && "daysInYear" in e2 && "fields" in e2 && "id" in e2 && "inLeapYear" in e2 && "mergeFields" in e2 && "month" in e2 && "monthCode" in e2 && "monthDayFromFields" in e2 && "monthsInYear" in e2 && "weekOfYear" in e2 && "year" in e2 && "yearMonthFromFields" in e2 && "yearOfWeek" in e2;
    }(e)) throw new TypeError("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
    return e;
  }
  const t2 = ToString(e);
  if (IsBuiltinCalendar(t2)) return ASCIILowercase(t2);
  let r2;
  try {
    ({ calendar: r2 } = ParseISODateTime(t2));
  } catch {
    try {
      ({ calendar: r2 } = ParseTemporalYearMonthString(t2));
    } catch {
      ({ calendar: r2 } = ParseTemporalMonthDayString(t2));
    }
  }
  if (r2 || (r2 = "iso8601"), !IsBuiltinCalendar(r2)) throw new RangeError(`invalid calendar identifier ${r2}`);
  return ASCIILowercase(r2);
}
function GetTemporalCalendarSlotValueWithISODefault(e) {
  if (HasSlot(e, p)) return GetSlot(e, p);
  const { calendar: t2 } = e;
  return void 0 === t2 ? "iso8601" : ToTemporalCalendarSlotValue(t2);
}
function ToTemporalCalendarIdentifier(e) {
  if ("string" == typeof e) return e;
  const t2 = e.id;
  if ("string" != typeof t2) throw new TypeError("calendar.id should be a string");
  return t2;
}
function ToTemporalCalendarObject(e) {
  if (IsObject(e)) return e;
  return new (GetIntrinsic("%Temporal.Calendar%"))(e);
}
function CalendarEquals(e, t2) {
  if (e === t2) return true;
  return ToTemporalCalendarIdentifier(e) === ToTemporalCalendarIdentifier(t2);
}
function ThrowIfCalendarsNotEqual(e, t2, r2) {
  if (e === t2) return;
  const o2 = ToTemporalCalendarIdentifier(e), n2 = ToTemporalCalendarIdentifier(t2);
  if (o2 !== n2) throw new RangeError(`cannot ${r2} of ${o2} and ${n2} calendars`);
}
function ConsolidateCalendars(e, t2) {
  if (e === t2) return t2;
  const r2 = ToTemporalCalendarIdentifier(e), o2 = ToTemporalCalendarIdentifier(t2);
  if (r2 === o2 || "iso8601" === r2) return t2;
  if ("iso8601" === o2) return e;
  throw new RangeError("irreconcilable calendars");
}
function CalendarDateFromFields(e, t2, r2, o2) {
  if ("string" == typeof e) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"), o3, [t2, r2]);
  }
  const n2 = Call(o2 ?? GetMethod(e, "dateFromFields"), e, [t2, r2]);
  if (!IsTemporalDate(n2)) throw new TypeError("invalid result");
  return n2;
}
function CalendarYearMonthFromFields(e, t2, r2) {
  if ("string" == typeof e) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearMonthFromFields%"), o3, [t2, r2]);
  }
  let o2 = Call(GetMethod(e, "yearMonthFromFields"), e, [t2, r2]);
  if (!IsTemporalYearMonth(o2)) throw new TypeError("invalid result");
  return o2;
}
function CalendarMonthDayFromFields(e, t2, r2) {
  if ("string" == typeof e) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"), o3, [t2, r2]);
  }
  let o2 = Call(GetMethod(e, "monthDayFromFields"), e, [t2, r2]);
  if (!IsTemporalMonthDay(o2)) throw new TypeError("invalid result");
  return o2;
}
function ToTemporalTimeZoneSlotValue(e) {
  if (IsObject(e)) {
    if (IsTemporalZonedDateTime(e)) return GetSlot(e, g);
    if (!function ObjectImplementsTemporalTimeZoneProtocol(e2) {
      return !!IsTemporalTimeZone(e2) || "getOffsetNanosecondsFor" in e2 && "getPossibleInstantsFor" in e2 && "id" in e2;
    }(e)) throw new TypeError("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
    return e;
  }
  return ParseTemporalTimeZone(ToString(e));
}
function ToTemporalTimeZoneIdentifier(e) {
  if ("string" == typeof e) return e;
  const t2 = e.id;
  if ("string" != typeof t2) throw new TypeError("timeZone.id should be a string");
  return t2;
}
function ToTemporalTimeZoneObject(e) {
  if (IsObject(e)) return e;
  return new (GetIntrinsic("%Temporal.TimeZone%"))(e);
}
function TimeZoneEquals(e, t2) {
  if (e === t2) return true;
  return ToTemporalTimeZoneIdentifier(e) === ToTemporalTimeZoneIdentifier(t2);
}
function TemporalDateTimeToDate(e) {
  return CreateTemporalDate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p));
}
function TemporalDateTimeToTime(e) {
  return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T));
}
function GetOffsetNanosecondsFor(e, t2, r2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"), r3, [t2]);
  }
  const o2 = Call(r2 ?? GetMethod(e, "getOffsetNanosecondsFor"), e, [t2]);
  if ("number" != typeof o2) throw new TypeError("bad return from getOffsetNanosecondsFor");
  if (!IsIntegralNumber(o2) || ae(o2) >= 864e11) throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
  return o2;
}
function GetOffsetStringFor(e, t2) {
  return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e, t2));
}
function GetPlainDateTimeFor(e, t2, r2) {
  const o2 = GetSlot(t2, n), a2 = GetOffsetNanosecondsFor(e, t2);
  let { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = GetISOPartsFromEpoch(o2);
  return { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = BalanceISODateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2 + a2), CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, r2);
}
function GetInstantFor(e, t2, r2) {
  return DisambiguatePossibleInstants(GetPossibleInstantsFor(e, t2), e, t2, r2);
}
function DisambiguatePossibleInstants(t2, r2, o2, n2) {
  const a2 = GetIntrinsic("%Temporal.Instant%"), f2 = t2.length;
  if (1 === f2) return t2[0];
  if (f2) switch (n2) {
    case "compatible":
    case "earlier":
      return t2[0];
    case "later":
      return t2[f2 - 1];
    case "reject":
      throw new RangeError("multiple instants found");
  }
  const y2 = GetSlot(o2, i), I2 = GetSlot(o2, s), S2 = GetSlot(o2, l), g2 = GetSlot(o2, d), w2 = GetSlot(o2, m), D2 = GetSlot(o2, c), G2 = GetSlot(o2, h), v2 = GetSlot(o2, u), C2 = GetSlot(o2, T), O2 = GetUTCEpochNanoseconds(y2, I2, S2, g2, w2, D2, G2, v2, C2);
  if (null === O2) throw new RangeError("DateTime outside of supported range");
  const b2 = new a2(jsbi_default.subtract(O2, Ee)), E2 = new a2(jsbi_default.add(O2, Ee)), M2 = GetOffsetNanosecondsFor(r2, b2), R2 = GetOffsetNanosecondsFor(r2, E2) - M2;
  switch (n2) {
    case "earlier": {
      const e = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e, 0, 0, 0, 0, 0, 0, 0, 0, 0, -R2, void 0);
      return GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e))[0];
    }
    case "compatible":
    case "later": {
      const e = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e, 0, 0, 0, 0, 0, 0, 0, 0, 0, R2, void 0), a3 = GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e));
      return a3[a3.length - 1];
    }
    case "reject":
      throw new RangeError("no such instant found");
  }
}
function GetPossibleInstantsFor(e, t2, r2) {
  if ("string" == typeof e) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"), r3, [t2]);
  }
  const o2 = Call(r2 ?? GetMethod(e, "getPossibleInstantsFor"), e, [t2]), n2 = [];
  for (const e2 of o2) {
    if (!IsTemporalInstant(e2)) throw new TypeError("bad return from getPossibleInstantsFor");
    te.call(n2, e2);
  }
  return n2;
}
function ISOYearString(e) {
  let t2;
  if (e < 0 || e > 9999) {
    t2 = (e < 0 ? "-" : "+") + `000000${ae(e)}`.slice(-6);
  } else t2 = `0000${e}`.slice(-4);
  return t2;
}
function ISODateTimePartString(e) {
  return `00${e}`.slice(-2);
}
function FormatSecondsStringPart(e, t2, r2, o2, n2) {
  if ("minute" === n2) return "";
  const a2 = `:${ISODateTimePartString(e)}`;
  let i2, s2 = 1e6 * t2 + 1e3 * r2 + o2;
  if ("auto" === n2) {
    if (0 === s2) return a2;
    for (i2 = `${s2}`.padStart(9, "0"); "0" === i2[i2.length - 1]; ) i2 = i2.slice(0, -1);
  } else {
    if (0 === n2) return a2;
    i2 = `${s2}`.padStart(9, "0").slice(0, n2);
  }
  return `${a2}.${i2}`;
}
function TemporalInstantToString(e, t2, r2) {
  let o2 = t2;
  void 0 === o2 && (o2 = "UTC");
  const n2 = GetPlainDateTimeFor(o2, e, "iso8601"), a2 = ISOYearString(GetSlot(n2, i)), p2 = ISODateTimePartString(GetSlot(n2, s)), f2 = ISODateTimePartString(GetSlot(n2, l)), y2 = ISODateTimePartString(GetSlot(n2, d)), I2 = ISODateTimePartString(GetSlot(n2, m)), S2 = FormatSecondsStringPart(GetSlot(n2, c), GetSlot(n2, h), GetSlot(n2, u), GetSlot(n2, T), r2);
  let g2 = "Z";
  if (void 0 !== t2) {
    g2 = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o2, e));
  }
  return `${a2}-${p2}-${f2}T${y2}:${I2}${S2}${g2}`;
}
function TemporalDurationToString(t2, r2 = "auto", o2) {
  function formatNumber(t3) {
    return t3 <= ue ? t3.toString(10) : jsbi_default.BigInt(t3).toString(10);
  }
  const n2 = GetSlot(t2, w), a2 = GetSlot(t2, D), i2 = GetSlot(t2, G), s2 = GetSlot(t2, v), l2 = GetSlot(t2, C), d2 = GetSlot(t2, O);
  let m2 = GetSlot(t2, b), c2 = GetSlot(t2, E), h2 = GetSlot(t2, M), u2 = GetSlot(t2, R);
  const T2 = DurationSign(n2, a2, i2, s2, l2, d2, m2, c2, h2, u2);
  if (o2) {
    const { unit: e, increment: t3, roundingMode: r3 } = o2;
    ({ seconds: m2, milliseconds: c2, microseconds: h2, nanoseconds: u2 } = RoundDuration(0, 0, 0, 0, 0, 0, m2, c2, h2, u2, t3, e, r3));
  }
  const p2 = [];
  n2 && p2.push(`${formatNumber(ae(n2))}Y`), a2 && p2.push(`${formatNumber(ae(a2))}M`), i2 && p2.push(`${formatNumber(ae(i2))}W`), s2 && p2.push(`${formatNumber(ae(s2))}D`);
  const f2 = [];
  l2 && f2.push(`${formatNumber(ae(l2))}H`), d2 && f2.push(`${formatNumber(ae(d2))}M`);
  const y2 = [];
  let I2, S2, g2, F2, Y2 = TotalDurationNanoseconds(0, 0, 0, m2, c2, h2, u2, 0);
  ({ quotient: Y2, remainder: I2 } = divmod(Y2, De)), { quotient: Y2, remainder: S2 } = divmod(Y2, De), { quotient: F2, remainder: g2 } = divmod(Y2, De);
  const P2 = 1e6 * ae(jsbi_default.toNumber(g2)) + 1e3 * ae(jsbi_default.toNumber(S2)) + ae(jsbi_default.toNumber(I2));
  let Z2;
  if ("auto" === r2) {
    if (0 !== P2) for (Z2 = `${P2}`.padStart(9, "0"); "0" === Z2[Z2.length - 1]; ) Z2 = Z2.slice(0, -1);
  } else 0 !== r2 && (Z2 = `${P2}`.padStart(9, "0").slice(0, r2));
  return Z2 && y2.unshift(".", Z2), jsbi_default.equal(F2, Ie) && !y2.length && "auto" === r2 || y2.unshift(abs(F2).toString()), y2.length && f2.push(`${y2.join("")}S`), f2.length && f2.unshift("T"), p2.length || f2.length ? `${T2 < 0 ? "-" : ""}P${p2.join("")}${f2.join("")}` : "PT0S";
}
function TemporalDateToString(e, t2 = "auto") {
  return `${ISOYearString(GetSlot(e, i))}-${ISODateTimePartString(GetSlot(e, s))}-${ISODateTimePartString(GetSlot(e, l))}${MaybeFormatCalendarAnnotation(GetSlot(e, p), t2)}`;
}
function TemporalDateTimeToString(e, t2, r2 = "auto", o2) {
  let n2 = GetSlot(e, i), a2 = GetSlot(e, s), f2 = GetSlot(e, l), y2 = GetSlot(e, d), I2 = GetSlot(e, m), S2 = GetSlot(e, c), g2 = GetSlot(e, h), w2 = GetSlot(e, u), D2 = GetSlot(e, T);
  if (o2) {
    const { unit: e2, increment: t3, roundingMode: r3 } = o2;
    ({ year: n2, month: a2, day: f2, hour: y2, minute: I2, second: S2, millisecond: g2, microsecond: w2, nanosecond: D2 } = RoundISODateTime(n2, a2, f2, y2, I2, S2, g2, w2, D2, t3, e2, r3));
  }
  return `${ISOYearString(n2)}-${ISODateTimePartString(a2)}-${ISODateTimePartString(f2)}T${ISODateTimePartString(y2)}:${ISODateTimePartString(I2)}${FormatSecondsStringPart(S2, g2, w2, D2, t2)}${MaybeFormatCalendarAnnotation(GetSlot(e, p), r2)}`;
}
function TemporalMonthDayToString(e, t2 = "auto") {
  let r2 = `${ISODateTimePartString(GetSlot(e, s))}-${ISODateTimePartString(GetSlot(e, l))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 = `${ISOYearString(GetSlot(e, i))}-${r2}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
function TemporalYearMonthToString(e, t2 = "auto") {
  let r2 = `${ISOYearString(GetSlot(e, i))}-${ISODateTimePartString(GetSlot(e, s))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 += `-${ISODateTimePartString(GetSlot(e, l))}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
function TemporalZonedDateTimeToString(e, t2, r2 = "auto", o2 = "auto", a2 = "auto", f2) {
  let y2 = GetSlot(e, S);
  if (f2) {
    const { unit: t3, increment: r3, roundingMode: o3 } = f2, a3 = RoundInstant(GetSlot(e, n), r3, t3, o3);
    y2 = new (GetIntrinsic("%Temporal.Instant%"))(a3);
  }
  const I2 = GetSlot(e, g), w2 = GetPlainDateTimeFor(I2, y2, "iso8601");
  let D2 = `${ISOYearString(GetSlot(w2, i))}-${ISODateTimePartString(GetSlot(w2, s))}-${ISODateTimePartString(GetSlot(w2, l))}T${ISODateTimePartString(GetSlot(w2, d))}:${ISODateTimePartString(GetSlot(w2, m))}${FormatSecondsStringPart(GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), t2)}`;
  if ("never" !== a2) {
    D2 += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I2, y2));
  }
  if ("never" !== o2) {
    D2 += `[${"critical" === o2 ? "!" : ""}${ToTemporalTimeZoneIdentifier(I2)}]`;
  }
  return D2 += MaybeFormatCalendarAnnotation(GetSlot(e, p), r2), D2;
}
function IsTimeZoneOffsetString(e) {
  return ze.test(he(e));
}
function ParseTimeZoneOffsetString(e) {
  const t2 = ze.exec(he(e));
  if (!t2) throw new RangeError(`invalid time zone offset: ${e}`);
  return ("-" === t2[1] || "−" === t2[1] ? -1 : 1) * (1e9 * (60 * (60 * +t2[2] + +(t2[3] || 0)) + +(t2[4] || 0)) + +((t2[5] || 0) + "000000000").slice(0, 9));
}
function GetCanonicalTimeZoneIdentifier(e) {
  if (IsTimeZoneOffsetString(e)) {
    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e));
  }
  return getIntlDateTimeFormatEnUsForTimeZone(he(e)).resolvedOptions().timeZone;
}
function GetNamedTimeZoneOffsetNanoseconds(t2, r2) {
  const { year: o2, month: n2, day: a2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = GetNamedTimeZoneDateTimeParts(t2, r2), h2 = o2 % 400, u2 = (o2 - h2) / 400, T2 = jsbi_default.multiply(jsbi_default.BigInt(146097), Ee), p2 = GetUTCEpochNanoseconds(h2, n2, a2, i2, s2, l2, d2, m2, c2), f2 = jsbi_default.add(p2, jsbi_default.multiply(T2, jsbi_default.BigInt(u2)));
  return jsbi_default.toNumber(jsbi_default.subtract(f2, r2));
}
function FormatTimeZoneOffsetString(e) {
  const t2 = e < 0 ? "-" : "+", r2 = ae(e), o2 = r2 % 1e9, n2 = ie(r2 / 1e9) % 60, a2 = ie(r2 / 6e10) % 60, i2 = ISODateTimePartString(ie(r2 / 36e11)), s2 = ISODateTimePartString(a2), l2 = ISODateTimePartString(n2);
  let d2 = "";
  if (o2) {
    let e2 = `${o2}`.padStart(9, "0");
    for (; "0" === e2[e2.length - 1]; ) e2 = e2.slice(0, -1);
    d2 = `:${l2}.${e2}`;
  } else n2 && (d2 = `:${l2}`);
  return `${t2}${i2}:${s2}${d2}`;
}
function FormatISOTimeZoneOffsetString(t2) {
  let r2 = jsbi_default.toNumber(RoundNumberToIncrement(jsbi_default.BigInt(t2), be, "halfExpand"));
  const o2 = r2 < 0 ? "-" : "+";
  r2 = ae(r2);
  const n2 = r2 / 6e10 % 60;
  return `${o2}${ISODateTimePartString(ie(r2 / 36e11))}:${ISODateTimePartString(n2)}`;
}
function GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = /* @__PURE__ */ new Date();
  m2.setUTCHours(n2, a2, i2, s2), m2.setUTCFullYear(t2, r2 - 1, o2);
  const c2 = m2.getTime();
  if (de(c2)) return null;
  let h2 = jsbi_default.multiply(jsbi_default.BigInt(c2), Ge);
  return h2 = jsbi_default.add(h2, jsbi_default.multiply(jsbi_default.BigInt(l2), De)), h2 = jsbi_default.add(h2, jsbi_default.BigInt(d2)), jsbi_default.lessThan(h2, Me) || jsbi_default.greaterThan(h2, Re) ? null : h2;
}
function GetISOPartsFromEpoch(t2) {
  const { quotient: r2, remainder: o2 } = divmod(t2, Ge);
  let n2 = jsbi_default.toNumber(r2), a2 = jsbi_default.toNumber(o2);
  a2 < 0 && (a2 += 1e6, n2 -= 1);
  const i2 = ie(a2 / 1e3) % 1e3, s2 = a2 % 1e3, l2 = new Date(n2);
  return { epochMilliseconds: n2, year: l2.getUTCFullYear(), month: l2.getUTCMonth() + 1, day: l2.getUTCDate(), hour: l2.getUTCHours(), minute: l2.getUTCMinutes(), second: l2.getUTCSeconds(), millisecond: l2.getUTCMilliseconds(), microsecond: i2, nanosecond: s2 };
}
function GetNamedTimeZoneDateTimeParts(e, t2) {
  const { epochMilliseconds: r2, millisecond: o2, microsecond: n2, nanosecond: a2 } = GetISOPartsFromEpoch(t2), { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2 } = function GetFormatterParts(e2, t3) {
    const r3 = getIntlDateTimeFormatEnUsForTimeZone(e2).format(new Date(t3));
    return function parseFromEnUsFormat(e3) {
      const t4 = e3.split(/[^\w]+/);
      if (7 !== t4.length) throw new RangeError(`expected 7 parts in "${e3}`);
      const r4 = +t4[0], o3 = +t4[1];
      let n3 = +t4[2];
      const a3 = t4[3].toUpperCase();
      if ("B" === a3 || "BC" === a3) n3 = 1 - n3;
      else if ("A" !== a3 && "AD" !== a3) throw new RangeError(`Unknown era ${a3} in "${e3}`);
      let i3 = +t4[4];
      24 === i3 && (i3 = 0);
      const s3 = +t4[5], l3 = +t4[6];
      if (!(me(n3) && me(r4) && me(o3) && me(i3) && me(s3) && me(l3))) throw new RangeError(`Invalid number in "${e3}`);
      return { year: n3, month: r4, day: o3, hour: i3, minute: s3, second: l3 };
    }(r3);
  }(e, r2);
  return BalanceISODateTime(i2, s2, l2, d2, m2, c2, o2, n2, a2);
}
function maxJSBI(t2, r2) {
  return jsbi_default.lessThan(t2, r2) ? r2 : t2;
}
function afterLatestPossibleTzdbRuleChange() {
  return jsbi_default.add(Ve(), Ze);
}
function GetNamedTimeZoneNextTransition(t2, r2) {
  if (jsbi_default.lessThan(r2, Pe)) return GetNamedTimeZoneNextTransition(t2, Pe);
  const o2 = jsbi_default.add(r2, Be), n2 = maxJSBI(afterLatestPossibleTzdbRuleChange(), o2);
  let a2 = maxJSBI(Pe, r2);
  const i2 = GetNamedTimeZoneOffsetNanoseconds(t2, a2);
  let s2 = a2, l2 = i2;
  for (; i2 === l2 && jsbi_default.lessThan(jsbi_default.BigInt(a2), n2); ) {
    if (s2 = jsbi_default.add(a2, Ne), jsbi_default.greaterThan(s2, Re)) return null;
    l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2), i2 === l2 && (a2 = s2);
  }
  if (i2 === l2) return null;
  return bisect((e) => GetNamedTimeZoneOffsetNanoseconds(t2, e), a2, s2, i2, l2);
}
function GetNamedTimeZonePreviousTransition(t2, r2) {
  const o2 = afterLatestPossibleTzdbRuleChange(), a2 = jsbi_default.greaterThan(r2, o2), i2 = a2 ? jsbi_default.subtract(r2, Be) : Pe;
  if ("Africa/Casablanca" === t2 || "Africa/El_Aaiun" === t2) {
    const o3 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
    if (jsbi_default.lessThan(o3, r2)) return GetNamedTimeZonePreviousTransition(t2, o3);
  }
  let s2 = jsbi_default.subtract(r2, Se);
  if (jsbi_default.lessThan(s2, Pe)) return null;
  const l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2);
  let d2 = s2, m2 = l2;
  for (; l2 === m2 && jsbi_default.greaterThan(s2, i2); ) {
    if (d2 = jsbi_default.subtract(s2, Ne), jsbi_default.lessThan(d2, Pe)) return null;
    m2 = GetNamedTimeZoneOffsetNanoseconds(t2, d2), l2 === m2 && (s2 = d2);
  }
  if (l2 === m2) {
    if (a2) {
      const r3 = jsbi_default.subtract(o2, Ee);
      return GetNamedTimeZonePreviousTransition(t2, r3);
    }
    return null;
  }
  return bisect((e) => GetNamedTimeZoneOffsetNanoseconds(t2, e), d2, s2, m2, l2);
}
function LeapYear(e) {
  if (void 0 === e) return false;
  return e % 4 == 0 && (!(e % 100 == 0) || e % 400 == 0);
}
function ISODaysInMonth(e, t2) {
  return { standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] }[LeapYear(e) ? "leapyear" : "standard"][t2 - 1];
}
function DayOfWeek(e, t2, r2) {
  const o2 = t2 + (t2 < 3 ? 10 : -2), n2 = e - (t2 < 3 ? 1 : 0), a2 = ie(n2 / 100), i2 = n2 - 100 * a2, s2 = (r2 + ie(2.6 * o2 - 0.2) + (i2 + ie(i2 / 4)) + (ie(a2 / 4) - 2 * a2)) % 7;
  return s2 + (s2 <= 0 ? 7 : 0);
}
function DayOfYear(e, t2, r2) {
  let o2 = r2;
  for (let r3 = t2 - 1; r3 > 0; r3--) o2 += ISODaysInMonth(e, r3);
  return o2;
}
function WeekOfYear(e, t2, r2) {
  const o2 = DayOfYear(e, t2, r2), n2 = DayOfWeek(e, t2, r2) || 7, a2 = DayOfWeek(e, 1, 1), i2 = ie((o2 - n2 + 10) / 7);
  return i2 < 1 ? 5 === a2 || 6 === a2 && LeapYear(e - 1) ? { week: 53, year: e - 1 } : { week: 52, year: e - 1 } : 53 === i2 && (LeapYear(e) ? 366 : 365) - o2 < 4 - n2 ? { week: 1, year: e + 1 } : { week: i2, year: e };
}
function DurationSign(e, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const m2 of [e, t2, r2, o2, n2, a2, i2, s2, l2, d2]) if (0 !== m2) return m2 < 0 ? -1 : 1;
  return 0;
}
function BalanceISOYearMonth(e, t2) {
  let r2 = e, o2 = t2;
  if (!me(r2) || !me(o2)) throw new RangeError("infinity is out of range");
  return o2 -= 1, r2 += ie(o2 / 12), o2 %= 12, o2 < 0 && (o2 += 12), o2 += 1, { year: r2, month: o2 };
}
function BalanceISODate(e, t2, r2) {
  let o2 = e, n2 = t2, a2 = r2;
  if (!me(a2)) throw new RangeError("infinity is out of range");
  ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2));
  const i2 = 146097;
  if (ae(a2) > i2) {
    const e2 = le(a2 / i2);
    o2 += 400 * e2, a2 -= e2 * i2;
  }
  let s2 = 0, l2 = n2 > 2 ? o2 : o2 - 1;
  for (; s2 = LeapYear(l2) ? 366 : 365, a2 < -s2; ) o2 -= 1, l2 -= 1, a2 += s2;
  for (l2 += 1; s2 = LeapYear(l2) ? 366 : 365, a2 > s2; ) o2 += 1, l2 += 1, a2 -= s2;
  for (; a2 < 1; ) ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 - 1)), a2 += ISODaysInMonth(o2, n2);
  for (; a2 > ISODaysInMonth(o2, n2); ) a2 -= ISODaysInMonth(o2, n2), { year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 + 1);
  return { year: o2, month: n2, day: a2 };
}
function BalanceISODateTime(e, t2, r2, o2, n2, a2, i2, s2, l2) {
  const { deltaDays: d2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 } = BalanceTime(o2, n2, a2, i2, s2, l2), { year: f2, month: y2, day: I2 } = BalanceISODate(e, t2, r2 + d2);
  return { year: f2, month: y2, day: I2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 };
}
function BalanceTime(t2, r2, o2, n2, a2, i2) {
  let s2, l2 = jsbi_default.BigInt(t2), d2 = jsbi_default.BigInt(r2), m2 = jsbi_default.BigInt(o2), c2 = jsbi_default.BigInt(n2), h2 = jsbi_default.BigInt(a2), u2 = jsbi_default.BigInt(i2);
  return { quotient: s2, remainder: u2 } = NonNegativeBigIntDivmod(u2, De), h2 = jsbi_default.add(h2, s2), { quotient: s2, remainder: h2 } = NonNegativeBigIntDivmod(h2, De), c2 = jsbi_default.add(c2, s2), { quotient: s2, remainder: c2 } = NonNegativeBigIntDivmod(c2, De), m2 = jsbi_default.add(m2, s2), { quotient: s2, remainder: m2 } = NonNegativeBigIntDivmod(m2, ge), d2 = jsbi_default.add(d2, s2), { quotient: s2, remainder: d2 } = NonNegativeBigIntDivmod(d2, ge), l2 = jsbi_default.add(l2, s2), { quotient: s2, remainder: l2 } = NonNegativeBigIntDivmod(l2, we), { deltaDays: jsbi_default.toNumber(s2), hour: jsbi_default.toNumber(l2), minute: jsbi_default.toNumber(d2), second: jsbi_default.toNumber(m2), millisecond: jsbi_default.toNumber(c2), microsecond: jsbi_default.toNumber(h2), nanosecond: jsbi_default.toNumber(u2) };
}
function TotalDurationNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2) {
  const d2 = jsbi_default.BigInt(t2);
  let m2 = jsbi_default.BigInt(s2);
  0 !== t2 && (m2 = jsbi_default.subtract(jsbi_default.BigInt(s2), jsbi_default.BigInt(l2)));
  const c2 = jsbi_default.add(jsbi_default.BigInt(r2), jsbi_default.multiply(d2, jsbi_default.BigInt(24))), h2 = jsbi_default.add(jsbi_default.BigInt(o2), jsbi_default.multiply(c2, ge)), u2 = jsbi_default.add(jsbi_default.BigInt(n2), jsbi_default.multiply(h2, ge)), T2 = jsbi_default.add(jsbi_default.BigInt(a2), jsbi_default.multiply(u2, De)), p2 = jsbi_default.add(jsbi_default.BigInt(i2), jsbi_default.multiply(T2, De));
  return jsbi_default.add(jsbi_default.BigInt(m2), jsbi_default.multiply(p2, De));
}
function NanosecondsToDays(t2, r2) {
  const o2 = GetIntrinsic("%Temporal.Instant%"), a2 = se(jsbi_default.toNumber(t2));
  let f2 = jsbi_default.BigInt(t2), y2 = 864e11;
  if (0 === a2) return { days: 0, nanoseconds: Ie, dayLengthNs: y2 };
  if (!IsTemporalZonedDateTime(r2)) {
    let t3;
    return { quotient: t3, remainder: f2 } = divmod(f2, jsbi_default.BigInt(y2)), { days: jsbi_default.toNumber(t3), nanoseconds: f2, dayLengthNs: y2 };
  }
  const I2 = GetSlot(r2, n), w2 = GetSlot(r2, S), D2 = jsbi_default.add(I2, f2), G2 = new o2(D2), v2 = GetSlot(r2, g), C2 = GetSlot(r2, p), O2 = GetPlainDateTimeFor(v2, w2, C2), b2 = GetPlainDateTimeFor(v2, G2, C2);
  let { days: E2 } = DifferenceISODateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(O2, d), GetSlot(O2, m), GetSlot(O2, c), GetSlot(O2, h), GetSlot(O2, u), GetSlot(O2, T), GetSlot(b2, i), GetSlot(b2, s), GetSlot(b2, l), GetSlot(b2, d), GetSlot(b2, m), GetSlot(b2, c), GetSlot(b2, h), GetSlot(b2, u), GetSlot(b2, T), C2, "day", Te(null)), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, E2, 0, 0, 0, 0, 0, 0), R2 = jsbi_default.BigInt(E2);
  if (1 === a2) for (; jsbi_default.greaterThan(R2, Ie) && jsbi_default.greaterThan(M2, D2); ) R2 = jsbi_default.subtract(R2, Se), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, jsbi_default.toNumber(R2), 0, 0, 0, 0, 0, 0);
  f2 = jsbi_default.subtract(D2, M2);
  let F2 = false, Y2 = new o2(M2);
  do {
    const t3 = AddZonedDateTime(Y2, v2, C2, 0, 0, 0, a2, 0, 0, 0, 0, 0, 0), r3 = GetSlot(Y2, n);
    y2 = jsbi_default.toNumber(jsbi_default.subtract(t3, r3)), F2 = jsbi_default.greaterThanOrEqual(jsbi_default.multiply(jsbi_default.subtract(f2, jsbi_default.BigInt(y2)), jsbi_default.BigInt(a2)), Ie), F2 && (f2 = jsbi_default.subtract(f2, jsbi_default.BigInt(y2)), Y2 = new o2(t3), R2 = jsbi_default.add(R2, jsbi_default.BigInt(a2)));
  } while (F2);
  if (!isZero(R2) && signJSBI(R2) !== a2) throw new RangeError("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
  if (!isZero(f2) && signJSBI(f2) !== a2) {
    if (isNegativeJSBI(f2) && 1 === a2) throw new Error("assert not reached");
    throw new RangeError("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
  }
  if (jsbi_default.greaterThanOrEqual(abs(f2), abs(jsbi_default.BigInt(y2)))) throw new Error("assert not reached");
  return { days: jsbi_default.toNumber(R2), nanoseconds: f2, dayLengthNs: ae(y2) };
}
function BalanceDuration(e, t2, r2, o2, n2, a2, i2, s2, l2) {
  let d2 = BalancePossiblyInfiniteDuration(e, t2, r2, o2, n2, a2, i2, s2, l2);
  if ("positive overflow" === d2 || "negative overflow" === d2) throw new RangeError("Duration out of range");
  return d2;
}
function BalancePossiblyInfiniteDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2) {
  let c2, h2, u2, T2, f2, y2, I2 = t2;
  if (IsTemporalZonedDateTime(m2)) {
    const t3 = AddZonedDateTime(GetSlot(m2, S), GetSlot(m2, g), GetSlot(m2, p), 0, 0, 0, I2, r2, o2, a2, i2, s2, l2), d3 = GetSlot(m2, n);
    c2 = jsbi_default.subtract(t3, d3);
  } else c2 = TotalDurationNanoseconds(I2, r2, o2, a2, i2, s2, l2, 0);
  "year" === d2 || "month" === d2 || "week" === d2 || "day" === d2 ? { days: I2, nanoseconds: c2 } = NanosecondsToDays(c2, m2) : I2 = 0;
  const w2 = jsbi_default.lessThan(c2, Ie) ? -1 : 1;
  switch (c2 = abs(c2), h2 = u2 = T2 = f2 = y2 = Ie, d2) {
    case "year":
    case "month":
    case "week":
    case "day":
    case "hour":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge), { quotient: y2, remainder: f2 } = divmod(f2, ge);
      break;
    case "minute":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge);
      break;
    case "second":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De);
      break;
    case "millisecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De);
      break;
    case "microsecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De));
      break;
    case "nanosecond":
      break;
    default:
      throw new Error("assert not reached");
  }
  const D2 = jsbi_default.toNumber(y2) * w2, G2 = jsbi_default.toNumber(f2) * w2, v2 = jsbi_default.toNumber(T2) * w2, C2 = jsbi_default.toNumber(u2) * w2, O2 = jsbi_default.toNumber(h2) * w2, b2 = jsbi_default.toNumber(c2) * w2;
  for (const e of [I2, D2, G2, v2, C2, O2, b2]) if (!me(e)) return 1 === w2 ? "positive overflow" : "negative overflow";
  return { days: I2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
}
function UnbalanceDurationRelative(t2, r2, o2, n2, a2, i2) {
  const s2 = GetIntrinsic("%Temporal.Duration%"), l2 = DurationSign(t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
  if (0 === l2) return { years: t2, months: r2, weeks: o2, days: n2 };
  const d2 = jsbi_default.BigInt(l2);
  let m2, c2, h2 = jsbi_default.BigInt(t2), u2 = jsbi_default.BigInt(r2), T2 = jsbi_default.BigInt(o2), f2 = jsbi_default.BigInt(n2);
  i2 && (c2 = ToTemporalDate(i2), m2 = GetSlot(c2, p));
  const y2 = new s2(l2), I2 = new s2(0, l2), S2 = new s2(0, 0, l2);
  switch (a2) {
    case "year":
      break;
    case "month":
      {
        if (!m2) throw new RangeError("a starting point is required for months balancing");
        let t3, r3;
        for ("string" != typeof m2 && (t3 = GetMethod(m2, "dateAdd"), r3 = GetMethod(m2, "dateUntil")); !isZero(h2); ) {
          const o3 = CalendarDateAdd(m2, c2, y2, void 0, t3), n3 = Te(null);
          n3.largestUnit = "month";
          const a3 = CalendarDateUntil(m2, c2, o3, n3, r3), i3 = jsbi_default.BigInt(GetSlot(a3, D));
          c2 = o3, u2 = jsbi_default.add(u2, i3), h2 = jsbi_default.subtract(h2, d2);
        }
      }
      break;
    case "week": {
      if (!m2) throw new RangeError("a starting point is required for weeks balancing");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = jsbi_default.add(f2, jsbi_default.BigInt(r3)), h2 = jsbi_default.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = jsbi_default.add(f2, jsbi_default.BigInt(r3)), u2 = jsbi_default.subtract(u2, d2);
      }
      break;
    }
    default: {
      if (isZero(h2) && isZero(u2) && isZero(T2)) break;
      if (!m2) throw new RangeError("a starting point is required for balancing calendar units");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = jsbi_default.add(f2, jsbi_default.BigInt(r3)), h2 = jsbi_default.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = jsbi_default.add(f2, jsbi_default.BigInt(r3)), u2 = jsbi_default.subtract(u2, d2);
      }
      for (; !isZero(T2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, S2, t3)), f2 = jsbi_default.add(f2, jsbi_default.BigInt(r3)), T2 = jsbi_default.subtract(T2, d2);
      }
      break;
    }
  }
  return { years: jsbi_default.toNumber(h2), months: jsbi_default.toNumber(u2), weeks: jsbi_default.toNumber(T2), days: jsbi_default.toNumber(f2) };
}
function CalculateOffsetShift(e, t2, r2, o2, n2) {
  if (IsTemporalZonedDateTime(e)) {
    const a2 = GetSlot(e, S), i2 = GetSlot(e, g), s2 = GetSlot(e, p), l2 = GetOffsetNanosecondsFor(i2, a2), d2 = AddZonedDateTime(a2, i2, s2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
    return GetOffsetNanosecondsFor(i2, new (GetIntrinsic("%Temporal.Instant%"))(d2)) - l2;
  }
  return 0;
}
function CreateNegatedTemporalDuration(e) {
  return new (GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e, w), -GetSlot(e, D), -GetSlot(e, G), -GetSlot(e, v), -GetSlot(e, C), -GetSlot(e, O), -GetSlot(e, b), -GetSlot(e, E), -GetSlot(e, M), -GetSlot(e, R));
}
function ConstrainToRange(e, t2, r2) {
  return oe(r2, ne(t2, e));
}
function ConstrainISODate(e, t2, r2) {
  const o2 = ConstrainToRange(t2, 1, 12);
  return { year: e, month: o2, day: ConstrainToRange(r2, 1, ISODaysInMonth(e, o2)) };
}
function RejectToRange(e, t2, r2) {
  if (e < t2 || e > r2) throw new RangeError(`value out of range: ${t2} <= ${e} <= ${r2}`);
}
function RejectISODate(e, t2, r2) {
  RejectToRange(t2, 1, 12), RejectToRange(r2, 1, ISODaysInMonth(e, t2));
}
function RejectDateRange(e, t2, r2) {
  RejectDateTimeRange(e, t2, r2, 12, 0, 0, 0, 0, 0);
}
function RejectTime(e, t2, r2, o2, n2, a2) {
  RejectToRange(e, 0, 23), RejectToRange(t2, 0, 59), RejectToRange(r2, 0, 59), RejectToRange(o2, 0, 999), RejectToRange(n2, 0, 999), RejectToRange(a2, 0, 999);
}
function RejectDateTime(e, t2, r2, o2, n2, a2, i2, s2, l2) {
  RejectISODate(e, t2, r2), RejectTime(o2, n2, a2, i2, s2, l2);
}
function RejectDateTimeRange(e, t2, r2, o2, n2, a2, i2, s2, l2) {
  if (RejectToRange(e, Fe, Ye), e === Fe && null == GetUTCEpochNanoseconds(e, t2, r2 + 1, o2, n2, a2, i2, s2, l2 - 1) || e === Ye && null == GetUTCEpochNanoseconds(e, t2, r2 - 1, o2, n2, a2, i2, s2, l2 + 1)) throw new RangeError("DateTime outside of supported range");
}
function ValidateEpochNanoseconds(t2) {
  if (jsbi_default.lessThan(t2, Me) || jsbi_default.greaterThan(t2, Re)) throw new RangeError("Instant outside of supported range");
}
function RejectDuration(e, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = DurationSign(e, t2, r2, o2, n2, a2, i2, s2, l2, d2);
  for (const c2 of [e, t2, r2, o2, n2, a2, i2, s2, l2, d2]) {
    if (!me(c2)) throw new RangeError("infinite values not allowed as duration fields");
    const e2 = se(c2);
    if (0 !== e2 && e2 !== m2) throw new RangeError("mixed-sign values not allowed as duration fields");
  }
}
function DifferenceISODate(e, t2, r2, o2, n2, a2, i2) {
  switch (i2) {
    case "year":
    case "month": {
      const s2 = -CompareISODate(e, t2, r2, o2, n2, a2);
      if (0 === s2) return { years: 0, months: 0, weeks: 0, days: 0 };
      const l2 = { year: e, month: t2, day: r2 }, d2 = { year: o2, month: n2, day: a2 };
      let m2 = d2.year - l2.year, c2 = AddISODate(e, t2, r2, m2, 0, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2);
      if (0 === h2) return "year" === i2 ? { years: m2, months: 0, weeks: 0, days: 0 } : { years: 0, months: 12 * m2, weeks: 0, days: 0 };
      let u2 = d2.month - l2.month;
      if (h2 !== s2 && (m2 -= s2, u2 += 12 * s2), c2 = AddISODate(e, t2, r2, m2, u2, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2), 0 === h2) return "year" === i2 ? { years: m2, months: u2, weeks: 0, days: 0 } : { years: 0, months: u2 + 12 * m2, weeks: 0, days: 0 };
      h2 !== s2 && (u2 -= s2, u2 === -s2 && (m2 -= s2, u2 = 11 * s2), c2 = AddISODate(e, t2, r2, m2, u2, 0, 0, "constrain"));
      let T2 = 0;
      return T2 = c2.month === d2.month ? d2.day - c2.day : s2 < 0 ? -c2.day - (ISODaysInMonth(d2.year, d2.month) - d2.day) : d2.day + (ISODaysInMonth(c2.year, c2.month) - c2.day), "month" === i2 && (u2 += 12 * m2, m2 = 0), { years: m2, months: u2, weeks: 0, days: T2 };
    }
    case "week":
    case "day": {
      let s2, l2, d2;
      CompareISODate(e, t2, r2, o2, n2, a2) < 0 ? (l2 = { year: e, month: t2, day: r2 }, s2 = { year: o2, month: n2, day: a2 }, d2 = 1) : (l2 = { year: o2, month: n2, day: a2 }, s2 = { year: e, month: t2, day: r2 }, d2 = -1);
      let m2 = DayOfYear(s2.year, s2.month, s2.day) - DayOfYear(l2.year, l2.month, l2.day);
      for (let e2 = l2.year; e2 < s2.year; ++e2) m2 += LeapYear(e2) ? 366 : 365;
      let c2 = 0;
      return "week" === i2 && (c2 = ie(m2 / 7), m2 %= 7), c2 *= d2, m2 *= d2, { years: 0, months: 0, weeks: c2, days: m2 };
    }
    default:
      throw new Error("assert not reached");
  }
}
function DifferenceTime(e, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = i2 - e, u2 = s2 - t2, T2 = l2 - r2, p2 = d2 - o2, f2 = m2 - n2, y2 = c2 - a2;
  const I2 = DurationSign(0, 0, 0, 0, h2, u2, T2, p2, f2, y2);
  h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2;
  let S2 = 0;
  if ({ deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), 0 != S2) throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
  return h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2, { hours: h2, minutes: u2, seconds: T2, milliseconds: p2, microseconds: f2, nanoseconds: y2 };
}
function DifferenceInstant(t2, r2, o2, n2, a2, i2) {
  const s2 = jsbi_default.subtract(r2, t2);
  let l2 = 0, d2 = 0, m2 = jsbi_default.toNumber(jsbi_default.remainder(s2, De)), c2 = jsbi_default.toNumber(jsbi_default.remainder(jsbi_default.divide(s2, De), De)), h2 = jsbi_default.toNumber(jsbi_default.remainder(jsbi_default.divide(s2, Ge), De)), u2 = jsbi_default.toNumber(jsbi_default.divide(s2, ve));
  return { hours: l2, minutes: d2, seconds: u2, milliseconds: h2, microseconds: c2, nanoseconds: m2 } = RoundDuration(0, 0, 0, 0, 0, 0, u2, h2, c2, m2, o2, n2, i2), BalanceDuration(0, l2, d2, u2, h2, c2, m2, a2);
}
function DifferenceISODateTime(e, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2) {
  let w2 = e, D2 = t2, G2 = r2, { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = DifferenceTime(o2, n2, a2, i2, s2, l2, h2, u2, T2, p2, f2, y2);
  const R2 = DurationSign(0, 0, 0, 0, v2, C2, O2, b2, E2, M2);
  CompareISODate(d2, m2, c2, w2, D2, G2) === -R2 && ({ year: w2, month: D2, day: G2 } = BalanceISODate(w2, D2, G2 - R2), { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration(-R2, v2, C2, O2, b2, E2, M2, S2));
  const F2 = CreateTemporalDate(w2, D2, G2, I2), Y2 = CreateTemporalDate(d2, m2, c2, I2), P2 = LargerOfTwoTemporalUnits("day", S2), Z2 = CopyOptions(g2);
  Z2.largestUnit = P2;
  let { years: B2, months: N2, weeks: j2, days: $2 } = CalendarDateUntil(I2, F2, Y2, Z2);
  return { days: $2, hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration($2, v2, C2, O2, b2, E2, M2, S2), { years: B2, months: N2, weeks: j2, days: $2, hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 };
}
function DifferenceZonedDateTime(t2, r2, o2, n2, a2, p2) {
  const f2 = jsbi_default.subtract(r2, t2);
  if (jsbi_default.equal(f2, Ie)) return { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  const y2 = GetIntrinsic("%Temporal.Instant%"), I2 = new y2(t2), S2 = new y2(r2), g2 = GetPlainDateTimeFor(o2, I2, n2), w2 = GetPlainDateTimeFor(o2, S2, n2);
  let { years: D2, months: G2, weeks: v2, days: C2 } = DifferenceISODateTime(GetSlot(g2, i), GetSlot(g2, s), GetSlot(g2, l), GetSlot(g2, d), GetSlot(g2, m), GetSlot(g2, c), GetSlot(g2, h), GetSlot(g2, u), GetSlot(g2, T), GetSlot(w2, i), GetSlot(w2, s), GetSlot(w2, l), GetSlot(w2, d), GetSlot(w2, m), GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), n2, a2, p2);
  const O2 = AddZonedDateTime(I2, o2, n2, D2, G2, v2, 0, 0, 0, 0, 0, 0, 0);
  let b2 = jsbi_default.subtract(r2, O2);
  const E2 = CreateTemporalZonedDateTime(O2, o2, n2);
  ({ nanoseconds: b2, days: C2 } = NanosecondsToDays(b2, E2));
  const { hours: M2, minutes: R2, seconds: F2, milliseconds: Y2, microseconds: P2, nanoseconds: Z2 } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi_default.toNumber(b2), "hour");
  return { years: D2, months: G2, weeks: v2, days: C2, hours: M2, minutes: R2, seconds: F2, milliseconds: Y2, microseconds: P2, nanoseconds: Z2 };
}
function GetDifferenceSettings(e, t2, r2, o2, n2, a2) {
  const i2 = Ue.reduce((e2, t3) => {
    const n3 = t3[0], a3 = t3[1], i3 = t3[2];
    return "datetime" !== r2 && i3 !== r2 || o2.includes(a3) || e2.push(a3, n3), e2;
  }, []);
  let s2 = GetTemporalUnit(t2, "largestUnit", r2, "auto");
  if (o2.includes(s2)) throw new RangeError(`largestUnit must be one of ${i2.join(", ")}, not ${s2}`);
  const l2 = ToTemporalRoundingIncrement(t2);
  let d2 = ToTemporalRoundingMode(t2, "trunc");
  "since" === e && (d2 = function NegateTemporalRoundingMode(e2) {
    switch (e2) {
      case "ceil":
        return "floor";
      case "floor":
        return "ceil";
      case "halfCeil":
        return "halfFloor";
      case "halfFloor":
        return "halfCeil";
      default:
        return e2;
    }
  }(d2));
  const m2 = GetTemporalUnit(t2, "smallestUnit", r2, n2);
  if (o2.includes(m2)) throw new RangeError(`smallestUnit must be one of ${i2.join(", ")}, not ${m2}`);
  const c2 = LargerOfTwoTemporalUnits(a2, m2);
  if ("auto" === s2 && (s2 = c2), LargerOfTwoTemporalUnits(s2, m2) !== s2) throw new RangeError(`largestUnit ${s2} cannot be smaller than smallestUnit ${m2}`);
  const h2 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[m2];
  return void 0 !== h2 && ValidateTemporalRoundingIncrement(l2, h2, false), { largestUnit: s2, roundingIncrement: l2, roundingMode: d2, smallestUnit: m2 };
}
function DifferenceTemporalInstant(e, t2, r2, o2) {
  const a2 = "since" === e ? -1 : 1, i2 = ToTemporalInstant(r2), s2 = GetDifferenceSettings(e, CopyOptions(o2), "time", [], "nanosecond", "second"), l2 = GetSlot(t2, n), d2 = GetSlot(i2, n);
  let { hours: m2, minutes: c2, seconds: h2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = DifferenceInstant(l2, d2, s2.roundingIncrement, s2.smallestUnit, s2.largestUnit, s2.roundingMode);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, a2 * m2, a2 * c2, a2 * h2, a2 * u2, a2 * T2, a2 * p2);
}
function DifferenceTemporalPlainDate(e, t2, r2, o2) {
  const n2 = "since" === e ? -1 : 1, a2 = ToTemporalDate(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between dates");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e, s2, "date", [], "day", "day");
  s2.largestUnit = l2.largestUnit;
  let { years: d2, months: m2, weeks: c2, days: h2 } = CalendarDateUntil(i2, t2, a2, s2);
  "day" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: d2, months: m2, weeks: c2, days: h2 } = RoundDuration(d2, m2, c2, h2, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, t2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * d2, n2 * m2, n2 * c2, n2 * h2, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalPlainDateTime(e, t2, r2, o2) {
  const n2 = "since" === e ? -1 : 1, a2 = ToTemporalDateTime(r2), f2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(f2, GetSlot(a2, p), "compute difference between dates");
  const y2 = CopyOptions(o2), I2 = GetDifferenceSettings(e, y2, "datetime", [], "nanosecond", "day");
  let { years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = DifferenceISODateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, i), GetSlot(a2, s), GetSlot(a2, l), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), f2, I2.largestUnit, y2);
  const M2 = TemporalDateTimeToDate(t2);
  ({ years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = RoundDuration(S2, g2, w2, D2, G2, v2, C2, O2, b2, E2, I2.roundingIncrement, I2.smallestUnit, I2.roundingMode, M2)), { days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = BalanceDuration(D2, G2, v2, C2, O2, b2, E2, I2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, n2 * C2, n2 * O2, n2 * b2, n2 * E2);
}
function DifferenceTemporalPlainTime(e, t2, r2, o2) {
  const n2 = "since" === e ? -1 : 1, a2 = ToTemporalTime(r2), i2 = GetDifferenceSettings(e, CopyOptions(o2), "time", [], "nanosecond", "hour");
  let { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = DifferenceTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T));
  ({ hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = RoundDuration(0, 0, 0, 0, s2, l2, p2, f2, y2, I2, i2.roundingIncrement, i2.smallestUnit, i2.roundingMode)), { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = BalanceDuration(0, s2, l2, p2, f2, y2, I2, i2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, n2 * s2, n2 * l2, n2 * p2, n2 * f2, n2 * y2, n2 * I2);
}
function DifferenceTemporalPlainYearMonth(e, t2, r2, o2) {
  const n2 = "since" === e ? -1 : 1, a2 = ToTemporalYearMonth(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between months");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e, s2, "date", ["week", "day"], "month", "year");
  s2.largestUnit = l2.largestUnit;
  const d2 = CalendarFields(i2, ["monthCode", "year"]), m2 = PrepareTemporalFields(t2, d2, []);
  m2.day = 1;
  const c2 = CalendarDateFromFields(i2, m2), h2 = PrepareTemporalFields(a2, d2, []);
  h2.day = 1;
  const u2 = CalendarDateFromFields(i2, h2);
  let { years: T2, months: f2 } = CalendarDateUntil(i2, c2, u2, s2);
  "month" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: T2, months: f2 } = RoundDuration(T2, f2, 0, 0, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, c2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * T2, n2 * f2, 0, 0, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalZonedDateTime(e, t2, r2, o2) {
  const a2 = "since" === e ? -1 : 1, i2 = ToTemporalZonedDateTime(r2), s2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(s2, GetSlot(i2, p), "compute difference between dates");
  const l2 = CopyOptions(o2), d2 = GetDifferenceSettings(e, l2, "datetime", [], "nanosecond", "hour");
  l2.largestUnit = d2.largestUnit;
  const m2 = GetSlot(t2, n), c2 = GetSlot(i2, n);
  let h2, u2, T2, f2, y2, I2, S2, w2, D2, G2;
  if ("year" !== d2.largestUnit && "month" !== d2.largestUnit && "week" !== d2.largestUnit && "day" !== d2.largestUnit) h2 = 0, u2 = 0, T2 = 0, f2 = 0, { hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceInstant(m2, c2, d2.roundingIncrement, d2.smallestUnit, d2.largestUnit, d2.roundingMode);
  else {
    const e2 = GetSlot(t2, g);
    if (!TimeZoneEquals(e2, GetSlot(i2, g))) throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
    ({ years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceZonedDateTime(m2, c2, e2, s2, d2.largestUnit, l2)), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = RoundDuration(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = AdjustRoundedDurationDays(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2);
  }
  return new (GetIntrinsic("%Temporal.Duration%"))(a2 * h2, a2 * u2, a2 * T2, a2 * f2, a2 * y2, a2 * I2, a2 * S2, a2 * w2, a2 * D2, a2 * G2);
}
function AddISODate(e, t2, r2, o2, n2, a2, i2, s2) {
  let l2 = e, d2 = t2, m2 = r2, c2 = a2, h2 = i2;
  return l2 += o2, d2 += n2, { year: l2, month: d2 } = BalanceISOYearMonth(l2, d2), { year: l2, month: d2, day: m2 } = RegulateISODate(l2, d2, m2, s2), h2 += 7 * c2, m2 += h2, { year: l2, month: d2, day: m2 } = BalanceISODate(l2, d2, m2), { year: l2, month: d2, day: m2 };
}
function AddTime(e, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = e, u2 = t2, T2 = r2, p2 = o2, f2 = n2, y2 = a2;
  h2 += i2, u2 += s2, T2 += l2, p2 += d2, f2 += m2, y2 += c2;
  let I2 = 0;
  return { deltaDays: I2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), { deltaDays: I2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 };
}
function AddDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2, C2) {
  const O2 = LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), DefaultTemporalLargestUnit(h2, u2, T2, f2, y2, I2, w2, D2, G2, v2));
  let b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2;
  if (C2) if (IsTemporalDate(C2)) {
    const n2 = GetIntrinsic("%Temporal.Duration%"), S2 = GetSlot(C2, p), g2 = new n2(t2, r2, o2, a2, 0, 0, 0, 0, 0, 0), j2 = new n2(h2, u2, T2, f2, 0, 0, 0, 0, 0, 0), $2 = "string" != typeof S2 ? GetMethod(S2, "dateAdd") : void 0, k2 = CalendarDateAdd(S2, C2, g2, void 0, $2), U2 = CalendarDateAdd(S2, k2, j2, void 0, $2), A2 = LargerOfTwoTemporalUnits("day", O2), L2 = Te(null);
    L2.largestUnit = A2, { years: b2, months: E2, weeks: M2, days: R2 } = CalendarDateUntil(S2, C2, U2, L2), { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(R2, jsbi_default.add(jsbi_default.BigInt(i2), jsbi_default.BigInt(y2)), jsbi_default.add(jsbi_default.BigInt(s2), jsbi_default.BigInt(I2)), jsbi_default.add(jsbi_default.BigInt(l2), jsbi_default.BigInt(w2)), jsbi_default.add(jsbi_default.BigInt(d2), jsbi_default.BigInt(D2)), jsbi_default.add(jsbi_default.BigInt(m2), jsbi_default.BigInt(G2)), jsbi_default.add(jsbi_default.BigInt(c2), jsbi_default.BigInt(v2)), O2);
  } else {
    const e = GetIntrinsic("%Temporal.Instant%"), j2 = GetSlot(C2, g), $2 = GetSlot(C2, p), k2 = AddZonedDateTime(GetSlot(C2, S), j2, $2, t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), U2 = AddZonedDateTime(new e(k2), j2, $2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2);
    "year" !== O2 && "month" !== O2 && "week" !== O2 && "day" !== O2 ? (b2 = 0, E2 = 0, M2 = 0, R2 = 0, { hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceInstant(GetSlot(C2, n), U2, 1, "nanosecond", O2, "halfExpand")) : { years: b2, months: E2, weeks: M2, days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceZonedDateTime(GetSlot(C2, n), U2, j2, $2, O2, Te(null));
  }
  else {
    if ("year" === O2 || "month" === O2 || "week" === O2) throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
    b2 = E2 = M2 = 0, { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(a2 + f2, jsbi_default.add(jsbi_default.BigInt(i2), jsbi_default.BigInt(y2)), jsbi_default.add(jsbi_default.BigInt(s2), jsbi_default.BigInt(I2)), jsbi_default.add(jsbi_default.BigInt(l2), jsbi_default.BigInt(w2)), jsbi_default.add(jsbi_default.BigInt(d2), jsbi_default.BigInt(D2)), jsbi_default.add(jsbi_default.BigInt(m2), jsbi_default.BigInt(G2)), jsbi_default.add(jsbi_default.BigInt(c2), jsbi_default.BigInt(v2)), O2);
  }
  return RejectDuration(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2), { years: b2, months: E2, weeks: M2, days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 };
}
function AddInstant(t2, r2, o2, n2, a2, i2, s2) {
  let l2 = Ie;
  l2 = jsbi_default.add(l2, jsbi_default.BigInt(s2)), l2 = jsbi_default.add(l2, jsbi_default.multiply(jsbi_default.BigInt(i2), De)), l2 = jsbi_default.add(l2, jsbi_default.multiply(jsbi_default.BigInt(a2), Ge)), l2 = jsbi_default.add(l2, jsbi_default.multiply(jsbi_default.BigInt(n2), ve)), l2 = jsbi_default.add(l2, jsbi_default.multiply(jsbi_default.BigInt(o2), jsbi_default.BigInt(6e10))), l2 = jsbi_default.add(l2, jsbi_default.multiply(jsbi_default.BigInt(r2), jsbi_default.BigInt(36e11)));
  const d2 = jsbi_default.add(t2, l2);
  return ValidateEpochNanoseconds(d2), d2;
}
function AddDateTime(e, t2, r2, o2, n2, a2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  let v2 = f2, { deltaDays: C2, hour: O2, minute: b2, second: E2, millisecond: M2, microsecond: R2, nanosecond: F2 } = AddTime(o2, n2, a2, d2, m2, c2, y2, I2, S2, g2, w2, D2);
  v2 += C2;
  const Y2 = GetIntrinsic("%Temporal.Duration%"), P2 = CalendarDateAdd(h2, CreateTemporalDate(e, t2, r2, h2), new Y2(u2, T2, p2, v2, 0, 0, 0, 0, 0, 0), G2);
  return { year: GetSlot(P2, i), month: GetSlot(P2, s), day: GetSlot(P2, l), hour: O2, minute: b2, second: E2, millisecond: M2, microsecond: R2, nanosecond: F2 };
}
function AddZonedDateTime(e, t2, r2, o2, a2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  const v2 = GetIntrinsic("%Temporal.Duration%");
  if (0 === DurationSign(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0)) return AddInstant(GetSlot(e, n), y2, I2, S2, g2, w2, D2);
  const C2 = GetPlainDateTimeFor(t2, e, r2), O2 = CalendarDateAdd(r2, CreateTemporalDate(GetSlot(C2, i), GetSlot(C2, s), GetSlot(C2, l), r2), new v2(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0), G2), b2 = CreateTemporalDateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(C2, d), GetSlot(C2, m), GetSlot(C2, c), GetSlot(C2, h), GetSlot(C2, u), GetSlot(C2, T), r2);
  return AddInstant(GetSlot(GetInstantFor(t2, b2, "compatible"), n), y2, I2, S2, g2, w2, D2);
}
function AddDurationToOrSubtractDurationFromDuration(e, t2, r2, o2) {
  const n2 = "subtract" === e ? -1 : 1;
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2);
  const p2 = ToRelativeTemporalObject(GetOptionsObject(o2));
  ({ years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = AddDuration(GetSlot(t2, w), GetSlot(t2, D), GetSlot(t2, G), GetSlot(t2, v), GetSlot(t2, C), GetSlot(t2, O), GetSlot(t2, b), GetSlot(t2, E), GetSlot(t2, M), GetSlot(t2, R), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, p2));
  return new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, d2, m2, c2, h2, u2, T2);
}
function AddDurationToOrSubtractDurationFromInstant(e, t2, r2) {
  const o2 = "subtract" === e ? -1 : 1, { hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = function ToLimitedTemporalDuration(e2, t3) {
    let r3 = ToTemporalDurationRecord(e2);
    for (const e3 of t3) if (0 !== r3[e3]) throw new RangeError(`Duration field ${e3} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
    return r3;
  }(r2, ["years", "months", "weeks", "days"]), c2 = AddInstant(GetSlot(t2, n), o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * d2, o2 * m2);
  return new (GetIntrinsic("%Temporal.Instant%"))(c2);
}
function AddDurationToOrSubtractDurationFromPlainDateTime(e, t2, r2, o2) {
  const n2 = "subtract" === e ? -1 : 1, { years: a2, months: f2, weeks: y2, days: I2, hours: S2, minutes: g2, seconds: w2, milliseconds: D2, microseconds: G2, nanoseconds: v2 } = ToTemporalDurationRecord(r2), C2 = GetOptionsObject(o2), O2 = GetSlot(t2, p), { year: b2, month: E2, day: M2, hour: R2, minute: F2, second: Y2, millisecond: P2, microsecond: Z2, nanosecond: B2 } = AddDateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), O2, n2 * a2, n2 * f2, n2 * y2, n2 * I2, n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, C2);
  return CreateTemporalDateTime(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, O2);
}
function AddDurationToOrSubtractDurationFromPlainTime(e, t2, r2) {
  const o2 = "subtract" === e ? -1 : 1, { hours: n2, minutes: a2, seconds: i2, milliseconds: s2, microseconds: l2, nanoseconds: p2 } = ToTemporalDurationRecord(r2);
  let { hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = AddTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), o2 * n2, o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * p2);
  ({ hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = RegulateTime(f2, y2, I2, S2, g2, w2, "reject"));
  return new (GetIntrinsic("%Temporal.PlainTime%"))(f2, y2, I2, S2, g2, w2);
}
function AddDurationToOrSubtractDurationFromPlainYearMonth(e, t2, r2, o2) {
  let n2 = ToTemporalDurationRecord(r2);
  "subtract" === e && (n2 = { years: -n2.years, months: -n2.months, weeks: -n2.weeks, days: -n2.days, hours: -n2.hours, minutes: -n2.minutes, seconds: -n2.seconds, milliseconds: -n2.milliseconds, microseconds: -n2.microseconds, nanoseconds: -n2.nanoseconds });
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = n2;
  ({ days: l2 } = BalanceDuration(l2, d2, m2, c2, h2, u2, T2, "day"));
  const f2 = GetOptionsObject(o2), y2 = GetSlot(t2, p), I2 = CalendarFields(y2, ["monthCode", "year"]), S2 = PrepareTemporalFields(t2, I2, []), g2 = Te(null);
  CopyDataProperties(g2, S2, []), S2.day = 1;
  let w2 = CalendarDateFromFields(y2, S2);
  const D2 = DurationSign(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), G2 = GetMethod(y2, "dateAdd"), v2 = GetIntrinsic("%Temporal.Duration%");
  if (D2 < 0) {
    const e2 = CalendarDateAdd(y2, w2, new v2(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G2), t3 = CalendarDateAdd(y2, e2, new v2(0, 0, 0, -1, 0, 0, 0, 0, 0, 0), void 0, G2);
    g2.day = CalendarDay(y2, t3), w2 = CalendarDateFromFields(y2, g2);
  }
  const C2 = new v2(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), O2 = CopyOptions(f2);
  return CalendarYearMonthFromFields(y2, PrepareTemporalFields(CalendarDateAdd(y2, w2, C2, f2, G2), I2, []), O2);
}
function AddDurationToOrSubtractDurationFromZonedDateTime(e, t2, r2, o2) {
  const n2 = "subtract" === e ? -1 : 1, { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2), f2 = GetOptionsObject(o2), y2 = GetSlot(t2, g), I2 = GetSlot(t2, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(t2, S), y2, I2, n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, f2), y2, I2);
}
function RoundNumberToIncrement(t2, r2, o2) {
  if (jsbi_default.equal(r2, Se)) return t2;
  let { quotient: n2, remainder: a2 } = divmod(t2, r2);
  if (jsbi_default.equal(a2, Ie)) return t2;
  const i2 = jsbi_default.lessThan(a2, Ie) ? -1 : 1, s2 = abs(jsbi_default.multiply(a2, jsbi_default.BigInt(2))), l2 = jsbi_default.equal(s2, r2), d2 = jsbi_default.greaterThan(s2, r2);
  switch (o2) {
    case "ceil":
      i2 > 0 && (n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2)));
      break;
    case "floor":
      i2 < 0 && (n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2)));
      break;
    case "expand":
      n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2));
      break;
    case "trunc":
      break;
    case "halfCeil":
      (d2 || l2 && i2 > 0) && (n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2)));
      break;
    case "halfFloor":
      (d2 || l2 && i2 < 0) && (n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2)));
      break;
    case "halfExpand":
      (d2 || l2) && (n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2)));
      break;
    case "halfTrunc":
      d2 && (n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2)));
      break;
    case "halfEven":
      (d2 || l2 && 1 === jsbi_default.toNumber(jsbi_default.remainder(abs(n2), jsbi_default.BigInt(2)))) && (n2 = jsbi_default.add(n2, jsbi_default.BigInt(i2)));
  }
  return jsbi_default.multiply(n2, r2);
}
function RoundInstant(t2, r2, o2, n2) {
  let { remainder: a2 } = NonNegativeBigIntDivmod(t2, Ee);
  const i2 = jsbi_default.subtract(t2, a2), s2 = RoundNumberToIncrement(a2, jsbi_default.BigInt(_e[o2] * r2), n2);
  return jsbi_default.add(i2, s2);
}
function RoundISODateTime(e, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2 = 864e11) {
  const { deltaDays: u2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: I2, nanosecond: S2 } = RoundTime(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { year: g2, month: w2, day: D2 } = BalanceISODate(e, t2, r2 + u2);
  return { year: g2, month: w2, day: D2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: I2, nanosecond: S2 };
}
function RoundTime(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2 = 864e11) {
  let c2 = Ie;
  switch (l2) {
    case "day":
    case "hour":
      c2 = jsbi_default.BigInt(t2);
    case "minute":
      c2 = jsbi_default.add(jsbi_default.multiply(c2, ge), jsbi_default.BigInt(r2));
    case "second":
      c2 = jsbi_default.add(jsbi_default.multiply(c2, ge), jsbi_default.BigInt(o2));
    case "millisecond":
      c2 = jsbi_default.add(jsbi_default.multiply(c2, De), jsbi_default.BigInt(n2));
    case "microsecond":
      c2 = jsbi_default.add(jsbi_default.multiply(c2, De), jsbi_default.BigInt(a2));
    case "nanosecond":
      c2 = jsbi_default.add(jsbi_default.multiply(c2, De), jsbi_default.BigInt(i2));
  }
  const h2 = "day" === l2 ? m2 : _e[l2], u2 = RoundNumberToIncrement(c2, jsbi_default.BigInt(h2 * s2), d2), T2 = jsbi_default.toNumber(jsbi_default.divide(u2, jsbi_default.BigInt(h2)));
  switch (l2) {
    case "day":
      return { deltaDays: T2, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };
    case "hour":
      return BalanceTime(T2, 0, 0, 0, 0, 0);
    case "minute":
      return BalanceTime(t2, T2, 0, 0, 0, 0);
    case "second":
      return BalanceTime(t2, r2, T2, 0, 0, 0);
    case "millisecond":
      return BalanceTime(t2, r2, o2, T2, 0, 0);
    case "microsecond":
      return BalanceTime(t2, r2, o2, n2, T2, 0);
    case "nanosecond":
      return BalanceTime(t2, r2, o2, n2, a2, T2);
    default:
      throw new Error(`Invalid unit ${l2}`);
  }
}
function DaysUntil(e, t2) {
  return DifferenceISODate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), "day").days;
}
function MoveRelativeDate(e, t2, r2, o2) {
  const n2 = CalendarDateAdd(e, t2, r2, void 0, o2);
  return { relativeTo: n2, days: DaysUntil(t2, n2) };
}
function MoveRelativeZonedDateTime(e, t2, r2, o2, n2) {
  const a2 = GetSlot(e, g), i2 = GetSlot(e, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(e, S), a2, i2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0), a2, i2);
}
function AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, w2 = n2, D2 = a2, G2 = i2, v2 = s2, C2 = l2, O2 = d2, b2 = m2;
  if (!IsTemporalZonedDateTime(T2) || "year" === h2 || "month" === h2 || "week" === h2 || "day" === h2 || "nanosecond" === h2 && 1 === c2) return { years: f2, months: y2, weeks: I2, days: w2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
  let E2 = TotalDurationNanoseconds(0, D2, G2, v2, C2, O2, b2, 0);
  const M2 = se(jsbi_default.toNumber(E2)), R2 = GetSlot(T2, g), F2 = GetSlot(T2, p), Y2 = AddZonedDateTime(GetSlot(T2, S), R2, F2, f2, y2, I2, w2, 0, 0, 0, 0, 0, 0), P2 = AddZonedDateTime(new (GetIntrinsic("%Temporal.Instant%"))(Y2), R2, F2, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0), Z2 = jsbi_default.subtract(P2, Y2);
  return jsbi_default.greaterThanOrEqual(jsbi_default.multiply(jsbi_default.subtract(E2, Z2), jsbi_default.BigInt(M2)), Ie) && ({ years: f2, months: y2, weeks: I2, days: w2 } = AddDuration(f2, y2, I2, w2, 0, 0, 0, 0, 0, 0, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0, T2), E2 = RoundInstant(jsbi_default.subtract(E2, Z2), c2, h2, u2), { hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 } = BalanceDuration(0, 0, 0, 0, 0, 0, jsbi_default.toNumber(E2), "hour")), { years: f2, months: y2, weeks: I2, days: w2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
}
function RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, S2 = n2, g2 = a2, w2 = i2, D2 = s2, G2 = l2, v2 = d2, C2 = jsbi_default.BigInt(m2);
  const O2 = GetIntrinsic("%Temporal.Duration%");
  let b2, E2, M2, R2, F2 = T2;
  if (F2) {
    if (IsTemporalZonedDateTime(F2)) E2 = F2, F2 = ToTemporalDate(F2);
    else if (!IsTemporalDate(F2)) throw new TypeError("starting point must be PlainDate or ZonedDateTime");
    b2 = GetSlot(F2, p);
  }
  if ("year" === h2 || "month" === h2 || "week" === h2 || "day" === h2) {
    let t3, r3, o3;
    C2 = TotalDurationNanoseconds(0, g2, w2, D2, G2, v2, m2, 0), E2 && (t3 = MoveRelativeZonedDateTime(E2, f2, y2, I2, S2)), { days: r3, nanoseconds: C2, dayLengthNs: o3 } = NanosecondsToDays(C2, t3), M2 = jsbi_default.BigInt(o3), S2 += r3, g2 = w2 = D2 = G2 = v2 = 0;
  }
  switch (h2) {
    case "year": {
      if (!b2) throw new RangeError("A starting point is required for years rounding");
      const t3 = new O2(f2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = CalendarDateAdd(b2, F2, new O2(0, 0, 0, S2), void 0, r3), i3 = Te(null);
      i3.largestUnit = "year";
      const s3 = CalendarDateUntil(b2, F2, a3, i3).years;
      f2 += s3;
      const l3 = F2;
      F2 = CalendarDateAdd(b2, F2, new O2(s3), void 0, r3);
      S2 -= DaysUntil(l3, F2);
      const d3 = new O2(S2 < 0 ? -1 : 1);
      let { days: m3 } = MoveRelativeDate(b2, F2, d3, r3);
      m3 = ae(m3);
      const h3 = jsbi_default.multiply(jsbi_default.BigInt(m3), M2);
      C2 = jsbi_default.add(jsbi_default.add(jsbi_default.multiply(h3, jsbi_default.BigInt(f2)), jsbi_default.multiply(jsbi_default.BigInt(S2), M2)), C2);
      const T3 = RoundNumberToIncrement(C2, jsbi_default.multiply(h3, jsbi_default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, h3), f2 = jsbi_default.toNumber(jsbi_default.divide(T3, h3)), C2 = Ie, y2 = I2 = S2 = 0;
      break;
    }
    case "month": {
      if (!b2) throw new RangeError("A starting point is required for months rounding");
      const t3 = new O2(f2, y2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = se(S2), i3 = new O2(0, S2 < 0 ? -1 : 1);
      let s3;
      for ({ relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3); ae(S2) >= ae(s3); ) y2 += a3, S2 -= s3, { relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3);
      s3 = ae(s3);
      const l3 = jsbi_default.multiply(jsbi_default.BigInt(s3), M2);
      C2 = jsbi_default.add(jsbi_default.add(jsbi_default.multiply(l3, jsbi_default.BigInt(y2)), jsbi_default.multiply(jsbi_default.BigInt(S2), M2)), C2);
      const d3 = RoundNumberToIncrement(C2, jsbi_default.multiply(l3, jsbi_default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, l3), y2 = jsbi_default.toNumber(jsbi_default.divide(d3, l3)), C2 = Ie, I2 = S2 = 0;
      break;
    }
    case "week": {
      if (!b2) throw new RangeError("A starting point is required for weeks rounding");
      const t3 = se(S2), r3 = new O2(0, 0, S2 < 0 ? -1 : 1), o3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0;
      let n3;
      for ({ relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3); ae(S2) >= ae(n3); ) I2 += t3, S2 -= n3, { relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3);
      n3 = ae(n3);
      const a3 = jsbi_default.multiply(jsbi_default.BigInt(n3), M2);
      C2 = jsbi_default.add(jsbi_default.add(jsbi_default.multiply(a3, jsbi_default.BigInt(I2)), jsbi_default.multiply(jsbi_default.BigInt(S2), M2)), C2);
      const i3 = RoundNumberToIncrement(C2, jsbi_default.multiply(a3, jsbi_default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, a3), I2 = jsbi_default.toNumber(jsbi_default.divide(i3, a3)), C2 = Ie, S2 = 0;
      break;
    }
    case "day": {
      const t3 = M2;
      C2 = jsbi_default.add(jsbi_default.multiply(t3, jsbi_default.BigInt(S2)), C2);
      const r3 = RoundNumberToIncrement(C2, jsbi_default.multiply(t3, jsbi_default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, t3), S2 = jsbi_default.toNumber(jsbi_default.divide(r3, t3)), C2 = Ie;
      break;
    }
    case "hour": {
      const t3 = 36e11;
      let r3 = jsbi_default.multiply(jsbi_default.BigInt(g2), jsbi_default.BigInt(36e11));
      r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(w2), jsbi_default.BigInt(6e10))), r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(D2), ve)), r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(G2), Ge)), r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(v2), De)), r3 = jsbi_default.add(r3, C2), R2 = BigIntDivideToNumber(r3, jsbi_default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, jsbi_default.BigInt(t3 * c2), u2);
      g2 = jsbi_default.toNumber(jsbi_default.divide(o3, jsbi_default.BigInt(t3))), C2 = Ie, w2 = D2 = G2 = v2 = 0;
      break;
    }
    case "minute": {
      const t3 = 6e10;
      let r3 = jsbi_default.multiply(jsbi_default.BigInt(w2), jsbi_default.BigInt(6e10));
      r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(D2), ve)), r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(G2), Ge)), r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(v2), De)), r3 = jsbi_default.add(r3, C2), R2 = BigIntDivideToNumber(r3, jsbi_default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, jsbi_default.BigInt(t3 * c2), u2);
      w2 = jsbi_default.toNumber(jsbi_default.divide(o3, jsbi_default.BigInt(t3))), C2 = Ie, D2 = G2 = v2 = 0;
      break;
    }
    case "second": {
      const t3 = 1e9;
      let r3 = jsbi_default.multiply(jsbi_default.BigInt(D2), ve);
      r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(G2), Ge)), r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(v2), De)), r3 = jsbi_default.add(r3, C2), R2 = BigIntDivideToNumber(r3, jsbi_default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, jsbi_default.BigInt(t3 * c2), u2);
      D2 = jsbi_default.toNumber(jsbi_default.divide(o3, jsbi_default.BigInt(t3))), C2 = Ie, G2 = v2 = 0;
      break;
    }
    case "millisecond": {
      const t3 = 1e6;
      let r3 = jsbi_default.multiply(jsbi_default.BigInt(G2), Ge);
      r3 = jsbi_default.add(r3, jsbi_default.multiply(jsbi_default.BigInt(v2), De)), r3 = jsbi_default.add(r3, C2), R2 = BigIntDivideToNumber(r3, jsbi_default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, jsbi_default.BigInt(t3 * c2), u2);
      G2 = jsbi_default.toNumber(jsbi_default.divide(o3, jsbi_default.BigInt(t3))), C2 = Ie, v2 = 0;
      break;
    }
    case "microsecond": {
      const t3 = 1e3;
      let r3 = jsbi_default.multiply(jsbi_default.BigInt(v2), De);
      r3 = jsbi_default.add(r3, C2), R2 = BigIntDivideToNumber(r3, jsbi_default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, jsbi_default.BigInt(t3 * c2), u2);
      v2 = jsbi_default.toNumber(jsbi_default.divide(o3, jsbi_default.BigInt(t3))), C2 = Ie;
      break;
    }
    case "nanosecond":
      R2 = jsbi_default.toNumber(C2), C2 = RoundNumberToIncrement(jsbi_default.BigInt(C2), jsbi_default.BigInt(c2), u2);
  }
  return { years: f2, months: y2, weeks: I2, days: S2, hours: g2, minutes: w2, seconds: D2, milliseconds: G2, microseconds: v2, nanoseconds: jsbi_default.toNumber(C2), total: R2 };
}
function CompareISODate(e, t2, r2, o2, n2, a2) {
  for (const [i2, s2] of [[e, o2], [t2, n2], [r2, a2]]) if (i2 !== s2) return ComparisonResult(i2 - s2);
  return 0;
}
function NonNegativeBigIntDivmod(t2, r2) {
  let { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return jsbi_default.lessThan(n2, Ie) && (o2 = jsbi_default.subtract(o2, Se), n2 = jsbi_default.add(n2, r2)), { quotient: o2, remainder: n2 };
}
function BigIntFloorDiv(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return isZero(n2) || !isNegativeJSBI(t2) == !isNegativeJSBI(r2) ? o2 : jsbi_default.subtract(o2, Se);
}
function BigIntDivideToNumber(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return jsbi_default.toNumber(o2) + jsbi_default.toNumber(n2) / jsbi_default.toNumber(r2);
}
function ToBigIntExternal(e) {
  const t2 = ToBigInt(e);
  return void 0 !== globalThis.BigInt ? globalThis.BigInt(t2.toString(10)) : t2;
}
function ToBigInt(t2) {
  let r2 = t2;
  if ("object" == typeof t2) {
    const e = t2[Symbol.toPrimitive];
    e && "function" == typeof e && (r2 = fe(e, t2, ["number"]));
  }
  if ("number" == typeof r2) throw new TypeError("cannot convert number to bigint");
  return "bigint" == typeof r2 ? jsbi_default.BigInt(r2.toString(10)) : jsbi_default.BigInt(r2);
}
var Ve = (() => {
  let t2 = jsbi_default.BigInt(Date.now() % 1e6);
  return () => {
    const r2 = jsbi_default.BigInt(Date.now()), o2 = jsbi_default.add(jsbi_default.multiply(r2, Ge), t2);
    return t2 = jsbi_default.remainder(r2, Ge), jsbi_default.greaterThan(o2, Re) ? Re : jsbi_default.lessThan(o2, Me) ? Me : o2;
  };
})();
function DefaultTimeZone() {
  return new re().resolvedOptions().timeZone;
}
function ComparisonResult(e) {
  return e < 0 ? -1 : e > 0 ? 1 : e;
}
function GetOptionsObject(e) {
  if (void 0 === e) return Te(null);
  if (IsObject(e) && null !== e) return e;
  throw new TypeError("Options parameter must be an object, not " + (null === e ? "null" : typeof e));
}
function CreateOnePropObject(e, t2) {
  const r2 = Te(null);
  return r2[e] = t2, r2;
}
function CopyOptions(e) {
  const t2 = Te(null);
  return CopyDataProperties(t2, GetOptionsObject(e), []), t2;
}
function GetOption(e, t2, r2, o2) {
  let n2 = e[t2];
  if (void 0 !== n2) {
    if (n2 = ToString(n2), !r2.includes(n2)) throw new RangeError(`${t2} must be one of ${r2.join(", ")}, not ${n2}`);
    return n2;
  }
  return o2;
}
function IsBuiltinCalendar(e) {
  return je.includes(ASCIILowercase(e));
}
function ASCIILowercase(e) {
  return e.replace(/[A-Z]/g, (e2) => {
    const t2 = e2.charCodeAt(0);
    return String.fromCharCode(t2 + 32);
  });
}
var ze = new RegExp(`^${W.source}$`);
function bisect(t2, r2, o2, n2 = t2(r2), a2 = t2(o2)) {
  let i2 = jsbi_default.BigInt(r2), s2 = jsbi_default.BigInt(o2), l2 = n2, d2 = a2;
  for (; jsbi_default.greaterThan(jsbi_default.subtract(s2, i2), Se); ) {
    const r3 = jsbi_default.divide(jsbi_default.add(i2, s2), jsbi_default.BigInt(2)), o3 = t2(r3);
    if (o3 === l2) i2 = r3, l2 = o3;
    else {
      if (o3 !== d2) throw new Error(`invalid state in bisection ${l2} - ${o3} - ${d2}`);
      s2 = r3, d2 = o3;
    }
  }
  return s2;
}
var _e = { hour: 36e11, minute: 6e10, second: 1e9, millisecond: 1e6, microsecond: 1e3, nanosecond: 1 };
var Je = Symbol("date");
var Ke = Symbol("ym");
var Xe = Symbol("md");
var Qe = Symbol("time");
var et = Symbol("datetime");
var tt = Symbol("instant");
var rt = Symbol("original");
var ot = Symbol("timezone");
var nt = Symbol("calendar-id");
var at = Symbol("locale");
var it = Symbol("options");
var descriptor = (e) => ({ value: e, enumerable: true, writable: false, configurable: true });
var st = globalThis.Intl.DateTimeFormat;
var lt = Object.assign;
var dt = Object.prototype.hasOwnProperty;
var mt = Reflect.apply;
function getPropLazy(e, t2) {
  let r2 = e[t2];
  return "function" == typeof r2 && (r2 = new st(e[at], r2(e[it])), e[t2] = r2), r2;
}
function DateTimeFormatImpl(e, t2 = {}) {
  if (!(this instanceof DateTimeFormatImpl)) return new DateTimeFormatImpl(e, t2);
  const r2 = void 0 !== t2, o2 = r2 ? lt({}, t2) : {}, n2 = new st(e, o2), a2 = n2.resolvedOptions();
  if (r2) {
    const e2 = lt({}, a2);
    for (const t3 in e2) mt(dt, o2, [t3]) || delete e2[t3];
    this[it] = e2;
  } else this[it] = o2;
  this[at] = a2.locale, this[rt] = n2, this[ot] = a2.timeZone, this[nt] = a2.calendar, this[Je] = dateAmend, this[Ke] = yearMonthAmend, this[Xe] = monthDayAmend, this[Qe] = timeAmend, this[et] = datetimeAmend, this[tt] = instantAmend;
}
Object.defineProperty(DateTimeFormatImpl, "name", { writable: true, value: "DateTimeFormat" }), DateTimeFormatImpl.supportedLocalesOf = function(e, t2) {
  return st.supportedLocalesOf(e, t2);
};
var ct = { resolvedOptions: descriptor(function resolvedOptions() {
  return this[rt].resolvedOptions();
}), format: descriptor(function format(e, ...t2) {
  let { instant: r2, formatter: o2 } = extractOverrides(e, this);
  if (r2 && o2) return o2.format(r2.epochMilliseconds);
  return this[rt].format(e, ...t2);
}), formatRange: descriptor(function formatRange(e, t2) {
  if (isTemporalObject(e) || isTemporalObject(t2)) {
    if (!sameTemporalType(e, t2)) throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
    const { instant: r2, formatter: o2 } = extractOverrides(e, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
    if (r2 && n2 && o2 && a2 && o2 === a2) return o2.formatRange(r2.epochMilliseconds, n2.epochMilliseconds);
  }
  return this[rt].formatRange(e, t2);
}) };
"formatToParts" in st.prototype && (ct.formatToParts = descriptor(function formatToParts(e, ...t2) {
  let { instant: r2, formatter: o2 } = extractOverrides(e, this);
  if (r2 && o2) return o2.formatToParts(r2.epochMilliseconds);
  return this[rt].formatToParts(e, ...t2);
})), "formatRangeToParts" in st.prototype && (ct.formatRangeToParts = descriptor(function formatRangeToParts(e, t2) {
  if (isTemporalObject(e) || isTemporalObject(t2)) {
    if (!sameTemporalType(e, t2)) throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
    const { instant: r2, formatter: o2 } = extractOverrides(e, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
    if (r2 && n2 && o2 && a2 && o2 === a2) return o2.formatRangeToParts(r2.epochMilliseconds, n2.epochMilliseconds);
  }
  return this[rt].formatRangeToParts(e, t2);
})), DateTimeFormatImpl.prototype = Object.create(st.prototype, ct), Object.defineProperty(DateTimeFormatImpl, "prototype", { writable: false, enumerable: false, configurable: false });
var ht = DateTimeFormatImpl;
function amend(e = {}, t2 = {}) {
  const r2 = lt({}, e);
  for (const e2 of ["year", "month", "day", "hour", "minute", "second", "weekday", "dayPeriod", "timeZoneName", "dateStyle", "timeStyle"]) r2[e2] = e2 in t2 ? t2[e2] : r2[e2], false !== r2[e2] && void 0 !== r2[e2] || delete r2[e2];
  return r2;
}
function timeAmend(e) {
  let t2 = amend(e, { year: false, month: false, day: false, weekday: false, timeZoneName: false, dateStyle: false });
  return hasTimeOptions(t2) || (t2 = lt({}, t2, { hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function yearMonthAmend(e) {
  let t2 = amend(e, { day: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "year" in t2 || "month" in t2 || (t2 = lt(t2, { year: "numeric", month: "numeric" })), t2;
}
function monthDayAmend(e) {
  let t2 = amend(e, { year: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "month" in t2 || "day" in t2 || (t2 = lt({}, t2, { month: "numeric", day: "numeric" })), t2;
}
function dateAmend(e) {
  let t2 = amend(e, { hour: false, minute: false, second: false, dayPeriod: false, timeZoneName: false, timeStyle: false });
  return hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric" })), t2;
}
function datetimeAmend(e) {
  let t2 = amend(e, { timeZoneName: false });
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function instantAmend(e) {
  let t2 = e;
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function hasDateOptions(e) {
  return "year" in e || "month" in e || "day" in e || "weekday" in e || "dateStyle" in e;
}
function hasTimeOptions(e) {
  return "hour" in e || "minute" in e || "second" in e || "timeStyle" in e || "dayPeriod" in e;
}
function isTemporalObject(e) {
  return IsTemporalDate(e) || IsTemporalTime(e) || IsTemporalDateTime(e) || IsTemporalZonedDateTime(e) || IsTemporalYearMonth(e) || IsTemporalMonthDay(e) || IsTemporalInstant(e);
}
function sameTemporalType(e, t2) {
  return !(!isTemporalObject(e) || !isTemporalObject(t2)) && (!(IsTemporalTime(e) && !IsTemporalTime(t2)) && (!(IsTemporalDate(e) && !IsTemporalDate(t2)) && (!(IsTemporalDateTime(e) && !IsTemporalDateTime(t2)) && (!(IsTemporalZonedDateTime(e) && !IsTemporalZonedDateTime(t2)) && (!(IsTemporalYearMonth(e) && !IsTemporalYearMonth(t2)) && (!(IsTemporalMonthDay(e) && !IsTemporalMonthDay(t2)) && !(IsTemporalInstant(e) && !IsTemporalInstant(t2))))))));
}
function extractOverrides(e, t2) {
  const r2 = GetIntrinsic("%Temporal.PlainDateTime%");
  if (IsTemporalTime(e)) {
    const o2 = new r2(1970, 1, 1, GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T), t2[nt]);
    return { instant: GetInstantFor(t2[ot], o2, "compatible"), formatter: getPropLazy(t2, Qe) };
  }
  if (IsTemporalYearMonth(e)) {
    const o2 = GetSlot(e, i), n2 = GetSlot(e, s), a2 = GetSlot(e, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if (d2 !== t2[nt]) throw new RangeError(`cannot format PlainYearMonth with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Ke) };
  }
  if (IsTemporalMonthDay(e)) {
    const o2 = GetSlot(e, i), n2 = GetSlot(e, s), a2 = GetSlot(e, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if (d2 !== t2[nt]) throw new RangeError(`cannot format PlainMonthDay with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Xe) };
  }
  if (IsTemporalDate(e)) {
    const o2 = GetSlot(e, i), n2 = GetSlot(e, s), a2 = GetSlot(e, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if ("iso8601" !== d2 && d2 !== t2[nt]) throw new RangeError(`cannot format PlainDate with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, t2[nt]);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Je) };
  }
  if (IsTemporalDateTime(e)) {
    const o2 = GetSlot(e, i), n2 = GetSlot(e, s), a2 = GetSlot(e, l), f2 = GetSlot(e, d), y2 = GetSlot(e, m), I2 = GetSlot(e, c), S2 = GetSlot(e, h), g2 = GetSlot(e, u), w2 = GetSlot(e, T), D2 = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if ("iso8601" !== D2 && D2 !== t2[nt]) throw new RangeError(`cannot format PlainDateTime with calendar ${D2} in locale with calendar ${t2[nt]}`);
    let G2 = e;
    return "iso8601" === D2 && (G2 = new r2(o2, n2, a2, f2, y2, I2, S2, g2, w2, t2[nt])), { instant: GetInstantFor(t2[ot], G2, "compatible"), formatter: getPropLazy(t2, et) };
  }
  if (IsTemporalZonedDateTime(e)) throw new TypeError("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
  return IsTemporalInstant(e) ? { instant: e, formatter: getPropLazy(t2, tt) } : {};
}
var ut = Object.freeze({ __proto__: null, DateTimeFormat: ht });
var Instant = class _Instant {
  constructor(e) {
    if (arguments.length < 1) throw new TypeError("missing argument: epochNanoseconds is required");
    const t2 = ToBigInt(e);
    ValidateEpochNanoseconds(t2), N(this), SetSlot(this, n, t2);
  }
  get epochSeconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return jsbi_default.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = jsbi_default.BigInt(GetSlot(this, n));
    return jsbi_default.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(jsbi_default.BigInt(GetSlot(this, n)), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(jsbi_default.BigInt(GetSlot(this, n)));
  }
  add(e) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("add", this, e);
  }
  subtract(e) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("subtract", this, e);
  }
  until(e, t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("until", this, e, t2);
  }
  since(e, t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("since", this, e, t2);
  }
  round(e) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    if (void 0 === e) throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e ? CreateOnePropObject("smallestUnit", e) : GetOptionsObject(e), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, { hour: 24, minute: 1440, second: 86400, millisecond: 864e5, microsecond: 864e8, nanosecond: 864e11 }[a2], true);
    const i2 = RoundInstant(GetSlot(this, n), r2, a2, o2);
    return new _Instant(i2);
  }
  equals(t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalInstant(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return jsbi_default.equal(jsbi_default.BigInt(o2), jsbi_default.BigInt(a2));
  }
  toString(e) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    let i2 = t2.timeZone;
    void 0 !== i2 && (i2 = ToTemporalTimeZoneSlotValue(i2));
    const { precision: s2, unit: l2, increment: d2 } = ToSecondsStringPrecisionRecord(a2, r2), m2 = RoundInstant(GetSlot(this, n), d2, l2, o2);
    return TemporalInstantToString(new _Instant(m2), i2, s2);
  }
  toJSON() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return TemporalInstantToString(this, void 0, "auto");
  }
  toLocaleString(e, t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return new ht(e, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.Instant");
  }
  toZonedDateTime(e) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid argument in toZonedDateTime");
    const t2 = e.calendar;
    if (void 0 === t2) throw new TypeError("missing calendar property in toZonedDateTime");
    const r2 = ToTemporalCalendarSlotValue(t2), o2 = e.timeZone;
    if (void 0 === o2) throw new TypeError("missing timeZone property in toZonedDateTime");
    const a2 = ToTemporalTimeZoneSlotValue(o2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), a2, r2);
  }
  toZonedDateTimeISO(e) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, "iso8601");
  }
  static fromEpochSeconds(t2) {
    const r2 = ToNumber(t2), o2 = jsbi_default.multiply(jsbi_default.BigInt(r2), ve);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMilliseconds(t2) {
    const r2 = ToNumber(t2), o2 = jsbi_default.multiply(jsbi_default.BigInt(r2), Ge);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMicroseconds(t2) {
    const r2 = ToBigInt(t2), o2 = jsbi_default.multiply(r2, De);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochNanoseconds(e) {
    const t2 = ToBigInt(e);
    return ValidateEpochNanoseconds(t2), new _Instant(t2);
  }
  static from(e) {
    return IsTemporalInstant(e) ? new _Instant(GetSlot(e, n)) : ToTemporalInstant(e);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalInstant(t2), a2 = ToTemporalInstant(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return jsbi_default.lessThan(i2, s2) ? -1 : jsbi_default.greaterThan(i2, s2) ? 1 : 0;
  }
};
MakeIntrinsicClass(Instant, "Temporal.Instant");
var Tt = Array.prototype.includes;
var pt = Array.prototype.push;
var ft = globalThis.Intl.DateTimeFormat;
var yt = Array.prototype.sort;
var It = Math.abs;
var St = Math.floor;
var gt = Object.create;
var wt = Object.entries;
var Dt = Set;
var Gt = Reflect.ownKeys;
var vt = Set.prototype.add;
var Ct = Set.prototype.values;
var Ot = {};
var Calendar = class {
  constructor(e) {
    if (arguments.length < 1) throw new RangeError("missing argument: id is required");
    const t2 = ToString(e);
    if (!IsBuiltinCalendar(t2)) throw new RangeError(`invalid calendar identifier ${t2}`);
    N(this), SetSlot(this, F, ASCIILowercase(t2));
  }
  get id() {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  dateFromFields(e, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].dateFromFields(e, r2, o2);
  }
  yearMonthFromFields(e, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].yearMonthFromFields(e, r2, o2);
  }
  monthDayFromFields(e, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].monthDayFromFields(e, r2, o2);
  }
  fields(e) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = [], r2 = /* @__PURE__ */ new Set(["year", "month", "monthCode", "day", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"]);
    for (const o2 of e) {
      if ("string" != typeof o2) throw new TypeError("invalid fields");
      if (!r2.has(o2)) throw new RangeError(`invalid field name ${o2}`);
      r2.delete(o2), pt.call(t2, o2);
    }
    return Ot[GetSlot(this, F)].fields(t2);
  }
  mergeFields(e, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const r2 = ToObject(e), o2 = gt(null);
    CopyDataProperties(o2, r2, [], [void 0]);
    const n2 = ToObject(t2), a2 = gt(null);
    CopyDataProperties(a2, n2, [], [void 0]);
    const i2 = Gt(a2), s2 = Ot[GetSlot(this, F)].fieldKeysToIgnore(i2), l2 = gt(null), d2 = Gt(o2);
    for (const e2 of d2) {
      let t3;
      t3 = Call(Tt, s2, [e2]) ? a2[e2] : o2[e2], void 0 !== t3 && (l2[e2] = t3);
    }
    return CopyDataProperties(l2, a2, []), l2;
  }
  dateAdd(e, t2, r2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e), n2 = ToTemporalDuration(t2), a2 = ToTemporalOverflow(GetOptionsObject(r2)), { days: i2 } = BalanceDuration(GetSlot(n2, v), GetSlot(n2, C), GetSlot(n2, O), GetSlot(n2, b), GetSlot(n2, E), GetSlot(n2, M), GetSlot(n2, R), "day"), s2 = GetSlot(this, F);
    return Ot[s2].dateAdd(o2, GetSlot(n2, w), GetSlot(n2, D), GetSlot(n2, G), i2, a2, s2);
  }
  dateUntil(e, t2, r2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e), n2 = ToTemporalDate(t2);
    let a2 = GetTemporalUnit(GetOptionsObject(r2), "largestUnit", "date", "auto");
    "auto" === a2 && (a2 = "day");
    const { years: i2, months: s2, weeks: l2, days: d2 } = Ot[GetSlot(this, F)].dateUntil(o2, n2, a2);
    return new (GetIntrinsic("%Temporal.Duration%"))(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
  }
  year(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].year(t2);
  }
  month(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (IsTemporalMonthDay(t2)) throw new TypeError("use monthCode on PlainMonthDay instead");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].month(t2);
  }
  monthCode(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthCode(t2);
  }
  day(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].day(t2);
  }
  era(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].era(t2);
  }
  eraYear(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].eraYear(t2);
  }
  dayOfWeek(e) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e);
    return Ot[GetSlot(this, F)].dayOfWeek(t2);
  }
  dayOfYear(e) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e);
    return Ot[GetSlot(this, F)].dayOfYear(t2);
  }
  weekOfYear(e) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e);
    return Ot[GetSlot(this, F)].weekOfYear(t2);
  }
  yearOfWeek(e) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e);
    return Ot[GetSlot(this, F)].yearOfWeek(t2);
  }
  daysInWeek(e) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e);
    return Ot[GetSlot(this, F)].daysInWeek(t2);
  }
  daysInMonth(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInMonth(t2);
  }
  daysInYear(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInYear(t2);
  }
  monthsInYear(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthsInYear(t2);
  }
  inLeapYear(e) {
    let t2 = e;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].inLeapYear(t2);
  }
  toString() {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  toJSON() {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  static from(e) {
    return ToTemporalCalendarObject(ToTemporalCalendarSlotValue(e));
  }
};
function monthCodeNumberPart(e) {
  if (!e.startsWith("M")) throw new RangeError(`Invalid month code: ${e}.  Month codes must start with M.`);
  const t2 = +e.slice(1);
  if (isNaN(t2)) throw new RangeError(`Invalid month code: ${e}`);
  return t2;
}
function buildMonthCode(e, t2 = false) {
  return `M${e.toString().padStart(2, "0")}${t2 ? "L" : ""}`;
}
function resolveNonLunisolarMonth(e, t2, r2 = 12) {
  let { month: o2, monthCode: n2 } = e;
  if (void 0 === n2) {
    if (void 0 === o2) throw new TypeError("Either month or monthCode are required");
    "reject" === t2 && RejectToRange(o2, 1, r2), "constrain" === t2 && (o2 = ConstrainToRange(o2, 1, r2)), n2 = buildMonthCode(o2);
  } else {
    const e2 = monthCodeNumberPart(n2);
    if (void 0 !== o2 && o2 !== e2) throw new RangeError(`monthCode ${n2} and month ${o2} must match if both are present`);
    if (n2 !== buildMonthCode(e2)) throw new RangeError(`Invalid month code: ${n2}`);
    if (o2 = e2, o2 < 1 || o2 > r2) throw new RangeError(`Invalid monthCode: ${n2}`);
  }
  return { ...e, month: o2, monthCode: n2 };
}
MakeIntrinsicClass(Calendar, "Temporal.Calendar"), DefineIntrinsic("Temporal.Calendar.from", Calendar.from), DefineIntrinsic("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd), DefineIntrinsic("Temporal.Calendar.prototype.dateFromFields", Calendar.prototype.dateFromFields), DefineIntrinsic("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil), DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day), DefineIntrinsic("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek), DefineIntrinsic("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear), DefineIntrinsic("Temporal.Calendar.prototype.daysInMonth", Calendar.prototype.daysInMonth), DefineIntrinsic("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek), DefineIntrinsic("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear), DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era), DefineIntrinsic("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear), DefineIntrinsic("Temporal.Calendar.prototype.fields", Calendar.prototype.fields), DefineIntrinsic("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear), DefineIntrinsic("Temporal.Calendar.prototype.mergeFields", Calendar.prototype.mergeFields), DefineIntrinsic("Temporal.Calendar.prototype.month", Calendar.prototype.month), DefineIntrinsic("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode), DefineIntrinsic("Temporal.Calendar.prototype.monthDayFromFields", Calendar.prototype.monthDayFromFields), DefineIntrinsic("Temporal.Calendar.prototype.monthsInYear", Calendar.prototype.monthsInYear), DefineIntrinsic("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear), DefineIntrinsic("Temporal.Calendar.prototype.year", Calendar.prototype.year), DefineIntrinsic("Temporal.Calendar.prototype.yearMonthFromFields", Calendar.prototype.yearMonthFromFields), DefineIntrinsic("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek), Ot.iso8601 = { dateFromFields(e, t2, r2) {
  let o2 = PrepareTemporalFields(e, ["day", "month", "monthCode", "year"], ["year", "day"]);
  const n2 = ToTemporalOverflow(t2);
  o2 = resolveNonLunisolarMonth(o2);
  let { year: a2, month: i2, day: s2 } = o2;
  return { year: a2, month: i2, day: s2 } = RegulateISODate(a2, i2, s2, n2), CreateTemporalDate(a2, i2, s2, r2);
}, yearMonthFromFields(e, t2, r2) {
  let o2 = PrepareTemporalFields(e, ["month", "monthCode", "year"], ["year"]);
  const n2 = ToTemporalOverflow(t2);
  o2 = resolveNonLunisolarMonth(o2);
  let { year: a2, month: i2 } = o2;
  return { year: a2, month: i2 } = function RegulateISOYearMonth(e2, t3, r3) {
    let o3 = e2, n3 = t3;
    switch (r3) {
      case "reject":
        RejectISODate(o3, n3, 1);
        break;
      case "constrain":
        ({ year: o3, month: n3 } = ConstrainISODate(o3, n3));
    }
    return { year: o3, month: n3 };
  }(a2, i2, n2), CreateTemporalYearMonth(a2, i2, r2, 1);
}, monthDayFromFields(e, t2, r2) {
  let o2 = PrepareTemporalFields(e, ["day", "month", "monthCode", "year"], ["day"]);
  const n2 = ToTemporalOverflow(t2);
  if (void 0 !== o2.month && void 0 === o2.year && void 0 === o2.monthCode) throw new TypeError("either year or monthCode required with month");
  const a2 = void 0 === o2.monthCode;
  o2 = resolveNonLunisolarMonth(o2);
  let { month: i2, day: s2, year: l2 } = o2;
  return { month: i2, day: s2 } = RegulateISODate(a2 ? l2 : 1972, i2, s2, n2), CreateTemporalMonthDay(i2, s2, r2, 1972);
}, fields: (e) => e, fieldKeysToIgnore(e) {
  const t2 = new Dt();
  for (let r2 = 0; r2 < e.length; r2++) {
    const o2 = e[r2];
    Call(vt, t2, [o2]), "month" === o2 ? Call(vt, t2, ["monthCode"]) : "monthCode" === o2 && Call(vt, t2, ["month"]);
  }
  return [...Call(Ct, t2, [])];
}, dateAdd(e, t2, r2, o2, n2, a2, d2) {
  let m2 = GetSlot(e, i), c2 = GetSlot(e, s), h2 = GetSlot(e, l);
  return { year: m2, month: c2, day: h2 } = AddISODate(m2, c2, h2, t2, r2, o2, n2, a2), CreateTemporalDate(m2, c2, h2, d2);
}, dateUntil: (e, t2, r2) => DifferenceISODate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), r2), year: (e) => GetSlot(e, i), era() {
}, eraYear() {
}, month: (e) => GetSlot(e, s), monthCode: (e) => buildMonthCode(GetSlot(e, s)), day: (e) => GetSlot(e, l), dayOfWeek: (e) => DayOfWeek(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)), dayOfYear: (e) => DayOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)), weekOfYear: (e) => WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).week, yearOfWeek: (e) => WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).year, daysInWeek: () => 7, daysInMonth: (e) => ISODaysInMonth(GetSlot(e, i), GetSlot(e, s)), daysInYear(e) {
  let t2 = e;
  return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i)) ? 366 : 365;
}, monthsInYear: () => 12, inLeapYear(e) {
  let t2 = e;
  return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i));
} };
var OneObjectCache = class _OneObjectCache {
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e) {
      let t2 = 0;
      for (const r2 of e.map.entries()) {
        if (++t2 > _OneObjectCache.MAX_CACHE_ENTRIES) break;
        this.map.set(...r2);
      }
    }
  }
  get(e) {
    const t2 = this.map.get(e);
    return t2 && (this.hits++, this.report()), this.calls++, t2;
  }
  set(e, t2) {
    this.map.set(e, t2), this.misses++, this.report();
  }
  report() {
  }
  setObject(e) {
    if (_OneObjectCache.objectMap.get(e)) throw new RangeError("object already cached");
    _OneObjectCache.objectMap.set(e, this), this.report();
  }
  static getCacheForObject(e) {
    let t2 = _OneObjectCache.objectMap.get(e);
    return t2 || (t2 = new _OneObjectCache(), _OneObjectCache.objectMap.set(e, t2)), t2;
  }
};
function toUtcIsoDateString({ isoYear: e, isoMonth: t2, isoDay: r2 }) {
  return `${ISOYearString(e)}-${ISODateTimePartString(t2)}-${ISODateTimePartString(r2)}T00:00Z`;
}
function simpleDateDiff(e, t2) {
  return { years: e.year - t2.year, months: e.month - t2.month, days: e.day - t2.day };
}
OneObjectCache.objectMap = /* @__PURE__ */ new WeakMap(), OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
var HelperBase = class {
  constructor() {
    this.eraLength = "short", this.hasEra = true, this.erasBeginMidYear = false;
  }
  getFormatter() {
    return void 0 === this.formatter && (this.formatter = new ft(`en-US-u-ca-${this.id}`, { day: "numeric", month: "numeric", year: "numeric", era: this.eraLength, timeZone: "UTC" })), this.formatter;
  }
  isoToCalendarDate(e, t2) {
    const { year: r2, month: o2, day: n2 } = e, a2 = JSON.stringify({ func: "isoToCalendarDate", isoYear: r2, isoMonth: o2, isoDay: n2, id: this.id }), i2 = t2.get(a2);
    if (i2) return i2;
    const s2 = this.getFormatter();
    let l2, d2;
    try {
      d2 = toUtcIsoDateString({ isoYear: r2, isoMonth: o2, isoDay: n2 }), l2 = s2.formatToParts(new Date(d2));
    } catch (e2) {
      throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear: r2, isoMonth: o2, isoDay: n2 })}`);
    }
    const m2 = {};
    for (let { type: e2, value: t3 } of l2) {
      if ("year" === e2 && (m2.eraYear = +t3), "relatedYear" === e2 && (m2.eraYear = +t3), "month" === e2) {
        const e3 = /^([0-9]*)(.*?)$/.exec(t3);
        if (!e3 || 3 != e3.length || !e3[1] && !e3[2]) throw new RangeError(`Unexpected month: ${t3}`);
        if (m2.month = e3[1] ? +e3[1] : 1, m2.month < 1) throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
        if (m2.month > 13) throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
        e3[2] && (m2.monthExtra = e3[2]);
      }
      "day" === e2 && (m2.day = +t3), this.hasEra && "era" === e2 && null != t3 && "" !== t3 && (t3 = t3.split(" (")[0], m2.era = t3.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase());
    }
    if (void 0 === m2.eraYear) throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
    if (this.reviseIntlEra) {
      const { era: t3, eraYear: r3 } = this.reviseIntlEra(m2, e);
      m2.era = t3, m2.eraYear = r3;
    }
    this.checkIcuBugs && this.checkIcuBugs(e);
    const c2 = this.adjustCalendarDate(m2, t2, "constrain", true);
    if (void 0 === c2.year) throw new RangeError(`Missing year converting ${JSON.stringify(e)}`);
    if (void 0 === c2.month) throw new RangeError(`Missing month converting ${JSON.stringify(e)}`);
    if (void 0 === c2.day) throw new RangeError(`Missing day converting ${JSON.stringify(e)}`);
    return t2.set(a2, c2), ["constrain", "reject"].forEach((r3) => {
      const o3 = JSON.stringify({ func: "calendarToIsoDate", year: c2.year, month: c2.month, day: c2.day, overflow: r3, id: this.id });
      t2.set(o3, e);
    }), c2;
  }
  validateCalendarDate(e) {
    const { era: t2, month: r2, year: o2, day: n2, eraYear: a2, monthCode: i2, monthExtra: s2 } = e;
    if (void 0 !== s2) throw new RangeError("Unexpected `monthExtra` value");
    if (void 0 === o2 && void 0 === a2) throw new TypeError("year or eraYear is required");
    if (void 0 === r2 && void 0 === i2) throw new TypeError("month or monthCode is required");
    if (void 0 === n2) throw new RangeError("Missing day");
    if (void 0 !== i2) {
      if ("string" != typeof i2) throw new RangeError("monthCode must be a string, not " + typeof i2);
      if (!/^M([01]?\d)(L?)$/.test(i2)) throw new RangeError(`Invalid monthCode: ${i2}`);
    }
    if (this.constantEra) {
      if (void 0 !== t2 && t2 !== this.constantEra) throw new RangeError(`era must be ${this.constantEra}, not ${t2}`);
      if (void 0 !== a2 && void 0 !== o2 && a2 !== o2) throw new RangeError(`eraYear ${a2} does not match year ${o2}`);
    }
    if (this.hasEra && void 0 === e.era != (void 0 === e.eraYear)) throw new RangeError("properties 'era' and 'eraYear' must be provided together");
  }
  adjustCalendarDate(e, t2, r2 = "constrain", o2 = false) {
    if ("lunisolar" === this.calendarType) throw new RangeError("Override required for lunisolar calendars");
    let n2 = e;
    if (this.validateCalendarDate(n2), this.constantEra) {
      const { year: e2, eraYear: t3 } = n2;
      n2 = { ...n2, era: this.constantEra, year: void 0 !== e2 ? e2 : t3, eraYear: void 0 !== t3 ? t3 : e2 };
    }
    const a2 = this.monthsInYear(n2, t2);
    let { month: i2, monthCode: s2 } = n2;
    return { month: i2, monthCode: s2 } = resolveNonLunisolarMonth(n2, r2, a2), { ...n2, month: i2, monthCode: s2 };
  }
  regulateMonthDayNaive(e, t2, r2) {
    const o2 = this.monthsInYear(e, r2);
    let { month: n2, day: a2 } = e;
    return "reject" === t2 ? (RejectToRange(n2, 1, o2), RejectToRange(a2, 1, this.maximumMonthLength(e))) : (n2 = ConstrainToRange(n2, 1, o2), a2 = ConstrainToRange(a2, 1, this.maximumMonthLength({ ...e, month: n2 }))), { ...e, month: n2, day: a2 };
  }
  calendarToIsoDate(e, t2 = "constrain", r2) {
    const o2 = e;
    let n2 = this.adjustCalendarDate(e, r2, t2, false);
    n2 = this.regulateMonthDayNaive(n2, t2, r2);
    const { year: a2, month: i2, day: s2 } = n2, l2 = JSON.stringify({ func: "calendarToIsoDate", year: a2, month: i2, day: s2, overflow: t2, id: this.id });
    let d2, m2 = r2.get(l2);
    if (m2) return m2;
    if (void 0 !== o2.year && void 0 !== o2.month && void 0 !== o2.day && (o2.year !== n2.year || o2.month !== n2.month || o2.day !== n2.day) && (d2 = JSON.stringify({ func: "calendarToIsoDate", year: o2.year, month: o2.month, day: o2.day, overflow: t2, id: this.id }), m2 = r2.get(d2), m2)) return m2;
    let c2 = this.estimateIsoDate({ year: a2, month: i2, day: s2 });
    const calculateSameMonthResult = (e2) => {
      let o3 = this.addDaysIso(c2, e2);
      if (n2.day > this.minimumMonthLength(n2)) {
        let e3 = this.isoToCalendarDate(o3, r2);
        for (; e3.month !== i2 || e3.year !== a2; ) {
          if ("reject" === t2) throw new RangeError(`day ${s2} does not exist in month ${i2} of year ${a2}`);
          o3 = this.addDaysIso(o3, -1), e3 = this.isoToCalendarDate(o3, r2);
        }
      }
      return o3;
    };
    let h2 = 0, u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2);
    if (0 !== T2.years || 0 !== T2.months || 0 !== T2.days) {
      const e2 = 365 * T2.years + 30 * T2.months + T2.days;
      c2 = this.addDaysIso(c2, e2), u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months ? c2 = calculateSameMonthResult(T2.days) : h2 = this.compareCalendarDates(n2, u2);
    }
    let p2 = 8;
    for (; h2; ) {
      c2 = this.addDaysIso(c2, h2 * p2);
      const e2 = u2;
      u2 = this.isoToCalendarDate(c2, r2);
      const a3 = h2;
      if (h2 = this.compareCalendarDates(n2, u2), h2) {
        if (T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months) c2 = calculateSameMonthResult(T2.days), h2 = 0;
        else if (a3 && h2 !== a3) if (p2 > 1) p2 /= 2;
        else {
          if ("reject" === t2) throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...o2 })}`);
          this.compareCalendarDates(u2, e2) > 0 && (c2 = this.addDaysIso(c2, -1)), h2 = 0;
        }
      }
    }
    if (r2.set(l2, c2), d2 && r2.set(d2, c2), void 0 === n2.year || void 0 === n2.month || void 0 === n2.day || void 0 === n2.monthCode || this.hasEra && (void 0 === n2.era || void 0 === n2.eraYear)) throw new RangeError("Unexpected missing property");
    return c2;
  }
  temporalToCalendarDate(e, t2) {
    const r2 = { year: GetSlot(e, i), month: GetSlot(e, s), day: GetSlot(e, l) };
    return this.isoToCalendarDate(r2, t2);
  }
  compareCalendarDates(e, t2) {
    const r2 = PrepareTemporalFields(e, ["day", "month", "year"], ["day", "month", "year"]), o2 = PrepareTemporalFields(t2, ["day", "month", "year"], ["day", "month", "year"]);
    return r2.year !== o2.year ? ComparisonResult(r2.year - o2.year) : r2.month !== o2.month ? ComparisonResult(r2.month - o2.month) : r2.day !== o2.day ? ComparisonResult(r2.day - o2.day) : 0;
  }
  regulateDate(e, t2 = "constrain", r2) {
    const o2 = this.calendarToIsoDate(e, t2, r2);
    return this.isoToCalendarDate(o2, r2);
  }
  addDaysIso(e, t2) {
    return AddISODate(e.year, e.month, e.day, 0, 0, 0, t2, "constrain");
  }
  addDaysCalendar(e, t2, r2) {
    const o2 = this.calendarToIsoDate(e, "constrain", r2), n2 = this.addDaysIso(o2, t2);
    return this.isoToCalendarDate(n2, r2);
  }
  addMonthsCalendar(e, t2, r2, o2) {
    let n2 = e;
    const { day: a2 } = n2;
    for (let e2 = 0, r3 = It(t2); e2 < r3; e2++) {
      const { month: e3 } = n2, r4 = n2, i2 = t2 < 0 ? -Math.max(a2, this.daysInPreviousMonth(n2, o2)) : this.daysInMonth(n2, o2), s2 = this.calendarToIsoDate(n2, "constrain", o2);
      let l2 = this.addDaysIso(s2, i2);
      if (n2 = this.isoToCalendarDate(l2, o2), t2 > 0) {
        const t3 = this.monthsInYear(r4, o2);
        for (; n2.month - 1 != e3 % t3; ) l2 = this.addDaysIso(l2, -1), n2 = this.isoToCalendarDate(l2, o2);
      }
      n2.day !== a2 && (n2 = this.regulateDate({ ...n2, day: a2 }, "constrain", o2));
    }
    if ("reject" === r2 && n2.day !== a2) throw new RangeError(`Day ${a2} does not exist in resulting calendar month`);
    return n2;
  }
  addCalendar(e, { years: t2 = 0, months: r2 = 0, weeks: o2 = 0, days: n2 = 0 }, a2, i2) {
    const { year: s2, day: l2, monthCode: d2 } = e, m2 = this.adjustCalendarDate({ year: s2 + t2, monthCode: d2, day: l2 }, i2), c2 = this.addMonthsCalendar(m2, r2, a2, i2), h2 = n2 + 7 * o2;
    return this.addDaysCalendar(c2, h2, i2);
  }
  untilCalendar(e, t2, r2, o2) {
    let n2 = 0, a2 = 0, i2 = 0, s2 = 0;
    switch (r2) {
      case "day":
        n2 = this.calendarDaysUntil(e, t2, o2);
        break;
      case "week": {
        const r3 = this.calendarDaysUntil(e, t2, o2);
        n2 = r3 % 7, a2 = (r3 - n2) / 7;
        break;
      }
      case "month":
      case "year": {
        const a3 = this.compareCalendarDates(t2, e);
        if (!a3) return { years: 0, months: 0, weeks: 0, days: 0 };
        const l2 = t2.year - e.year, d2 = t2.day - e.day;
        if ("year" === r2 && l2) {
          let r3 = 0;
          t2.monthCode > e.monthCode && (r3 = 1), t2.monthCode < e.monthCode && (r3 = -1), r3 || (r3 = Math.sign(d2));
          s2 = r3 * a3 < 0 ? l2 - a3 : l2;
        }
        let m2, c2 = s2 ? this.addCalendar(e, { years: s2 }, "constrain", o2) : e;
        do {
          i2 += a3, m2 = c2, c2 = this.addMonthsCalendar(m2, a3, "constrain", o2), c2.day !== e.day && (c2 = this.regulateDate({ ...c2, day: e.day }, "constrain", o2));
        } while (this.compareCalendarDates(t2, c2) * a3 >= 0);
        i2 -= a3;
        n2 = this.calendarDaysUntil(m2, t2, o2);
        break;
      }
    }
    return { years: s2, months: i2, weeks: a2, days: n2 };
  }
  daysInMonth(e, t2) {
    const { day: r2 } = e, o2 = this.maximumMonthLength(e), n2 = this.minimumMonthLength(e);
    if (n2 === o2) return n2;
    const a2 = r2 <= o2 - n2 ? o2 : n2, i2 = this.calendarToIsoDate(e, "constrain", t2), s2 = this.addDaysIso(i2, a2), l2 = this.isoToCalendarDate(s2, t2), d2 = this.addDaysIso(s2, -l2.day);
    return this.isoToCalendarDate(d2, t2).day;
  }
  daysInPreviousMonth(e, t2) {
    const { day: r2, month: o2, year: n2 } = e;
    let a2 = { year: o2 > 1 ? n2 : n2 - 1, month: o2, day: 1 };
    const i2 = o2 > 1 ? o2 - 1 : this.monthsInYear(a2, t2);
    a2 = { ...a2, month: i2 };
    const s2 = this.minimumMonthLength(a2), l2 = this.maximumMonthLength(a2);
    if (s2 === l2) return l2;
    const d2 = this.calendarToIsoDate(e, "constrain", t2), m2 = this.addDaysIso(d2, -r2);
    return this.isoToCalendarDate(m2, t2).day;
  }
  startOfCalendarYear(e) {
    return { year: e.year, month: 1, monthCode: "M01", day: 1 };
  }
  startOfCalendarMonth(e) {
    return { year: e.year, month: e.month, day: 1 };
  }
  calendarDaysUntil(e, t2, r2) {
    const o2 = this.calendarToIsoDate(e, "constrain", r2), n2 = this.calendarToIsoDate(t2, "constrain", r2);
    return this.isoDaysUntil(o2, n2);
  }
  isoDaysUntil(e, t2) {
    return DifferenceISODate(e.year, e.month, e.day, t2.year, t2.month, t2.day, "day").days;
  }
  monthDayFromFields(e, t2, r2) {
    let o2, n2, a2, i2, s2, { monthCode: l2, day: d2 } = e;
    if (void 0 === l2) {
      let { year: o3, era: n3, eraYear: a3 } = e;
      if (void 0 === o3 && (void 0 === n3 || void 0 === a3)) throw new TypeError("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
      ({ monthCode: l2, day: d2 } = this.isoToCalendarDate(this.calendarToIsoDate(e, t2, r2), r2));
    }
    const m2 = this.isoToCalendarDate({ year: 1972, month: 12, day: 31 }, r2), c2 = m2.monthCode > l2 || m2.monthCode === l2 && m2.day >= d2 ? m2.year : m2.year - 1;
    for (let e2 = 0; e2 < 100; e2++) {
      const m3 = this.adjustCalendarDate({ day: d2, monthCode: l2, year: c2 - e2 }, r2), h2 = this.calendarToIsoDate(m3, "constrain", r2), u2 = this.isoToCalendarDate(h2, r2);
      if ({ year: o2, month: n2, day: a2 } = h2, u2.monthCode === l2 && u2.day === d2) return { month: n2, day: a2, year: o2 };
      "constrain" === t2 && (void 0 === i2 || u2.monthCode === i2.monthCode && u2.day > i2.day) && (i2 = u2, s2 = h2);
    }
    if ("constrain" === t2 && void 0 !== s2) return s2;
    throw new RangeError(`No recent ${this.id} year with monthCode ${l2} and day ${d2}`);
  }
};
var HebrewHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "hebrew", this.calendarType = "lunisolar", this.months = { Tishri: { leap: 1, regular: 1, monthCode: "M01", days: 30 }, Heshvan: { leap: 2, regular: 2, monthCode: "M02", days: { min: 29, max: 30 } }, Kislev: { leap: 3, regular: 3, monthCode: "M03", days: { min: 29, max: 30 } }, Tevet: { leap: 4, regular: 4, monthCode: "M04", days: 29 }, Shevat: { leap: 5, regular: 5, monthCode: "M05", days: 30 }, Adar: { leap: void 0, regular: 6, monthCode: "M06", days: 29 }, "Adar I": { leap: 6, regular: void 0, monthCode: "M05L", days: 30 }, "Adar II": { leap: 7, regular: void 0, monthCode: "M06", days: 29 }, Nisan: { leap: 8, regular: 7, monthCode: "M07", days: 30 }, Iyar: { leap: 9, regular: 8, monthCode: "M08", days: 29 }, Sivan: { leap: 10, regular: 9, monthCode: "M09", days: 30 }, Tamuz: { leap: 11, regular: 10, monthCode: "M10", days: 29 }, Av: { leap: 12, regular: 11, monthCode: "M11", days: 30 }, Elul: { leap: 13, regular: 12, monthCode: "M12", days: 29 } }, this.hasEra = false;
  }
  inLeapYear(e) {
    const { year: t2 } = e;
    return (7 * t2 + 1) % 19 < 7;
  }
  monthsInYear(e) {
    return this.inLeapYear(e) ? 13 : 12;
  }
  minimumMonthLength(e) {
    return this.minMaxMonthLength(e, "min");
  }
  maximumMonthLength(e) {
    return this.minMaxMonthLength(e, "max");
  }
  minMaxMonthLength(e, t2) {
    const { month: r2, year: o2 } = e, n2 = this.getMonthCode(o2, r2), a2 = wt(this.months).find((e2) => e2[1].monthCode === n2);
    if (void 0 === a2) throw new RangeError(`unmatched Hebrew month: ${r2}`);
    const i2 = a2[1].days;
    return "number" == typeof i2 ? i2 : i2[t2];
  }
  estimateIsoDate(e) {
    const { year: t2 } = e;
    return { year: t2 - 3760, month: 1, day: 1 };
  }
  getMonthCode(e, t2) {
    return this.inLeapYear({ year: e }) ? 6 === t2 ? buildMonthCode(5, true) : buildMonthCode(t2 < 6 ? t2 : t2 - 1) : buildMonthCode(t2);
  }
  adjustCalendarDate(e, t2, r2 = "constrain", o2 = false) {
    let { year: n2, eraYear: a2, month: i2, monthCode: s2, day: l2, monthExtra: d2 } = e;
    if (void 0 === n2 && void 0 !== a2 && (n2 = a2), void 0 === a2 && void 0 !== n2 && (a2 = n2), o2) {
      if (d2) {
        const e2 = this.months[d2];
        if (!e2) throw new RangeError(`Unrecognized month from formatToParts: ${d2}`);
        i2 = this.inLeapYear({ year: n2 }) ? e2.leap : e2.regular;
      }
      s2 = this.getMonthCode(n2, i2);
      return { year: n2, month: i2, day: l2, era: void 0, eraYear: a2, monthCode: s2 };
    }
    if (this.validateCalendarDate(e), void 0 === i2) if (s2.endsWith("L")) {
      if ("M05L" !== s2) throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${s2}`);
      if (i2 = 6, !this.inLeapYear({ year: n2 })) {
        if ("reject" === r2) throw new RangeError(`Hebrew monthCode M05L is invalid in year ${n2} which is not a leap year`);
        i2 = 6, s2 = "M06";
      }
    } else {
      i2 = monthCodeNumberPart(s2), this.inLeapYear({ year: n2 }) && i2 >= 6 && i2++;
      const e2 = this.monthsInYear({ year: n2 });
      if (i2 < 1 || i2 > e2) throw new RangeError(`Invalid monthCode: ${s2}`);
    }
    else if ("reject" === r2 ? (RejectToRange(i2, 1, this.monthsInYear({ year: n2 })), RejectToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))) : (i2 = ConstrainToRange(i2, 1, this.monthsInYear({ year: n2 })), l2 = ConstrainToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))), void 0 === s2) s2 = this.getMonthCode(n2, i2);
    else {
      if (this.getMonthCode(n2, i2) !== s2) throw new RangeError(`monthCode ${s2} doesn't correspond to month ${i2} in Hebrew year ${n2}`);
    }
    return { ...e, day: l2, month: i2, monthCode: s2, year: n2, eraYear: a2 };
  }
};
var IslamicBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunar", this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, this.DAYS_PER_ISO_YEAR = 365.2425, this.constantEra = "ah";
  }
  inLeapYear(e, t2) {
    return 30 === this.daysInMonth({ year: e.year, month: 12, day: 1 }, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  estimateIsoDate(e) {
    const { year: t2 } = this.adjustCalendarDate(e);
    return { year: St(t2 * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };
  }
};
var IslamicHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic";
  }
};
var IslamicUmalquraHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-umalqura";
  }
};
var IslamicTblaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-tbla";
  }
};
var IslamicCivilHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-civil";
  }
};
var IslamicRgsaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-rgsa";
  }
};
var IslamicCcHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamicc";
  }
};
var PersianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "persian", this.calendarType = "solar", this.constantEra = "ap";
  }
  inLeapYear(e, t2) {
    return IslamicHelper.prototype.inLeapYear.call(this, e, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e) {
    const { month: t2 } = e;
    return 12 === t2 ? 29 : t2 <= 6 ? 31 : 30;
  }
  maximumMonthLength(e) {
    const { month: t2 } = e;
    return 12 === t2 ? 30 : t2 <= 6 ? 31 : 30;
  }
  estimateIsoDate(e) {
    const { year: t2 } = this.adjustCalendarDate(e);
    return { year: t2 + 621, month: 1, day: 1 };
  }
};
var IndianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "indian", this.calendarType = "solar", this.constantEra = "saka", this.months = { 1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } }, 2: { length: 31, month: 4, day: 21 }, 3: { length: 31, month: 5, day: 22 }, 4: { length: 31, month: 6, day: 22 }, 5: { length: 31, month: 7, day: 23 }, 6: { length: 31, month: 8, day: 23 }, 7: { length: 30, month: 9, day: 23 }, 8: { length: 30, month: 10, day: 23 }, 9: { length: 30, month: 11, day: 22 }, 10: { length: 30, month: 12, day: 22 }, 11: { length: 30, month: 1, nextYear: true, day: 21 }, 12: { length: 30, month: 2, nextYear: true, day: 20 } }, this.vulnerableToBceBug = "10/11/-79 Saka" !== (/* @__PURE__ */ new Date("0000-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-indian", { timeZone: "UTC" });
  }
  inLeapYear(e) {
    return isGregorianLeapYear(e.year + 78);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e) {
    return this.getMonthInfo(e).length;
  }
  maximumMonthLength(e) {
    return this.getMonthInfo(e).length;
  }
  getMonthInfo(e) {
    const { month: t2 } = e;
    let r2 = this.months[t2];
    if (void 0 === r2) throw new RangeError(`Invalid month: ${t2}`);
    return this.inLeapYear(e) && r2.leap && (r2 = r2.leap), r2;
  }
  estimateIsoDate(e) {
    const t2 = this.adjustCalendarDate(e), r2 = this.getMonthInfo(t2);
    return AddISODate(t2.year + 78 + (r2.nextYear ? 1 : 0), r2.month, r2.day, 0, 0, 0, t2.day - 1, "constrain");
  }
  checkIcuBugs(e) {
    if (this.vulnerableToBceBug && e.year < 1) throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
  }
};
function isGregorianLeapYear(e) {
  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
}
var GregorianBaseHelper = class extends HelperBase {
  constructor(e, t2) {
    super(), this.calendarType = "solar", this.v8IsVulnerableToJulianBug = (/* @__PURE__ */ new Date("+001001-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-japanese", { timeZone: "UTC" }).startsWith("12"), this.calendarIsVulnerableToJulianBug = false, this.id = e;
    const { eras: r2, anchorEra: o2 } = function adjustEras(e2) {
      let t3, r3 = e2;
      if (0 === r3.length) throw new RangeError("Invalid era data: eras are required");
      if (1 === r3.length && r3[0].reverseOf) throw new RangeError("Invalid era data: anchor era cannot count years backwards");
      if (1 === r3.length && !r3[0].name) throw new RangeError("Invalid era data: at least one named era is required");
      if (r3.filter((e3) => null != e3.reverseOf).length > 1) throw new RangeError("Invalid era data: only one era can count years backwards");
      r3.forEach((e3) => {
        if (e3.isAnchor || !e3.anchorEpoch && !e3.reverseOf) {
          if (t3) throw new RangeError("Invalid era data: cannot have multiple anchor eras");
          t3 = e3, e3.anchorEpoch = { year: e3.hasYearZero ? 0 : 1 };
        } else if (!e3.name) throw new RangeError("If era name is blank, it must be the anchor era");
      }), r3 = r3.filter((e3) => e3.name), r3.forEach((e3) => {
        const { reverseOf: t4 } = e3;
        if (t4) {
          const o4 = r3.find((e4) => e4.name === t4);
          if (void 0 === o4) throw new RangeError(`Invalid era data: unmatched reverseOf era: ${t4}`);
          e3.reverseOf = o4, e3.anchorEpoch = o4.anchorEpoch, e3.isoEpoch = o4.isoEpoch;
        }
        void 0 === e3.anchorEpoch.month && (e3.anchorEpoch.month = 1), void 0 === e3.anchorEpoch.day && (e3.anchorEpoch.day = 1);
      }), yt.call(r3, (e3, t4) => {
        if (e3.reverseOf) return 1;
        if (t4.reverseOf) return -1;
        if (!e3.isoEpoch || !t4.isoEpoch) throw new RangeError("Invalid era data: missing ISO epoch");
        return t4.isoEpoch.year - e3.isoEpoch.year;
      });
      const o3 = r3[r3.length - 1].reverseOf;
      if (o3 && o3 !== r3[r3.length - 2]) throw new RangeError("Invalid era data: invalid reverse-sign era");
      return r3.forEach((e3, t4) => {
        e3.genericName = "era" + (r3.length - 1 - t4);
      }), { eras: r3, anchorEra: t3 || r3[0] };
    }(t2);
    this.anchorEra = o2, this.eras = r2;
  }
  inLeapYear(e) {
    const { year: t2 } = this.estimateIsoDate({ month: 1, day: 1, year: e.year });
    return isGregorianLeapYear(t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e) {
    const { month: t2 } = e;
    return 2 === t2 ? this.inLeapYear(e) ? 29 : 28 : [4, 6, 9, 11].indexOf(t2) >= 0 ? 30 : 31;
  }
  maximumMonthLength(e) {
    return this.minimumMonthLength(e);
  }
  completeEraYear(e) {
    const checkField = (t3, r3) => {
      const o3 = e[t3];
      if (null != o3 && o3 != r3) throw new RangeError(`Input ${t3} ${o3} doesn't match calculated value ${r3}`);
    }, eraFromYear = (t3) => {
      let r3;
      const o3 = { ...e, year: t3 }, n2 = this.eras.find((e2, n3) => {
        if (n3 === this.eras.length - 1) {
          if (e2.reverseOf) {
            if (t3 > 0) throw new RangeError(`Signed year ${t3} is invalid for era ${e2.name}`);
            return r3 = e2.anchorEpoch.year - t3, true;
          }
          return r3 = t3 - e2.anchorEpoch.year + (e2.hasYearZero ? 0 : 1), true;
        }
        return this.compareCalendarDates(o3, e2.anchorEpoch) >= 0 && (r3 = t3 - e2.anchorEpoch.year + (e2.hasYearZero ? 0 : 1), true);
      });
      if (!n2) throw new RangeError(`Year ${t3} was not matched by any era`);
      return { eraYear: r3, era: n2.name };
    };
    let { year: t2, eraYear: r2, era: o2 } = e;
    if (null != t2) ({ eraYear: r2, era: o2 } = eraFromYear(t2)), checkField("era", o2), checkField("eraYear", r2);
    else {
      if (null == r2) throw new RangeError("Either `year` or `eraYear` and `era` are required");
      {
        const e2 = void 0 === o2 ? void 0 : this.eras.find((e3) => e3.name === o2 || e3.genericName === o2);
        if (!e2) throw new RangeError(`Era ${o2} (ISO year ${r2}) was not matched by any era`);
        if (r2 < 1 && e2.reverseOf) throw new RangeError(`Years in ${o2} era must be positive, not ${t2}`);
        t2 = e2.reverseOf ? e2.anchorEpoch.year - r2 : r2 + e2.anchorEpoch.year - (e2.hasYearZero ? 0 : 1), checkField("year", t2), { eraYear: r2, era: o2 } = eraFromYear(t2);
      }
    }
    return { ...e, year: t2, eraYear: r2, era: o2 };
  }
  adjustCalendarDate(e, t2, r2 = "constrain") {
    let o2 = e;
    const { month: n2, monthCode: a2 } = o2;
    return void 0 === n2 && (o2 = { ...o2, month: monthCodeNumberPart(a2) }), this.validateCalendarDate(o2), o2 = this.completeEraYear(o2), super.adjustCalendarDate(o2, t2, r2);
  }
  estimateIsoDate(e) {
    const t2 = this.adjustCalendarDate(e), { year: r2, month: o2, day: n2 } = t2, { anchorEra: a2 } = this;
    return RegulateISODate(r2 + a2.isoEpoch.year - (a2.hasYearZero ? 0 : 1), o2, n2, "constrain");
  }
  checkIcuBugs(e) {
    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
      if (CompareISODate(e.year, e.month, e.day, 1582, 10, 15) < 0) throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
    }
  }
};
var OrthodoxBaseHelper = class extends GregorianBaseHelper {
  constructor(e, t2) {
    super(e, t2);
  }
  inLeapYear(e) {
    const { year: t2 } = e;
    return (t2 + 1) % 4 == 0;
  }
  monthsInYear() {
    return 13;
  }
  minimumMonthLength(e) {
    const { month: t2 } = e;
    return 13 === t2 ? this.inLeapYear(e) ? 6 : 5 : 30;
  }
  maximumMonthLength(e) {
    return this.minimumMonthLength(e);
  }
};
var EthioaaHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethioaa", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }]);
  }
};
var CopticHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("coptic", [{ name: "era1", isoEpoch: { year: 284, month: 8, day: 29 } }, { name: "era0", reverseOf: "era1" }]);
  }
};
var EthiopicHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethiopic", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }, { name: "era1", isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }]);
  }
};
var RocHelper = class extends GregorianBaseHelper {
  constructor() {
    super("roc", [{ name: "minguo", isoEpoch: { year: 1912, month: 1, day: 1 } }, { name: "before-roc", reverseOf: "minguo" }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var BuddhistHelper = class extends GregorianBaseHelper {
  constructor() {
    super("buddhist", [{ name: "be", hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var GregoryHelper = class extends GregorianBaseHelper {
  constructor() {
    super("gregory", [{ name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]);
  }
  reviseIntlEra(e) {
    let { era: t2, eraYear: r2 } = e;
    return "bc" !== t2 && "b" !== t2 || (t2 = "bce"), "ad" !== t2 && "a" !== t2 || (t2 = "ce"), { era: t2, eraYear: r2 };
  }
};
var JapaneseHelper = class extends GregorianBaseHelper {
  constructor() {
    super("japanese", [{ name: "reiwa", isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } }, { name: "heisei", isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } }, { name: "showa", isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } }, { name: "taisho", isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } }, { name: "meiji", isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } }, { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]), this.calendarIsVulnerableToJulianBug = true, this.eraLength = "long", this.erasBeginMidYear = true;
  }
  reviseIntlEra(e, t2) {
    const { era: r2, eraYear: o2 } = e, { year: n2 } = t2;
    return this.eras.find((e2) => e2.name === r2) ? { era: r2, eraYear: o2 } : n2 < 1 ? { era: "bce", eraYear: 1 - n2 } : { era: "ce", eraYear: n2 };
  }
};
var ChineseBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunisolar", this.hasEra = false;
  }
  inLeapYear(e, t2) {
    const r2 = this.getMonthList(e.year, t2);
    return 13 === wt(r2).length;
  }
  monthsInYear(e, t2) {
    return this.inLeapYear(e, t2) ? 13 : 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  getMonthList(e, t2) {
    if (void 0 === e) throw new TypeError("Missing year");
    const r2 = JSON.stringify({ func: "getMonthList", calendarYear: e, id: this.id }), o2 = t2.get(r2);
    if (o2) return o2;
    const n2 = this.getFormatter(), getCalendarDate = (e2, t3) => {
      const r3 = toUtcIsoDateString({ isoYear: e2, isoMonth: 2, isoDay: 1 }), o3 = new Date(r3);
      o3.setUTCDate(t3 + 1);
      const a3 = n2.formatToParts(o3), i3 = a3.find((e3) => "month" === e3.type).value, s3 = +a3.find((e3) => "day" === e3.type).value;
      let l3 = a3.find((e3) => "relatedYear" === e3.type);
      if (void 0 === l3) throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
      return l3 = +l3.value, { calendarMonthString: i3, calendarDay: s3, calendarYearToVerify: l3 };
    };
    let a2 = 17, { calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e, a2);
    "1" !== i2 && (a2 += 29, { calendarMonthString: i2, calendarDay: s2 } = getCalendarDate(e, a2)), a2 -= s2 - 5;
    const d2 = {};
    let m2, c2, h2 = 1, u2 = false;
    do {
      ({ calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e, a2)), m2 && (d2[c2].daysInMonth = m2 + 30 - s2), l2 !== e ? u2 = true : (d2[i2] = { monthIndex: h2++ }, a2 += 30), m2 = s2, c2 = i2;
    } while (!u2);
    return d2[c2].daysInMonth = m2 + 30 - s2, t2.set(r2, d2), d2;
  }
  estimateIsoDate(e) {
    const { year: t2, month: r2 } = e;
    return { year: t2, month: r2 >= 12 ? 12 : r2 + 1, day: 1 };
  }
  adjustCalendarDate(e, t2, r2 = "constrain", o2 = false) {
    let { year: n2, month: a2, monthExtra: i2, day: s2, monthCode: l2, eraYear: d2 } = e;
    if (o2) {
      if (n2 = d2, i2 && "bis" !== i2) throw new RangeError(`Unexpected leap month suffix: ${i2}`);
      const e2 = buildMonthCode(a2, void 0 !== i2), r3 = `${a2}${i2 || ""}`, o3 = this.getMonthList(n2, t2)[r3];
      if (void 0 === o3) throw new RangeError(`Unmatched month ${r3} in Chinese year ${n2}`);
      return a2 = o3.monthIndex, { year: n2, month: a2, day: s2, era: void 0, eraYear: d2, monthCode: e2 };
    }
    if (this.validateCalendarDate(e), void 0 === n2 && (n2 = d2), void 0 === d2 && (d2 = n2), void 0 === a2) {
      const e2 = this.getMonthList(n2, t2);
      let o3 = l2.replace("L", "bis").slice(1);
      "0" === o3[0] && (o3 = o3.slice(1));
      let i3 = e2[o3];
      if (a2 = i3 && i3.monthIndex, void 0 === a2 && l2.endsWith("L") && "M13L" != l2 && "constrain" === r2) {
        let t3 = l2.slice(1, -1);
        "0" === t3[0] && (t3 = t3.slice(1)), i3 = e2[t3], i3 && (a2 = i3.monthIndex, l2 = buildMonthCode(t3));
      }
      if (void 0 === a2) throw new RangeError(`Unmatched month ${l2} in Chinese year ${n2}`);
    } else if (void 0 === l2) {
      const e2 = this.getMonthList(n2, t2), o3 = wt(e2), i3 = o3.length;
      "reject" === r2 ? (RejectToRange(a2, 1, i3), RejectToRange(s2, 1, this.maximumMonthLength())) : (a2 = ConstrainToRange(a2, 1, i3), s2 = ConstrainToRange(s2, 1, this.maximumMonthLength()));
      const d3 = o3.find(([, e3]) => e3.monthIndex === a2);
      if (void 0 === d3) throw new RangeError(`Invalid month ${a2} in Chinese year ${n2}`);
      l2 = buildMonthCode(d3[0].replace("bis", ""), -1 !== d3[0].indexOf("bis"));
    } else {
      const e2 = this.getMonthList(n2, t2);
      let r3 = l2.replace("L", "bis").slice(1);
      "0" === r3[0] && (r3 = r3.slice(1));
      const o3 = e2[r3];
      if (!o3) throw new RangeError(`Unmatched monthCode ${l2} in Chinese year ${n2}`);
      if (a2 !== o3.monthIndex) throw new RangeError(`monthCode ${l2} doesn't correspond to month ${a2} in Chinese year ${n2}`);
    }
    return { ...e, year: n2, eraYear: d2, month: a2, monthCode: l2, day: s2 };
  }
};
var ChineseHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "chinese";
  }
};
var DangiHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "dangi";
  }
};
var NonIsoCalendar = class {
  constructor(e) {
    this.helper = e;
  }
  dateFromFields(e, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e, this.fields(["day", "month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate(n2, a2, o2), d2 = CreateTemporalDate(i2, s2, l2, r2);
    return o2.setObject(d2), d2;
  }
  yearMonthFromFields(e, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e, this.fields(["month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate({ ...n2, day: 1 }, a2, o2), d2 = CreateTemporalYearMonth(i2, s2, r2, l2);
    return o2.setObject(d2), d2;
  }
  monthDayFromFields(e, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e, this.fields(["day", "month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.monthDayFromFields(n2, a2, o2), d2 = CreateTemporalMonthDay(s2, l2, r2, i2);
    return o2.setObject(d2), d2;
  }
  fields(e) {
    let t2 = e;
    return Tt.call(t2, "year") && (t2 = [...t2, "era", "eraYear"]), t2;
  }
  fieldKeysToIgnore(e) {
    const t2 = new Dt();
    for (let r2 = 0; r2 < e.length; r2++) {
      const o2 = e[r2];
      switch (Call(vt, t2, [o2]), o2) {
        case "era":
          Call(vt, t2, ["eraYear"]), Call(vt, t2, ["year"]);
          break;
        case "eraYear":
          Call(vt, t2, ["era"]), Call(vt, t2, ["year"]);
          break;
        case "year":
          Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]);
          break;
        case "month":
          Call(vt, t2, ["monthCode"]), this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
          break;
        case "monthCode":
          Call(vt, t2, ["month"]), this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
          break;
        case "day":
          this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
      }
    }
    return [...Call(Ct, t2, [])];
  }
  dateAdd(e, t2, r2, o2, n2, a2, i2) {
    const s2 = OneObjectCache.getCacheForObject(e), l2 = this.helper.temporalToCalendarDate(e, s2), d2 = this.helper.addCalendar(l2, { years: t2, months: r2, weeks: o2, days: n2 }, a2, s2), m2 = this.helper.calendarToIsoDate(d2, "constrain", s2), { year: c2, month: h2, day: u2 } = m2, T2 = CreateTemporalDate(c2, h2, u2, i2);
    return new OneObjectCache(s2).setObject(T2), T2;
  }
  dateUntil(e, t2, r2) {
    const o2 = OneObjectCache.getCacheForObject(e), n2 = OneObjectCache.getCacheForObject(t2), a2 = this.helper.temporalToCalendarDate(e, o2), i2 = this.helper.temporalToCalendarDate(t2, n2);
    return this.helper.untilCalendar(a2, i2, r2, o2);
  }
  year(e) {
    const t2 = OneObjectCache.getCacheForObject(e);
    return this.helper.temporalToCalendarDate(e, t2).year;
  }
  month(e) {
    const t2 = OneObjectCache.getCacheForObject(e);
    return this.helper.temporalToCalendarDate(e, t2).month;
  }
  day(e) {
    const t2 = OneObjectCache.getCacheForObject(e);
    return this.helper.temporalToCalendarDate(e, t2).day;
  }
  era(e) {
    if (!this.helper.hasEra) return;
    const t2 = OneObjectCache.getCacheForObject(e);
    return this.helper.temporalToCalendarDate(e, t2).era;
  }
  eraYear(e) {
    if (!this.helper.hasEra) return;
    const t2 = OneObjectCache.getCacheForObject(e);
    return this.helper.temporalToCalendarDate(e, t2).eraYear;
  }
  monthCode(e) {
    const t2 = OneObjectCache.getCacheForObject(e);
    return this.helper.temporalToCalendarDate(e, t2).monthCode;
  }
  dayOfWeek(e) {
    return Ot.iso8601.dayOfWeek(e);
  }
  dayOfYear(e) {
    const t2 = OneObjectCache.getCacheForObject(e), r2 = this.helper.isoToCalendarDate(e, t2), o2 = this.helper.startOfCalendarYear(r2);
    return this.helper.calendarDaysUntil(o2, r2, t2) + 1;
  }
  weekOfYear(e) {
    return Ot.iso8601.weekOfYear(e);
  }
  yearOfWeek(e) {
    return Ot.iso8601.yearOfWeek(e);
  }
  daysInWeek(e) {
    return Ot.iso8601.daysInWeek(e);
  }
  daysInMonth(e) {
    const t2 = OneObjectCache.getCacheForObject(e), r2 = this.helper.temporalToCalendarDate(e, t2), o2 = this.helper.maximumMonthLength(r2);
    if (o2 === this.helper.minimumMonthLength(r2)) return o2;
    const n2 = this.helper.startOfCalendarMonth(r2), a2 = this.helper.addMonthsCalendar(n2, 1, "constrain", t2);
    return this.helper.calendarDaysUntil(n2, a2, t2);
  }
  daysInYear(e) {
    let t2 = e;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2), n2 = this.helper.startOfCalendarYear(o2), a2 = this.helper.addCalendar(n2, { years: 1 }, "constrain", r2);
    return this.helper.calendarDaysUntil(n2, a2, r2);
  }
  monthsInYear(e) {
    const t2 = OneObjectCache.getCacheForObject(e), r2 = this.helper.temporalToCalendarDate(e, t2);
    return this.helper.monthsInYear(r2, t2);
  }
  inLeapYear(e) {
    let t2 = e;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2);
    return this.helper.inLeapYear(o2, r2);
  }
};
for (const e of [HebrewHelper, PersianHelper, EthiopicHelper, EthioaaHelper, CopticHelper, ChineseHelper, DangiHelper, RocHelper, IndianHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper]) {
  const t2 = new e();
  Ot[t2.id] = new NonIsoCalendar(t2);
}
var PlainDate = class _PlainDate {
  constructor(e, t2, r2, o2 = "iso8601") {
    CreateTemporalDateSlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), ToTemporalCalendarSlotValue(o2));
  }
  get calendarId() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get year() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarDateFromFields(o2, a2, r2);
  }
  withCalendar(e) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e);
    return new _PlainDate(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t2);
  }
  add(e, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalDuration(e), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  subtract(e, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const r2 = CreateNegatedTemporalDuration(ToTemporalDuration(e)), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  until(e, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("until", this, e, t2);
  }
  since(e, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("since", this, e, t2);
  }
  equals(e) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e);
    for (const e2 of [i, s, l]) {
      if (GetSlot(this, e2) !== GetSlot(t2, e2)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return TemporalDateToString(this, ToCalendarNameOption(GetOptionsObject(e)));
  }
  toJSON() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return TemporalDateToString(this);
  }
  toLocaleString(e, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return new ht(e, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
  }
  toPlainDateTime(e) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e) return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  toZonedDateTime(e) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    let t2, r2;
    if (IsObject(e)) if (IsTemporalTimeZone(e)) t2 = e;
    else {
      const o3 = e.timeZone;
      void 0 === o3 ? t2 = ToTemporalTimeZoneSlotValue(e) : (t2 = ToTemporalTimeZoneSlotValue(o3), r2 = e.plainTime);
    }
    else t2 = ToTemporalTimeZoneSlotValue(e);
    const o2 = GetSlot(this, i), a2 = GetSlot(this, s), f2 = GetSlot(this, l), y2 = GetSlot(this, p);
    let I2 = 0, S2 = 0, g2 = 0, w2 = 0, D2 = 0, G2 = 0;
    void 0 !== r2 && (r2 = ToTemporalTime(r2), I2 = GetSlot(r2, d), S2 = GetSlot(r2, m), g2 = GetSlot(r2, c), w2 = GetSlot(r2, h), D2 = GetSlot(r2, u), G2 = GetSlot(r2, T));
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(t2, CreateTemporalDateTime(o2, a2, f2, I2, S2, g2, w2, D2, G2, y2), "compatible"), n), t2, y2);
  }
  toPlainYearMonth() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const e = GetSlot(this, p);
    return CalendarYearMonthFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const e = GetSlot(this, p);
    return CalendarMonthDayFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDate(e) ? (ToTemporalOverflow(r2), CreateTemporalDate(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p))) : ToTemporalDate(e, r2);
  }
  static compare(e, t2) {
    const r2 = ToTemporalDate(e), o2 = ToTemporalDate(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
var PlainDateTime = class _PlainDateTime {
  constructor(e, t2, r2, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = "iso8601") {
    CreateTemporalDateTimeSlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), void 0 === a2 ? 0 : ToIntegerWithTruncation(a2), void 0 === i2 ? 0 : ToIntegerWithTruncation(i2), void 0 === s2 ? 0 : ToIntegerWithTruncation(s2), void 0 === l2 ? 0 : ToIntegerWithTruncation(l2), ToTemporalCalendarSlotValue(d2));
  }
  get calendarId() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get year() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get hour() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  get era() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []);
    const { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    return CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, o2);
  }
  withPlainTime(e) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e) return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  withPlainDate(e) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l);
    let a2 = GetSlot(t2, p);
    const f2 = GetSlot(this, d), y2 = GetSlot(this, m), I2 = GetSlot(this, c), S2 = GetSlot(this, h), g2 = GetSlot(this, u), w2 = GetSlot(this, T);
    return a2 = ConsolidateCalendars(GetSlot(this, p), a2), CreateTemporalDateTime(r2, o2, n2, f2, y2, I2, S2, g2, w2, a2);
  }
  withCalendar(e) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e);
    return new _PlainDateTime(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), t2);
  }
  add(e, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("add", this, e, t2);
  }
  subtract(e, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("subtract", this, e, t2);
  }
  until(e, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("until", this, e, t2);
  }
  since(e, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("since", this, e, t2);
  }
  round(e) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    if (void 0 === e) throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e ? CreateOnePropObject("smallestUnit", e) : GetOptionsObject(e), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He, ["day"]), a2 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[n2];
    ValidateTemporalRoundingIncrement(r2, a2, 1 === a2);
    let f2 = GetSlot(this, i), y2 = GetSlot(this, s), I2 = GetSlot(this, l), S2 = GetSlot(this, d), g2 = GetSlot(this, m), w2 = GetSlot(this, c), D2 = GetSlot(this, h), G2 = GetSlot(this, u), v2 = GetSlot(this, T);
    return { year: f2, month: y2, day: I2, hour: S2, minute: g2, second: w2, millisecond: D2, microsecond: G2, nanosecond: v2 } = RoundISODateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, r2, n2, o2), CreateTemporalDateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, GetSlot(this, p));
  }
  equals(e) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDateTime(e);
    for (const e2 of [i, s, l, d, m, c, h, u, T]) {
      if (GetSlot(this, e2) !== GetSlot(t2, e2)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: i2, unit: s2, increment: l2 } = ToSecondsStringPrecisionRecord(a2, o2);
    return TemporalDateTimeToString(this, i2, r2, { unit: s2, increment: l2, roundingMode: n2 });
  }
  toJSON() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToString(this, "auto");
  }
  toLocaleString(e, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return new ht(e, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
  }
  toZonedDateTime(e, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalTimeZoneSlotValue(e);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(r2, this, ToTemporalDisambiguation(GetOptionsObject(t2))), n), r2, GetSlot(this, p));
  }
  toPlainDate() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const e = GetSlot(this, p);
    return CalendarYearMonthFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const e = GetSlot(this, p);
    return CalendarMonthDayFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["day", "monthCode"]), []));
  }
  toPlainTime() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(this);
  }
  getISOFields() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoHour: GetSlot(this, d), isoMicrosecond: GetSlot(this, u), isoMillisecond: GetSlot(this, h), isoMinute: GetSlot(this, m), isoMonth: GetSlot(this, s), isoNanosecond: GetSlot(this, T), isoSecond: GetSlot(this, c), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDateTime(e) ? (ToTemporalOverflow(r2), CreateTemporalDateTime(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T), GetSlot(e, p))) : ToTemporalDateTime(e, r2);
  }
  static compare(e, t2) {
    const r2 = ToTemporalDateTime(e), o2 = ToTemporalDateTime(t2);
    for (const e2 of [i, s, l, d, m, c, h, u, T]) {
      const t3 = GetSlot(r2, e2), n2 = GetSlot(o2, e2);
      if (t3 !== n2) return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
var Duration = class _Duration {
  constructor(e = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = 0) {
    const m2 = void 0 === e ? 0 : ToIntegerIfIntegral(e), c2 = void 0 === t2 ? 0 : ToIntegerIfIntegral(t2), h2 = void 0 === r2 ? 0 : ToIntegerIfIntegral(r2), u2 = void 0 === o2 ? 0 : ToIntegerIfIntegral(o2), T2 = void 0 === n2 ? 0 : ToIntegerIfIntegral(n2), p2 = void 0 === a2 ? 0 : ToIntegerIfIntegral(a2), f2 = void 0 === i2 ? 0 : ToIntegerIfIntegral(i2), y2 = void 0 === s2 ? 0 : ToIntegerIfIntegral(s2), I2 = void 0 === l2 ? 0 : ToIntegerIfIntegral(l2), S2 = void 0 === d2 ? 0 : ToIntegerIfIntegral(d2);
    RejectDuration(m2, c2, h2, u2, T2, p2, f2, y2, I2, S2), N(this), SetSlot(this, w, m2), SetSlot(this, D, c2), SetSlot(this, G, h2), SetSlot(this, v, u2), SetSlot(this, C, T2), SetSlot(this, O, p2), SetSlot(this, b, f2), SetSlot(this, E, y2), SetSlot(this, M, I2), SetSlot(this, R, S2);
  }
  get years() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, w);
  }
  get months() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, D);
  }
  get weeks() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, G);
  }
  get days() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, v);
  }
  get hours() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, C);
  }
  get minutes() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, O);
  }
  get seconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, b);
  }
  get milliseconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, E);
  }
  get microseconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, M);
  }
  get nanoseconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, R);
  }
  get sign() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  get blank() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return 0 === DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  with(e) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    const t2 = PrepareTemporalFields(e, ["days", "hours", "microseconds", "milliseconds", "minutes", "months", "nanoseconds", "seconds", "weeks", "years"], "partial"), { years: r2 = GetSlot(this, w), months: o2 = GetSlot(this, D), weeks: n2 = GetSlot(this, G), days: a2 = GetSlot(this, v), hours: i2 = GetSlot(this, C), minutes: s2 = GetSlot(this, O), seconds: l2 = GetSlot(this, b), milliseconds: d2 = GetSlot(this, E), microseconds: m2 = GetSlot(this, M), nanoseconds: c2 = GetSlot(this, R) } = t2;
    return new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  negated() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return CreateNegatedTemporalDuration(this);
  }
  abs() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return new _Duration(Math.abs(GetSlot(this, w)), Math.abs(GetSlot(this, D)), Math.abs(GetSlot(this, G)), Math.abs(GetSlot(this, v)), Math.abs(GetSlot(this, C)), Math.abs(GetSlot(this, O)), Math.abs(GetSlot(this, b)), Math.abs(GetSlot(this, E)), Math.abs(GetSlot(this, M)), Math.abs(GetSlot(this, R)));
  }
  add(e, t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("add", this, e, t2);
  }
  subtract(e, t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("subtract", this, e, t2);
  }
  round(t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    if (void 0 === t2) throw new TypeError("options parameter is required");
    let r2 = GetSlot(this, w), o2 = GetSlot(this, D), n2 = GetSlot(this, G), a2 = GetSlot(this, v), i2 = GetSlot(this, C), s2 = GetSlot(this, O), l2 = GetSlot(this, b), d2 = GetSlot(this, E), m2 = GetSlot(this, M), c2 = GetSlot(this, R), h2 = DefaultTemporalLargestUnit(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
    const u2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2);
    let T2 = GetTemporalUnit(u2, "largestUnit", "datetime", void 0, ["auto"]), f2 = ToRelativeTemporalObject(u2);
    const y2 = ToTemporalRoundingIncrement(u2), I2 = ToTemporalRoundingMode(u2, "halfExpand");
    let S2 = GetTemporalUnit(u2, "smallestUnit", "datetime", void 0), g2 = true;
    S2 || (g2 = false, S2 = "nanosecond"), h2 = LargerOfTwoTemporalUnits(h2, S2);
    let F2 = true;
    if (T2 || (F2 = false, T2 = h2), "auto" === T2 && (T2 = h2), !g2 && !F2) throw new RangeError("at least one of smallestUnit or largestUnit is required");
    if (LargerOfTwoTemporalUnits(T2, S2) !== T2) throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${S2}`);
    const Y2 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[S2];
    return void 0 !== Y2 && ValidateTemporalRoundingIncrement(y2, Y2, false), { years: r2, months: o2, weeks: n2, days: a2 } = UnbalanceDurationRelative(r2, o2, n2, a2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = RoundDuration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = AdjustRoundedDurationDays(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = BalanceDuration(a2, i2, s2, l2, d2, m2, c2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2 } = function BalanceDurationRelative(t3, r3, o3, n3, a3, i3) {
      const s3 = GetIntrinsic("%Temporal.Duration%"), l3 = DurationSign(t3, r3, o3, n3, 0, 0, 0, 0, 0, 0);
      if (0 === l3) return { years: t3, months: r3, weeks: o3, days: n3 };
      const d3 = jsbi_default.BigInt(l3);
      let m3, c3, h3 = jsbi_default.BigInt(t3), u3 = jsbi_default.BigInt(r3), T3 = jsbi_default.BigInt(o3), f3 = jsbi_default.BigInt(n3);
      i3 && (c3 = ToTemporalDate(i3), m3 = GetSlot(c3, p));
      const y3 = new s3(l3), I3 = new s3(0, l3), S3 = new s3(0, 0, l3);
      switch (a3) {
        case "year": {
          if (!m3) throw new RangeError("a starting point is required for years balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4, n4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4); jsbi_default.greaterThanOrEqual(abs(f3), jsbi_default.BigInt(ae(o4))); ) f3 = jsbi_default.subtract(f3, jsbi_default.BigInt(o4)), h3 = jsbi_default.add(h3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4);
          for ({ relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4); jsbi_default.greaterThanOrEqual(abs(f3), jsbi_default.BigInt(ae(n4))); ) f3 = jsbi_default.subtract(f3, jsbi_default.BigInt(n4)), u3 = jsbi_default.add(u3, d3), c3 = r4, { relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4);
          r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
          const a4 = "string" != typeof m3 ? GetMethod(m3, "dateUntil") : void 0, i4 = Te(null);
          i4.largestUnit = "month";
          let s4 = CalendarDateUntil(m3, c3, r4, i4, a4), l4 = GetSlot(s4, D);
          for (; jsbi_default.greaterThanOrEqual(abs(u3), jsbi_default.BigInt(ae(l4))); ) {
            u3 = jsbi_default.subtract(u3, jsbi_default.BigInt(l4)), h3 = jsbi_default.add(h3, d3), c3 = r4, r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
            const o5 = Te(null);
            o5.largestUnit = "month", s4 = CalendarDateUntil(m3, c3, r4, o5, a4), l4 = GetSlot(s4, D);
          }
          break;
        }
        case "month": {
          if (!m3) throw new RangeError("a starting point is required for months balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4); jsbi_default.greaterThanOrEqual(abs(f3), jsbi_default.BigInt(ae(o4))); ) f3 = jsbi_default.subtract(f3, jsbi_default.BigInt(o4)), u3 = jsbi_default.add(u3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4);
          break;
        }
        case "week": {
          if (!m3) throw new RangeError("a starting point is required for weeks balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4); jsbi_default.greaterThanOrEqual(abs(f3), jsbi_default.BigInt(ae(o4))); ) f3 = jsbi_default.subtract(f3, jsbi_default.BigInt(o4)), T3 = jsbi_default.add(T3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4);
          break;
        }
      }
      return { years: jsbi_default.toNumber(h3), months: jsbi_default.toNumber(u3), weeks: jsbi_default.toNumber(T3), days: jsbi_default.toNumber(f3) };
    }(r2, o2, n2, a2, T2, f2), new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  total(e) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    let t2 = GetSlot(this, w), r2 = GetSlot(this, D), o2 = GetSlot(this, G), n2 = GetSlot(this, v), a2 = GetSlot(this, C), i2 = GetSlot(this, O), s2 = GetSlot(this, b), l2 = GetSlot(this, E), d2 = GetSlot(this, M), m2 = GetSlot(this, R);
    if (void 0 === e) throw new TypeError("options argument is required");
    const c2 = "string" == typeof e ? CreateOnePropObject("unit", e) : GetOptionsObject(e), h2 = ToRelativeTemporalObject(c2), u2 = GetTemporalUnit(c2, "unit", "datetime", He);
    let T2;
    ({ years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, u2, h2)), IsTemporalZonedDateTime(h2) && (T2 = MoveRelativeZonedDateTime(h2, t2, r2, o2, 0));
    let p2 = BalancePossiblyInfiniteDuration(n2, a2, i2, s2, l2, d2, m2, u2, T2);
    if ("positive overflow" === p2) return 1 / 0;
    if ("negative overflow" === p2) return -1 / 0;
    ({ days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = p2);
    const { total: f2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, 1, u2, "trunc", h2);
    return f2;
  }
  toString(e) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2 || "minute" === n2) throw new RangeError('smallestUnit must be a time unit other than "hours" or "minutes"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalDurationToString(this, a2, { unit: i2, increment: s2, roundingMode: o2 });
  }
  toJSON() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return TemporalDurationToString(this);
  }
  toLocaleString(e, t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e, t2).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), TemporalDurationToString(this));
  }
  valueOf() {
    throw new TypeError("use compare() to compare Temporal.Duration");
  }
  static from(e) {
    return IsTemporalDuration(e) ? new _Duration(GetSlot(e, w), GetSlot(e, D), GetSlot(e, G), GetSlot(e, v), GetSlot(e, C), GetSlot(e, O), GetSlot(e, b), GetSlot(e, E), GetSlot(e, M), GetSlot(e, R)) : ToTemporalDuration(e);
  }
  static compare(t2, r2, o2) {
    const n2 = ToTemporalDuration(t2), a2 = ToTemporalDuration(r2), i2 = ToRelativeTemporalObject(GetOptionsObject(o2)), s2 = GetSlot(n2, w), l2 = GetSlot(n2, D), d2 = GetSlot(n2, G);
    let m2 = GetSlot(n2, v);
    const c2 = GetSlot(n2, C), h2 = GetSlot(n2, O), u2 = GetSlot(n2, b), T2 = GetSlot(n2, E), p2 = GetSlot(n2, M);
    let f2 = GetSlot(n2, R);
    const y2 = GetSlot(a2, w), I2 = GetSlot(a2, D), S2 = GetSlot(a2, G);
    let g2 = GetSlot(a2, v);
    const F2 = GetSlot(a2, C), Y2 = GetSlot(a2, O), P2 = GetSlot(a2, b), Z2 = GetSlot(a2, E), B2 = GetSlot(a2, M);
    let N2 = GetSlot(a2, R);
    const j2 = CalculateOffsetShift(i2, s2, l2, d2, m2), $2 = CalculateOffsetShift(i2, y2, I2, S2, g2);
    0 === s2 && 0 === y2 && 0 === l2 && 0 === I2 && 0 === d2 && 0 === S2 || ({ days: m2 } = UnbalanceDurationRelative(s2, l2, d2, m2, "day", i2), { days: g2 } = UnbalanceDurationRelative(y2, I2, S2, g2, "day", i2));
    const k2 = TotalDurationNanoseconds(m2, c2, h2, u2, T2, p2, f2, j2), U2 = TotalDurationNanoseconds(g2, F2, Y2, P2, Z2, B2, N2, $2);
    return ComparisonResult(jsbi_default.toNumber(jsbi_default.subtract(k2, U2)));
  }
};
MakeIntrinsicClass(Duration, "Temporal.Duration");
var bt = Object.create;
var PlainMonthDay = class {
  constructor(e, t2, r2 = "iso8601", o2 = 1972) {
    CreateTemporalMonthDaySlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get monthCode() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  with(e, t2) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarMonthDayFromFields(o2, a2, r2);
  }
  equals(e) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalMonthDay(e);
    for (const e2 of [s, l, i]) {
      if (GetSlot(this, e2) !== GetSlot(t2, e2)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this, ToCalendarNameOption(GetOptionsObject(e)));
  }
  toJSON() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this);
  }
  toLocaleString(e, t2) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return new ht(e, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
  }
  toPlainDate(e) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, ["day", "monthCode"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["year"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = bt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalMonthDay(e) ? (ToTemporalOverflow(r2), CreateTemporalMonthDay(GetSlot(e, s), GetSlot(e, l), GetSlot(e, p), GetSlot(e, i))) : ToTemporalMonthDay(e, r2);
  }
};
MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
var instant = () => new (GetIntrinsic("%Temporal.Instant%"))(Ve());
var plainDateTime = (e, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e);
  return GetPlainDateTimeFor(r2, instant(), o2);
};
var plainDateTimeISO = (e = DefaultTimeZone()) => GetPlainDateTimeFor(ToTemporalTimeZoneSlotValue(e), instant(), "iso8601");
var zonedDateTime = (e, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e);
  return CreateTemporalZonedDateTime(Ve(), r2, o2);
};
var Et = { instant, plainDateTime, plainDateTimeISO, plainDate: (e, t2 = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTime(e, t2)), plainDateISO: (e = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTimeISO(e)), plainTimeISO: (e = DefaultTimeZone()) => TemporalDateTimeToTime(plainDateTimeISO(e)), timeZoneId: () => DefaultTimeZone(), zonedDateTime, zonedDateTimeISO: (e = DefaultTimeZone()) => zonedDateTime("iso8601", e), [Symbol.toStringTag]: "Temporal.Now" };
Object.defineProperty(Et, Symbol.toStringTag, { value: "Temporal.Now", writable: false, enumerable: false, configurable: true });
var Mt = Object.assign;
function TemporalTimeToString(e, t2, r2) {
  let o2 = GetSlot(e, d), n2 = GetSlot(e, m), a2 = GetSlot(e, c), i2 = GetSlot(e, h), s2 = GetSlot(e, u), l2 = GetSlot(e, T);
  if (r2) {
    const { unit: e2, increment: t3, roundingMode: d2 } = r2;
    ({ hour: o2, minute: n2, second: a2, millisecond: i2, microsecond: s2, nanosecond: l2 } = RoundTime(o2, n2, a2, i2, s2, l2, t3, e2, d2));
  }
  return `${ISODateTimePartString(o2)}:${ISODateTimePartString(n2)}${FormatSecondsStringPart(a2, i2, s2, l2, t2)}`;
}
var PlainTime = class _PlainTime {
  constructor(e = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0) {
    const i2 = void 0 === e ? 0 : ToIntegerWithTruncation(e), s2 = void 0 === t2 ? 0 : ToIntegerWithTruncation(t2), l2 = void 0 === r2 ? 0 : ToIntegerWithTruncation(r2), p2 = void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), f2 = void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), y2 = void 0 === a2 ? 0 : ToIntegerWithTruncation(a2);
    RejectTime(i2, s2, l2, p2, f2, y2), N(this), SetSlot(this, d, i2), SetSlot(this, m, s2), SetSlot(this, c, l2), SetSlot(this, h, p2), SetSlot(this, u, f2), SetSlot(this, T, y2);
  }
  get hour() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  with(e, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e);
    const r2 = ToTemporalOverflow(GetOptionsObject(t2)), o2 = ToTemporalTimeRecord(e, "partial"), n2 = ToTemporalTimeRecord(this);
    let { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = Mt(n2, o2);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = RegulateTime(a2, i2, s2, l2, d2, m2, r2), new _PlainTime(a2, i2, s2, l2, d2, m2);
  }
  add(e) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("add", this, e);
  }
  subtract(e) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("subtract", this, e);
  }
  until(e, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("until", this, e, t2);
  }
  since(e, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("since", this, e, t2);
  }
  round(e) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    if (void 0 === e) throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e ? CreateOnePropObject("smallestUnit", e) : GetOptionsObject(e), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[n2], false);
    let a2 = GetSlot(this, d), i2 = GetSlot(this, m), s2 = GetSlot(this, c), l2 = GetSlot(this, h), p2 = GetSlot(this, u), f2 = GetSlot(this, T);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: p2, nanosecond: f2 } = RoundTime(a2, i2, s2, l2, p2, f2, r2, n2, o2), new _PlainTime(a2, i2, s2, l2, p2, f2);
  }
  equals(e) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalTime(e);
    for (const e2 of [d, m, c, h, u, T]) {
      if (GetSlot(this, e2) !== GetSlot(t2, e2)) return false;
    }
    return true;
  }
  toString(e) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalTimeToString(this, a2, { unit: i2, increment: s2, roundingMode: o2 });
  }
  toJSON() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return TemporalTimeToString(this, "auto");
  }
  toLocaleString(e, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return new ht(e, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
  }
  toPlainDateTime(e) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l), a2 = GetSlot(t2, p);
    return CreateTemporalDateTime(r2, o2, n2, GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), a2);
  }
  toZonedDateTime(e) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid argument");
    const t2 = e.plainDate;
    if (void 0 === t2) throw new TypeError("missing date property");
    const r2 = ToTemporalDate(t2), o2 = e.timeZone;
    if (void 0 === o2) throw new TypeError("missing timeZone property");
    const a2 = ToTemporalTimeZoneSlotValue(o2), f2 = GetSlot(r2, i), y2 = GetSlot(r2, s), I2 = GetSlot(r2, l), S2 = GetSlot(r2, p), g2 = GetSlot(this, d), w2 = GetSlot(this, m), D2 = GetSlot(this, c), G2 = GetSlot(this, h), v2 = GetSlot(this, u), C2 = GetSlot(this, T);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, I2, g2, w2, D2, G2, v2, C2, S2), "compatible"), n), a2, S2);
  }
  getISOFields() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return { isoHour: GetSlot(this, d), isoMicrosecond: GetSlot(this, u), isoMillisecond: GetSlot(this, h), isoMinute: GetSlot(this, m), isoNanosecond: GetSlot(this, T), isoSecond: GetSlot(this, c) };
  }
  static from(e, t2) {
    const r2 = ToTemporalOverflow(GetOptionsObject(t2));
    return IsTemporalTime(e) ? new _PlainTime(GetSlot(e, d), GetSlot(e, m), GetSlot(e, c), GetSlot(e, h), GetSlot(e, u), GetSlot(e, T)) : ToTemporalTime(e, r2);
  }
  static compare(e, t2) {
    const r2 = ToTemporalTime(e), o2 = ToTemporalTime(t2);
    for (const e2 of [d, m, c, h, u, T]) {
      const t3 = GetSlot(r2, e2), n2 = GetSlot(o2, e2);
      if (t3 !== n2) return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
var TimeZone = class {
  constructor(e) {
    if (arguments.length < 1) throw new RangeError("missing argument: identifier is required");
    const t2 = GetCanonicalTimeZoneIdentifier(e);
    N(this), SetSlot(this, a, t2);
  }
  get id() {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  getOffsetNanosecondsFor(e) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e), r2 = GetSlot(this, a);
    return IsTimeZoneOffsetString(r2) ? ParseTimeZoneOffsetString(r2) : GetNamedTimeZoneOffsetNanoseconds(r2, GetSlot(t2, n));
  }
  getOffsetStringFor(e) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetOffsetStringFor(this, ToTemporalInstant(e));
  }
  getPlainDateTimeFor(e, t2 = "iso8601") {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetPlainDateTimeFor(this, ToTemporalInstant(e), ToTemporalCalendarSlotValue(t2));
  }
  getInstantFor(e, t2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetInstantFor(this, ToTemporalDateTime(e), ToTemporalDisambiguation(GetOptionsObject(t2)));
  }
  getPossibleInstantsFor(t2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalDateTime(t2), o2 = GetIntrinsic("%Temporal.Instant%"), n2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(n2)) {
      const t3 = GetUTCEpochNanoseconds(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
      if (null === t3) throw new RangeError("DateTime outside of supported range");
      const a2 = ParseTimeZoneOffsetString(n2);
      return [new o2(jsbi_default.subtract(t3, jsbi_default.BigInt(a2)))];
    }
    const p2 = function GetNamedTimeZoneEpochNanoseconds(t3, r3, o3, n3, a2, i2, s2, l2, d2, m2) {
      const c2 = GetUTCEpochNanoseconds(r3, o3, n3, a2, i2, s2, l2, d2, m2);
      if (null === c2) throw new RangeError("DateTime outside of supported range");
      let h2 = jsbi_default.subtract(c2, Ee);
      jsbi_default.lessThan(h2, Me) && (h2 = c2);
      let u2 = jsbi_default.add(c2, Ee);
      jsbi_default.greaterThan(u2, Re) && (u2 = c2);
      const T2 = GetNamedTimeZoneOffsetNanoseconds(t3, h2), p3 = GetNamedTimeZoneOffsetNanoseconds(t3, u2);
      return (T2 === p3 ? [T2] : [T2, p3]).map((h3) => {
        const u3 = jsbi_default.subtract(c2, jsbi_default.BigInt(h3)), T3 = GetNamedTimeZoneDateTimeParts(t3, u3);
        if (r3 === T3.year && o3 === T3.month && n3 === T3.day && a2 === T3.hour && i2 === T3.minute && s2 === T3.second && l2 === T3.millisecond && d2 === T3.microsecond && m2 === T3.nanosecond) return u3;
      }).filter((e) => void 0 !== e);
    }(n2, GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
    return p2.map((e) => new o2(e));
  }
  getNextTransition(e) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2) return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZoneNextTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  getPreviousTransition(e) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2) return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZonePreviousTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  toString() {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  toJSON() {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  static from(e) {
    return ToTemporalTimeZoneObject(ToTemporalTimeZoneSlotValue(e));
  }
};
MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"), DefineIntrinsic("Temporal.TimeZone.prototype.getOffsetNanosecondsFor", TimeZone.prototype.getOffsetNanosecondsFor), DefineIntrinsic("Temporal.TimeZone.prototype.getPossibleInstantsFor", TimeZone.prototype.getPossibleInstantsFor);
var Rt = Object.create;
var PlainYearMonth = class {
  constructor(e, t2, r2 = "iso8601", o2 = 1) {
    CreateTemporalYearMonthSlots(this, ToIntegerWithTruncation(e), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get year() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarYearMonthFromFields(o2, a2, r2);
  }
  add(e, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("add", this, e, t2);
  }
  subtract(e, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("subtract", this, e, t2);
  }
  until(e, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("until", this, e, t2);
  }
  since(e, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("since", this, e, t2);
  }
  equals(e) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalYearMonth(e);
    for (const e2 of [i, s, l]) {
      if (GetSlot(this, e2) !== GetSlot(t2, e2)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this, ToCalendarNameOption(GetOptionsObject(e)));
  }
  toJSON() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this);
  }
  toLocaleString(e, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return new ht(e, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
  }
  toPlainDate(e) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, ["monthCode", "year"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["day"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = Rt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalYearMonth(e) ? (ToTemporalOverflow(r2), CreateTemporalYearMonth(GetSlot(e, i), GetSlot(e, s), GetSlot(e, p), GetSlot(e, l))) : ToTemporalYearMonth(e, r2);
  }
  static compare(e, t2) {
    const r2 = ToTemporalYearMonth(e), o2 = ToTemporalYearMonth(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
var Ft = ht.prototype.resolvedOptions;
var Yt = Object.create;
var ZonedDateTime = class {
  constructor(e, t2, r2 = "iso8601") {
    if (arguments.length < 1) throw new TypeError("missing argument: epochNanoseconds is required");
    CreateTemporalZonedDateTimeSlots(this, ToBigInt(e), ToTemporalTimeZoneSlotValue(t2), ToTemporalCalendarSlotValue(r2));
  }
  get calendarId() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get timeZoneId() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
  }
  get year() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), dateTime(this));
  }
  get month() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), dateTime(this));
  }
  get monthCode() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), dateTime(this));
  }
  get day() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), dateTime(this));
  }
  get hour() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), d);
  }
  get minute() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), m);
  }
  get second() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), c);
  }
  get millisecond() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), h);
  }
  get microsecond() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), u);
  }
  get nanosecond() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), T);
  }
  get era() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), dateTime(this));
  }
  get eraYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), dateTime(this));
  }
  get epochSeconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return jsbi_default.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return jsbi_default.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(GetSlot(this, n));
  }
  get dayOfWeek() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
  }
  get dayOfYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
  }
  get weekOfYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
  }
  get yearOfWeek() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
  }
  get hoursInDay() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = dateTime(this), r2 = GetIntrinsic("%Temporal.PlainDateTime%"), o2 = GetSlot(t2, i), a2 = GetSlot(t2, s), d2 = GetSlot(t2, l), m2 = new r2(o2, a2, d2, 0, 0, 0, 0, 0, 0), c2 = AddISODate(o2, a2, d2, 0, 0, 0, 1, "reject"), h2 = new r2(c2.year, c2.month, c2.day, 0, 0, 0, 0, 0, 0), u2 = GetSlot(this, g), T2 = GetSlot(GetInstantFor(u2, m2, "compatible"), n), p2 = GetSlot(GetInstantFor(u2, h2, "compatible"), n);
    return BigIntDivideToNumber(jsbi_default.subtract(p2, T2), Oe);
  }
  get daysInWeek() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
  }
  get daysInMonth() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
  }
  get daysInYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
  }
  get monthsInYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
  }
  get inLeapYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
  }
  get offset() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
  }
  get offsetNanoseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetOffsetNanosecondsFor(GetSlot(this, g), GetSlot(this, S));
  }
  with(e, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e)) throw new TypeError("invalid zoned-date-time-like");
    RejectTemporalLikeObject(e);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p);
    let n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    n2.push("offset");
    let a2 = PrepareTemporalFields(this, n2, ["offset"]);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, ["offset"]);
    const i2 = ToTemporalDisambiguation(r2), s2 = ToTemporalOffset(r2, "prefer");
    let { year: l2, month: d2, day: m2, hour: c2, minute: h2, second: u2, millisecond: T2, microsecond: f2, nanosecond: y2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    const I2 = ParseTimeZoneOffsetString(a2.offset), S2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(l2, d2, m2, c2, h2, u2, T2, f2, y2, "option", I2, S2, i2, s2, false), S2, o2);
  }
  withPlainDate(e) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), a2 = GetSlot(t2, l);
    let f2 = GetSlot(t2, p);
    const y2 = dateTime(this), I2 = GetSlot(y2, d), S2 = GetSlot(y2, m), w2 = GetSlot(y2, c), D2 = GetSlot(y2, h), G2 = GetSlot(y2, u), v2 = GetSlot(y2, T);
    f2 = ConsolidateCalendars(GetSlot(this, p), f2);
    const C2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(C2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(r2, o2, a2, I2, S2, w2, D2, G2, v2, f2), "compatible"), n), C2, f2);
  }
  withPlainTime(e) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetIntrinsic("%Temporal.PlainTime%"), r2 = void 0 === e ? new t2() : ToTemporalTime(e), o2 = dateTime(this), a2 = GetSlot(o2, i), f2 = GetSlot(o2, s), y2 = GetSlot(o2, l), I2 = GetSlot(this, p), S2 = GetSlot(r2, d), w2 = GetSlot(r2, m), D2 = GetSlot(r2, c), G2 = GetSlot(r2, h), v2 = GetSlot(r2, u), C2 = GetSlot(r2, T), O2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(O2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(a2, f2, y2, S2, w2, D2, G2, v2, C2, I2), "compatible"), n), O2, I2);
  }
  withTimeZone(e) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, GetSlot(this, p));
  }
  withCalendar(e) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e);
    return CreateTemporalZonedDateTime(GetSlot(this, n), GetSlot(this, g), t2);
  }
  add(e, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("add", this, e, t2);
  }
  subtract(e, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("subtract", this, e, t2);
  }
  until(e, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("until", this, e, t2);
  }
  since(e, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("since", this, e, t2);
  }
  round(t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    if (void 0 === t2) throw new TypeError("options parameter is required");
    const r2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2), o2 = ToTemporalRoundingIncrement(r2), a2 = ToTemporalRoundingMode(r2, "halfExpand"), f2 = GetTemporalUnit(r2, "smallestUnit", "time", He, ["day"]), y2 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[f2];
    ValidateTemporalRoundingIncrement(o2, y2, 1 === y2);
    const I2 = dateTime(this);
    let w2 = GetSlot(I2, i), D2 = GetSlot(I2, s), G2 = GetSlot(I2, l), v2 = GetSlot(I2, d), C2 = GetSlot(I2, m), O2 = GetSlot(I2, c), b2 = GetSlot(I2, h), E2 = GetSlot(I2, u), M2 = GetSlot(I2, T);
    const R2 = GetIntrinsic("%Temporal.PlainDateTime%"), F2 = GetSlot(this, g), Y2 = GetSlot(this, p), P2 = GetInstantFor(F2, new R2(GetSlot(I2, i), GetSlot(I2, s), GetSlot(I2, l), 0, 0, 0, 0, 0, 0), "compatible"), Z2 = AddZonedDateTime(P2, F2, Y2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0), B2 = jsbi_default.subtract(Z2, jsbi_default.BigInt(GetSlot(P2, n)));
    if (jsbi_default.lessThanOrEqual(B2, Ie)) throw new RangeError("cannot round a ZonedDateTime in a calendar with zero or negative length days");
    ({ year: w2, month: D2, day: G2, hour: v2, minute: C2, second: O2, millisecond: b2, microsecond: E2, nanosecond: M2 } = RoundISODateTime(w2, D2, G2, v2, C2, O2, b2, E2, M2, o2, f2, a2, jsbi_default.toNumber(B2)));
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(w2, D2, G2, v2, C2, O2, b2, E2, M2, "option", GetOffsetNanosecondsFor(F2, GetSlot(this, S)), F2, "compatible", "prefer", false), F2, GetSlot(this, p));
  }
  equals(t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalZonedDateTime(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return !!jsbi_default.equal(jsbi_default.BigInt(o2), jsbi_default.BigInt(a2)) && (!!TimeZoneEquals(GetSlot(this, g), GetSlot(r2, g)) && CalendarEquals(GetSlot(this, p), GetSlot(r2, p)));
  }
  toString(e) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = function ToShowOffsetOption(e2) {
      return GetOption(e2, "offset", ["auto", "never"], "auto");
    }(t2), a2 = ToTemporalRoundingMode(t2, "trunc"), i2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === i2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const s2 = function ToTimeZoneNameOption(e2) {
      return GetOption(e2, "timeZoneName", ["auto", "never", "critical"], "auto");
    }(t2), { precision: l2, unit: d2, increment: m2 } = ToSecondsStringPrecisionRecord(i2, o2);
    return TemporalZonedDateTimeToString(this, l2, r2, s2, n2, { unit: d2, increment: m2, roundingMode: a2 });
  }
  toLocaleString(e, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const r2 = GetOptionsObject(t2), o2 = Yt(null);
    if (CopyDataProperties(o2, r2, ["timeZone"]), void 0 !== r2.timeZone) throw new TypeError("ZonedDateTime toLocaleString does not accept a timeZone option");
    void 0 === o2.year && void 0 === o2.month && void 0 === o2.day && void 0 === o2.weekday && void 0 === o2.dateStyle && void 0 === o2.hour && void 0 === o2.minute && void 0 === o2.second && void 0 === o2.timeStyle && void 0 === o2.dayPeriod && void 0 === o2.timeZoneName && (o2.timeZoneName = "short");
    let n2 = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
    if (IsTimeZoneOffsetString(n2)) throw new RangeError("toLocaleString does not support offset string time zones");
    n2 = GetCanonicalTimeZoneIdentifier(n2), o2.timeZone = n2;
    const a2 = new ht(e, o2), i2 = Call(Ft, a2, []).calendar, s2 = ToTemporalCalendarIdentifier(GetSlot(this, p));
    if ("iso8601" !== s2 && "iso8601" !== i2 && i2 !== s2) throw new RangeError(`cannot format ZonedDateTime with calendar ${s2} in locale with calendar ${i2}`);
    return a2.format(GetSlot(this, S));
  }
  toJSON() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalZonedDateTimeToString(this, "auto");
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
  }
  startOfDay() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e = dateTime(this), t2 = GetIntrinsic("%Temporal.PlainDateTime%"), r2 = GetSlot(this, p), o2 = new t2(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), 0, 0, 0, 0, 0, 0, r2), a2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, o2, "compatible"), n), a2, r2);
  }
  toInstant() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, n));
  }
  toPlainDate() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(dateTime(this));
  }
  toPlainTime() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(dateTime(this));
  }
  toPlainDateTime() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return dateTime(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e = GetSlot(this, p);
    return CalendarYearMonthFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e = GetSlot(this, p);
    return CalendarMonthDayFromFields(e, PrepareTemporalFields(this, CalendarFields(e, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e = dateTime(this), t2 = GetSlot(this, g);
    return { calendar: GetSlot(this, p), isoDay: GetSlot(e, l), isoHour: GetSlot(e, d), isoMicrosecond: GetSlot(e, u), isoMillisecond: GetSlot(e, h), isoMinute: GetSlot(e, m), isoMonth: GetSlot(e, s), isoNanosecond: GetSlot(e, T), isoSecond: GetSlot(e, c), isoYear: GetSlot(e, i), offset: GetOffsetStringFor(t2, GetSlot(this, S)), timeZone: t2 };
  }
  getCalendar() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  getTimeZone() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneObject(GetSlot(this, g));
  }
  static from(e, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalZonedDateTime(e) ? (ToTemporalDisambiguation(r2), ToTemporalOffset(r2, "reject"), ToTemporalOverflow(r2), CreateTemporalZonedDateTime(GetSlot(e, n), GetSlot(e, g), GetSlot(e, p))) : ToTemporalZonedDateTime(e, r2);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalZonedDateTime(t2), a2 = ToTemporalZonedDateTime(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return jsbi_default.lessThan(jsbi_default.BigInt(i2), jsbi_default.BigInt(s2)) ? -1 : jsbi_default.greaterThan(jsbi_default.BigInt(i2), jsbi_default.BigInt(s2)) ? 1 : 0;
  }
};
function dateTime(e) {
  return GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
}
MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
var Pt = Object.freeze({ __proto__: null, Calendar, Duration, Instant, Now: Et, PlainDate, PlainDateTime, PlainMonthDay, PlainTime, PlainYearMonth, TimeZone, ZonedDateTime });
function toTemporalInstant() {
  const t2 = jsbi_default.multiply(jsbi_default.BigInt(+this), Ge);
  return new Instant(t2);
}
var Zt = [Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime];
for (const e of Zt) {
  const t2 = Object.getOwnPropertyDescriptor(e, "prototype");
  (t2.configurable || t2.enumerable || t2.writable) && (t2.configurable = false, t2.enumerable = false, t2.writable = false, Object.defineProperty(e, "prototype", t2));
}
export {
  ut as Intl,
  Pt as Temporal,
  toTemporalInstant
};
//# sourceMappingURL=@js-temporal_polyfill.js.map
