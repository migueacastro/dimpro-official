import { t as Br, $ as al, i as rl, a0 as ol, a1 as zr, a2 as Ur, a3 as ll, a4 as cl, a5 as ul, a6 as hl, a7 as Fr, a8 as ya, a9 as sn, g as O, p as Kt, a as nn, C as Ea, aa as xt, w as Mt, ab as Cn, E as xa, H as jt, ac as Wr, ad as Os, c as dl, ae as xe, I as hi, K as di, e as se, af as yn, ag as ge, f as ye, x as ve, ah as pl, h as Ke, O as fl, ai as Re, z as Et, l as qt, aj as Gt, ak as gl, M as ml, al as Xr, y as _t, q as hn, n as Hn, am as Ps, an as vl, ao as yl, ap as pi, aq as Sa, A as Ae, ar as ba, as as Yr, at as El } from "./color-scale-utils-BPsvYA85.mjs";
import { y as at, $ as T, N as bt, r as Te, q as ze, L as xl, A as te, m as nt, s as Me, W as Je, S as kt, e as J, Z as Ue, i as Xt, f as Ta, J as $s, d as Sl, F as Bn, n as Vs, H as Gs, C as Hs, p as zn, b as Oa, D as Bs, U as bl, x as we, a0 as Un, O as zs } from "./axis-scales-CPuwbFQf.mjs";
import { R as lt } from "./a11y-ePqvrObQ.mjs";
import { t as ns, s as D, h as La, e as Ut, c as ss, f as Ce, g as oe, m as Us, i as Aa, j as Ma, k as Qe, l as Dt, n as wa, o as Tl, q as Ol, u as Bi, D as I, v as Ll, w as fi, G as Ca, x as zi, y as Al, a as Ml, p as Tt, r as ka, b as wl } from "./angle-utils-Re7uVv7K.mjs";
import { b as Zr, c as pt, a as Ui, s as Cl } from "./array-CLq6Q40W.mjs";
function kl(i, t, e, n) {
  for (var s = -1, a = i == null ? 0 : i.length; ++s < a; )
    e = t(e, i[s], s, i);
  return e;
}
function _l(i) {
  return function(t) {
    return i == null ? void 0 : i[t];
  };
}
var Il = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, Rl = _l(Il), Dl = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Nl = "\\u0300-\\u036f", Pl = "\\ufe20-\\ufe2f", $l = "\\u20d0-\\u20ff", Vl = Nl + Pl + $l, Gl = "[" + Vl + "]", Hl = RegExp(Gl, "g");
function Bl(i) {
  return i = Br(i), i && i.replace(Dl, Rl).replace(Hl, "");
}
var zl = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function Ul(i) {
  return i.match(zl) || [];
}
var Fl = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Wl(i) {
  return Fl.test(i);
}
var qr = "\\ud800-\\udfff", Xl = "\\u0300-\\u036f", Yl = "\\ufe20-\\ufe2f", Zl = "\\u20d0-\\u20ff", ql = Xl + Yl + Zl, jr = "\\u2700-\\u27bf", Kr = "a-z\\xdf-\\xf6\\xf8-\\xff", jl = "\\xac\\xb1\\xd7\\xf7", Kl = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Jl = "\\u2000-\\u206f", Ql = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Jr = "A-Z\\xc0-\\xd6\\xd8-\\xde", tc = "\\ufe0e\\ufe0f", Qr = jl + Kl + Jl + Ql, to = "['’]", _a = "[" + Qr + "]", ec = "[" + ql + "]", eo = "\\d+", nc = "[" + jr + "]", no = "[" + Kr + "]", so = "[^" + qr + Qr + eo + jr + Kr + Jr + "]", sc = "\\ud83c[\\udffb-\\udfff]", ic = "(?:" + ec + "|" + sc + ")", ac = "[^" + qr + "]", io = "(?:\\ud83c[\\udde6-\\uddff]){2}", ao = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ze = "[" + Jr + "]", rc = "\\u200d", Ia = "(?:" + no + "|" + so + ")", oc = "(?:" + Ze + "|" + so + ")", Ra = "(?:" + to + "(?:d|ll|m|re|s|t|ve))?", Da = "(?:" + to + "(?:D|LL|M|RE|S|T|VE))?", ro = ic + "?", oo = "[" + tc + "]?", lc = "(?:" + rc + "(?:" + [ac, io, ao].join("|") + ")" + oo + ro + ")*", cc = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", uc = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", hc = oo + ro + lc, dc = "(?:" + [nc, io, ao].join("|") + ")" + hc, pc = RegExp([
  Ze + "?" + no + "+" + Ra + "(?=" + [_a, Ze, "$"].join("|") + ")",
  oc + "+" + Da + "(?=" + [_a, Ze + Ia, "$"].join("|") + ")",
  Ze + "?" + Ia + "+" + Ra,
  Ze + "+" + Da,
  uc,
  cc,
  eo,
  dc
].join("|"), "g");
function fc(i) {
  return i.match(pc) || [];
}
function gc(i, t, e) {
  return i = Br(i), t = t, t === void 0 ? Wl(i) ? fc(i) : Ul(i) : i.match(t) || [];
}
var mc = "['’]", vc = RegExp(mc, "g");
function yc(i) {
  return function(t) {
    return kl(gc(Bl(t).replace(vc, "")), i, "");
  };
}
function Ec(i, t, e) {
  return i === i && (e !== void 0 && (i = i <= e ? i : e), t !== void 0 && (i = i >= t ? i : t)), i;
}
function lo(i, t, e) {
  return e === void 0 && (e = t, t = void 0), e !== void 0 && (e = ns(e), e = e === e ? e : 0), t !== void 0 && (t = ns(t), t = t === t ? t : 0), Ec(ns(i), t, e);
}
var xc = "Expected a function";
function Sc(i, t, e) {
  if (typeof i != "function")
    throw new TypeError(xc);
  return setTimeout(function() {
    i.apply(void 0, e);
  }, t);
}
var bc = al(function(i, t, e) {
  return Sc(i, ns(t) || 0, e);
});
function Tc(i, t) {
  var e = -1, n = rl(i) ? Array(i.length) : [];
  return Zr(i, function(s, a, r) {
    n[++e] = t(s, a, r);
  }), n;
}
function Oc(i, t) {
  var e = Ur(i) ? ol : Tc;
  return e(i, zr(t));
}
var Lc = 1 / 0;
function Ac(i, t) {
  return ll(Oc(i, t), Lc);
}
function co(i, t) {
  return cl(i, t);
}
var Fe = yc(function(i, t, e) {
  return i + (e ? "-" : "") + t.toLowerCase();
});
function Mc(i, t) {
  var e;
  return Zr(i, function(n, s, a) {
    return e = t(n, s, a), !e;
  }), !!e;
}
function wc(i, t, e) {
  var n = Ur(i) ? ul : Mc;
  return n(i, zr(t));
}
class De {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const e = this._partials;
    let n = 0;
    for (let s = 0; s < this._n && s < 32; s++) {
      const a = e[s], r = t + a, o = Math.abs(t) < Math.abs(a) ? t - (r - a) : a - (r - t);
      o && (e[n++] = o), t = r;
    }
    return e[n] = t, this._n = n + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let e = this._n, n, s, a, r = 0;
    if (e > 0) {
      for (r = t[--e]; e > 0 && (n = r, s = t[--e], r = n + s, a = s - (r - n), !a); )
        ;
      e > 0 && (a < 0 && t[e - 1] < 0 || a > 0 && t[e - 1] > 0) && (s = a * 2, n = r + s, s == n - r && (r = n));
    }
    return r;
  }
}
function* Cc(i) {
  for (const t of i)
    yield* t;
}
function uo(i) {
  return Array.from(Cc(i));
}
function kc(i) {
  return i;
}
var is = 1, as = 2, gi = 3, En = 4, Na = 1e-6;
function _c(i) {
  return "translate(" + i + ",0)";
}
function Ic(i) {
  return "translate(0," + i + ")";
}
function Rc(i) {
  return (t) => +i(t);
}
function Dc(i, t) {
  return t = Math.max(0, i.bandwidth() - t * 2) / 2, i.round() && (t = Math.round(t)), (e) => +i(e) + t;
}
function Nc() {
  return !this.__axis;
}
function Ls(i, t) {
  var e = [], n = null, s = null, a = 6, r = 6, o = 3, c = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, l = i === is || i === En ? -1 : 1, h = i === En || i === as ? "x" : "y", d = i === is || i === gi ? _c : Ic;
  function u(p) {
    var f = n ?? (t.ticks ? t.ticks.apply(t, e) : t.domain()), g = s ?? (t.tickFormat ? t.tickFormat.apply(t, e) : kc), m = Math.max(a, 0) + o, v = t.range(), S = +v[0] + c, y = +v[v.length - 1] + c, E = (t.bandwidth ? Dc : Rc)(t.copy(), c), x = p.selection ? p.selection() : p, b = x.selectAll(".domain").data([null]), k = x.selectAll(".tick").data(f, t).order(), _ = k.exit(), G = k.enter().append("g").attr("class", "tick"), R = k.select("line"), A = k.select("text");
    b = b.merge(b.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), k = k.merge(G), R = R.merge(G.append("line").attr("stroke", "currentColor").attr(h + "2", l * a)), A = A.merge(G.append("text").attr("fill", "currentColor").attr(h, l * m).attr("dy", i === is ? "0em" : i === gi ? "0.71em" : "0.32em")), p !== x && (b = b.transition(p), k = k.transition(p), R = R.transition(p), A = A.transition(p), _ = _.transition(p).attr("opacity", Na).attr("transform", function(H) {
      return isFinite(H = E(H)) ? d(H + c) : this.getAttribute("transform");
    }), G.attr("opacity", Na).attr("transform", function(H) {
      var N = this.parentNode.__axis;
      return d((N && isFinite(N = N(H)) ? N : E(H)) + c);
    })), _.remove(), b.attr("d", i === En || i === as ? r ? "M" + l * r + "," + S + "H" + c + "V" + y + "H" + l * r : "M" + c + "," + S + "V" + y : r ? "M" + S + "," + l * r + "V" + c + "H" + y + "V" + l * r : "M" + S + "," + c + "H" + y), k.attr("opacity", 1).attr("transform", function(H) {
      return d(E(H) + c);
    }), R.attr(h + "2", l * a), A.attr(h, l * m).text(g), x.filter(Nc).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", i === as ? "start" : i === En ? "end" : "middle"), x.each(function() {
      this.__axis = E;
    });
  }
  return u.scale = function(p) {
    return arguments.length ? (t = p, u) : t;
  }, u.ticks = function() {
    return e = Array.from(arguments), u;
  }, u.tickArguments = function(p) {
    return arguments.length ? (e = p == null ? [] : Array.from(p), u) : e.slice();
  }, u.tickValues = function(p) {
    return arguments.length ? (n = p == null ? null : Array.from(p), u) : n && n.slice();
  }, u.tickFormat = function(p) {
    return arguments.length ? (s = p, u) : s;
  }, u.tickSize = function(p) {
    return arguments.length ? (a = r = +p, u) : a;
  }, u.tickSizeInner = function(p) {
    return arguments.length ? (a = +p, u) : a;
  }, u.tickSizeOuter = function(p) {
    return arguments.length ? (r = +p, u) : r;
  }, u.tickPadding = function(p) {
    return arguments.length ? (o = +p, u) : o;
  }, u.offset = function(p) {
    return arguments.length ? (c = +p, u) : c;
  }, u;
}
function Pc(i) {
  return Ls(is, i);
}
function $c(i) {
  return Ls(as, i);
}
function Fi(i) {
  return Ls(gi, i);
}
function ho(i) {
  return Ls(En, i);
}
const mi = { capture: !0, passive: !1 };
function vi(i) {
  i.preventDefault(), i.stopImmediatePropagation();
}
function Vc(i) {
  var t = i.document.documentElement, e = D(i).on("dragstart.drag", vi, mi);
  "onselectstart" in t ? e.on("selectstart.drag", vi, mi) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Gc(i, t) {
  var e = i.document.documentElement, n = D(i).on("dragstart.drag", null);
  t && (n.on("click.drag", vi, mi), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in e ? n.on("selectstart.drag", null) : (e.style.MozUserSelect = e.__noselect, delete e.__noselect);
}
function Hc(i, t) {
  for (var e = new Array(t), n = 0; n < t; ++n) e[n] = i(n / (t - 1));
  return e;
}
const Bc = (i) => +i, Fs = (i) => () => i;
function zc(i, {
  sourceEvent: t,
  target: e,
  selection: n,
  mode: s,
  dispatch: a
}) {
  Object.defineProperties(this, {
    type: { value: i, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: e, enumerable: !0, configurable: !0 },
    selection: { value: n, enumerable: !0, configurable: !0 },
    mode: { value: s, enumerable: !0, configurable: !0 },
    _: { value: a }
  });
}
function Uc(i) {
  i.stopImmediatePropagation();
}
function Ws(i) {
  i.preventDefault(), i.stopImmediatePropagation();
}
var Pa = { name: "drag" }, Xs = { name: "space" }, We = { name: "handle" }, Xe = { name: "center" };
const { abs: $a, max: Nt, min: Pt } = Math;
function Va(i) {
  return [+i[0], +i[1]];
}
function Ga(i) {
  return [Va(i[0]), Va(i[1])];
}
var rs = {
  name: "x",
  handles: ["w", "e"].map(yi),
  input: function(i, t) {
    return i == null ? null : [[+i[0], t[0][1]], [+i[1], t[1][1]]];
  },
  output: function(i) {
    return i && [i[0][0], i[1][0]];
  }
}, Ys = {}, fe = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, Ha = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, Ba = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, Fc = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, Wc = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function yi(i) {
  return { type: i };
}
function Xc(i) {
  return !i.ctrlKey && !i.button;
}
function Yc() {
  var i = this.ownerSVGElement || this;
  return i.hasAttribute("viewBox") ? (i = i.viewBox.baseVal, [[i.x, i.y], [i.x + i.width, i.y + i.height]]) : [[0, 0], [i.width.baseVal.value, i.height.baseVal.value]];
}
function Zc() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Zs(i) {
  for (; !i.__brush; ) if (!(i = i.parentNode)) return;
  return i.__brush;
}
function qc(i) {
  return i[0][0] === i[1][0] || i[0][1] === i[1][1];
}
function po() {
  return jc(rs);
}
function jc(i) {
  var t = Yc, e = Xc, n = Zc, s = !0, a = hl("start", "brush", "end"), r = 6, o;
  function c(m) {
    var v = m.property("__brush", g).selectAll(".overlay").data([yi("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", fe.overlay).merge(v).each(function() {
      var y = Zs(this).extent;
      D(this).attr("x", y[0][0]).attr("y", y[0][1]).attr("width", y[1][0] - y[0][0]).attr("height", y[1][1] - y[0][1]);
    }), m.selectAll(".selection").data([yi("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", fe.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var S = m.selectAll(".handle").data(i.handles, function(y) {
      return y.type;
    });
    S.exit().remove(), S.enter().append("rect").attr("class", function(y) {
      return "handle handle--" + y.type;
    }).attr("cursor", function(y) {
      return fe[y.type];
    }), m.each(l).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", u).filter(n).on("touchstart.brush", u).on("touchmove.brush", p).on("touchend.brush touchcancel.brush", f).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  c.move = function(m, v, S) {
    m.tween ? m.on("start.brush", function(y) {
      h(this, arguments).beforestart().start(y);
    }).on("interrupt.brush end.brush", function(y) {
      h(this, arguments).end(y);
    }).tween("brush", function() {
      var y = this, E = y.__brush, x = h(y, arguments), b = E.selection, k = i.input(typeof v == "function" ? v.apply(this, arguments) : v, E.extent), _ = Fr(b, k);
      function G(R) {
        E.selection = R === 1 && k === null ? null : _(R), l.call(y), x.brush();
      }
      return b !== null && k !== null ? G : G(1);
    }) : m.each(function() {
      var y = this, E = arguments, x = y.__brush, b = i.input(typeof v == "function" ? v.apply(y, E) : v, x.extent), k = h(y, E).beforestart();
      ya(y), x.selection = b === null ? null : b, l.call(y), k.start(S).brush(S).end(S);
    });
  }, c.clear = function(m, v) {
    c.move(m, null, v);
  };
  function l() {
    var m = D(this), v = Zs(this).selection;
    v ? (m.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(S) {
      return S.type[S.type.length - 1] === "e" ? v[1][0] - r / 2 : v[0][0] - r / 2;
    }).attr("y", function(S) {
      return S.type[0] === "s" ? v[1][1] - r / 2 : v[0][1] - r / 2;
    }).attr("width", function(S) {
      return S.type === "n" || S.type === "s" ? v[1][0] - v[0][0] + r : r;
    }).attr("height", function(S) {
      return S.type === "e" || S.type === "w" ? v[1][1] - v[0][1] + r : r;
    })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function h(m, v, S) {
    var y = m.__brush.emitter;
    return y && (!S || !y.clean) ? y : new d(m, v, S);
  }
  function d(m, v, S) {
    this.that = m, this.args = v, this.state = m.__brush, this.active = 0, this.clean = S;
  }
  d.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(m, v) {
      return this.starting ? (this.starting = !1, this.emit("start", m, v)) : this.emit("brush", m), this;
    },
    brush: function(m, v) {
      return this.emit("brush", m, v), this;
    },
    end: function(m, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, v)), this;
    },
    emit: function(m, v, S) {
      var y = D(this.that).datum();
      a.call(
        m,
        this.that,
        new zc(m, {
          sourceEvent: v,
          target: c,
          selection: i.output(this.state.selection),
          mode: S,
          dispatch: a
        }),
        y
      );
    }
  };
  function u(m) {
    if (o && !m.touches || !e.apply(this, arguments)) return;
    var v = this, S = m.target.__data__.type, y = (s && m.metaKey ? S = "overlay" : S) === "selection" ? Pa : s && m.altKey ? Xe : We, E = i === Ys ? null : Fc[S], x = i === rs ? null : Wc[S], b = Zs(v), k = b.extent, _ = b.selection, G = k[0][0], R, A, H = k[0][1], N, M, L = k[1][0], P, $, C = k[1][1], V, q, X = 0, F = 0, Z, rt = E && x && s && m.shiftKey, j, Y, K = Array.from(m.touches || [m], (et) => {
      const yt = et.identifier;
      return et = sn(et, v), et.point0 = et.slice(), et.identifier = yt, et;
    });
    ya(v);
    var ot = h(v, arguments, !0).beforestart();
    if (S === "overlay") {
      _ && (Z = !0);
      const et = [K[0], K[1] || K[0]];
      b.selection = _ = [[
        R = i === Ys ? G : Pt(et[0][0], et[1][0]),
        N = i === rs ? H : Pt(et[0][1], et[1][1])
      ], [
        P = i === Ys ? L : Nt(et[0][0], et[1][0]),
        V = i === rs ? C : Nt(et[0][1], et[1][1])
      ]], K.length > 1 && B(m);
    } else
      R = _[0][0], N = _[0][1], P = _[1][0], V = _[1][1];
    A = R, M = N, $ = P, q = V;
    var ct = D(v).attr("pointer-events", "none"), st = ct.selectAll(".overlay").attr("cursor", fe[S]);
    if (m.touches)
      ot.moved = z, ot.ended = U;
    else {
      var it = D(m.view).on("mousemove.brush", z, !0).on("mouseup.brush", U, !0);
      s && it.on("keydown.brush", wt, !0).on("keyup.brush", be, !0), Vc(m.view);
    }
    l.call(v), ot.start(m, y.name);
    function z(et) {
      for (const yt of et.changedTouches || [et])
        for (const Zt of K)
          Zt.identifier === yt.identifier && (Zt.cur = sn(yt, v));
      if (rt && !j && !Y && K.length === 1) {
        const yt = K[0];
        $a(yt.cur[0] - yt[0]) > $a(yt.cur[1] - yt[1]) ? Y = !0 : j = !0;
      }
      for (const yt of K)
        yt.cur && (yt[0] = yt.cur[0], yt[1] = yt.cur[1]);
      Z = !0, Ws(et), B(et);
    }
    function B(et) {
      const yt = K[0], Zt = yt.point0;
      var Wt;
      switch (X = yt[0] - Zt[0], F = yt[1] - Zt[1], y) {
        case Xs:
        case Pa: {
          E && (X = Nt(G - R, Pt(L - P, X)), A = R + X, $ = P + X), x && (F = Nt(H - N, Pt(C - V, F)), M = N + F, q = V + F);
          break;
        }
        case We: {
          K[1] ? (E && (A = Nt(G, Pt(L, K[0][0])), $ = Nt(G, Pt(L, K[1][0])), E = 1), x && (M = Nt(H, Pt(C, K[0][1])), q = Nt(H, Pt(C, K[1][1])), x = 1)) : (E < 0 ? (X = Nt(G - R, Pt(L - R, X)), A = R + X, $ = P) : E > 0 && (X = Nt(G - P, Pt(L - P, X)), A = R, $ = P + X), x < 0 ? (F = Nt(H - N, Pt(C - N, F)), M = N + F, q = V) : x > 0 && (F = Nt(H - V, Pt(C - V, F)), M = N, q = V + F));
          break;
        }
        case Xe: {
          E && (A = Nt(G, Pt(L, R - X * E)), $ = Nt(G, Pt(L, P + X * E))), x && (M = Nt(H, Pt(C, N - F * x)), q = Nt(H, Pt(C, V + F * x)));
          break;
        }
      }
      $ < A && (E *= -1, Wt = R, R = P, P = Wt, Wt = A, A = $, $ = Wt, S in Ha && st.attr("cursor", fe[S = Ha[S]])), q < M && (x *= -1, Wt = N, N = V, V = Wt, Wt = M, M = q, q = Wt, S in Ba && st.attr("cursor", fe[S = Ba[S]])), b.selection && (_ = b.selection), j && (A = _[0][0], $ = _[1][0]), Y && (M = _[0][1], q = _[1][1]), (_[0][0] !== A || _[0][1] !== M || _[1][0] !== $ || _[1][1] !== q) && (b.selection = [[A, M], [$, q]], l.call(v), ot.brush(et, y.name));
    }
    function U(et) {
      if (Uc(et), et.touches) {
        if (et.touches.length) return;
        o && clearTimeout(o), o = setTimeout(function() {
          o = null;
        }, 500);
      } else
        Gc(et.view, Z), it.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      ct.attr("pointer-events", "all"), st.attr("cursor", fe.overlay), b.selection && (_ = b.selection), qc(_) && (b.selection = null, l.call(v)), ot.end(et, y.name);
    }
    function wt(et) {
      switch (et.keyCode) {
        case 16: {
          rt = E && x;
          break;
        }
        case 18: {
          y === We && (E && (P = $ - X * E, R = A + X * E), x && (V = q - F * x, N = M + F * x), y = Xe, B(et));
          break;
        }
        case 32: {
          (y === We || y === Xe) && (E < 0 ? P = $ - X : E > 0 && (R = A - X), x < 0 ? V = q - F : x > 0 && (N = M - F), y = Xs, st.attr("cursor", fe.selection), B(et));
          break;
        }
        default:
          return;
      }
      Ws(et);
    }
    function be(et) {
      switch (et.keyCode) {
        case 16: {
          rt && (j = Y = rt = !1, B(et));
          break;
        }
        case 18: {
          y === Xe && (E < 0 ? P = $ : E > 0 && (R = A), x < 0 ? V = q : x > 0 && (N = M), y = We, B(et));
          break;
        }
        case 32: {
          y === Xs && (et.altKey ? (E && (P = $ - X * E, R = A + X * E), x && (V = q - F * x, N = M + F * x), y = Xe) : (E < 0 ? P = $ : E > 0 && (R = A), x < 0 ? V = q : x > 0 && (N = M), y = We), st.attr("cursor", fe[S]), B(et));
          break;
        }
        default:
          return;
      }
      Ws(et);
    }
  }
  function p(m) {
    h(this, arguments).moved(m);
  }
  function f(m) {
    h(this, arguments).ended(m);
  }
  function g() {
    var m = this.__brush || { selection: null };
    return m.extent = Ga(t.apply(this, arguments)), m.dim = i, m;
  }
  return c.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : Fs(Ga(m)), c) : t;
  }, c.filter = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Fs(!!m), c) : e;
  }, c.touchable = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Fs(!!m), c) : n;
  }, c.handleSize = function(m) {
    return arguments.length ? (r = +m, c) : r;
  }, c.keyModifiers = function(m) {
    return arguments.length ? (s = !!m, c) : s;
  }, c.on = function() {
    var m = a.on.apply(a, arguments);
    return m === a ? c : m;
  }, c;
}
const Ei = Math.PI, xi = 2 * Ei, ke = 1e-6, Kc = xi - ke;
function fo(i) {
  this._ += i[0];
  for (let t = 1, e = i.length; t < e; ++t)
    this._ += arguments[t] + i[t];
}
function Jc(i) {
  let t = Math.floor(i);
  if (!(t >= 0)) throw new Error(`invalid digits: ${i}`);
  if (t > 15) return fo;
  const e = 10 ** t;
  return function(n) {
    this._ += n[0];
    for (let s = 1, a = n.length; s < a; ++s)
      this._ += Math.round(arguments[s] * e) / e + n[s];
  };
}
let Wi = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? fo : Jc(t);
  }
  moveTo(t, e) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, e) {
    this._append`L${this._x1 = +t},${this._y1 = +e}`;
  }
  quadraticCurveTo(t, e, n, s) {
    this._append`Q${+t},${+e},${this._x1 = +n},${this._y1 = +s}`;
  }
  bezierCurveTo(t, e, n, s, a, r) {
    this._append`C${+t},${+e},${+n},${+s},${this._x1 = +a},${this._y1 = +r}`;
  }
  arcTo(t, e, n, s, a) {
    if (t = +t, e = +e, n = +n, s = +s, a = +a, a < 0) throw new Error(`negative radius: ${a}`);
    let r = this._x1, o = this._y1, c = n - t, l = s - e, h = r - t, d = o - e, u = h * h + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = e}`;
    else if (u > ke) if (!(Math.abs(d * c - l * h) > ke) || !a)
      this._append`L${this._x1 = t},${this._y1 = e}`;
    else {
      let p = n - r, f = s - o, g = c * c + l * l, m = p * p + f * f, v = Math.sqrt(g), S = Math.sqrt(u), y = a * Math.tan((Ei - Math.acos((g + u - m) / (2 * v * S))) / 2), E = y / S, x = y / v;
      Math.abs(E - 1) > ke && this._append`L${t + E * h},${e + E * d}`, this._append`A${a},${a},0,0,${+(d * p > h * f)},${this._x1 = t + x * c},${this._y1 = e + x * l}`;
    }
  }
  arc(t, e, n, s, a, r) {
    if (t = +t, e = +e, n = +n, r = !!r, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(s), c = n * Math.sin(s), l = t + o, h = e + c, d = 1 ^ r, u = r ? s - a : a - s;
    this._x1 === null ? this._append`M${l},${h}` : (Math.abs(this._x1 - l) > ke || Math.abs(this._y1 - h) > ke) && this._append`L${l},${h}`, n && (u < 0 && (u = u % xi + xi), u > Kc ? this._append`A${n},${n},0,1,${d},${t - o},${e - c}A${n},${n},0,1,${d},${this._x1 = l},${this._y1 = h}` : u > ke && this._append`A${n},${n},0,${+(u >= Ei)},${d},${this._x1 = t + n * Math.cos(a)},${this._y1 = e + n * Math.sin(a)}`);
  }
  rect(t, e, n, s) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}h${n = +n}v${+s}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function As() {
  return new Wi();
}
As.prototype = Wi.prototype;
var vt = 1e-6, Qc = 1e-12, ht = Math.PI, Ft = ht / 2, za = ht / 4, Yt = ht * 2, Vt = 180 / ht, Ot = ht / 180, gt = Math.abs, go = Math.atan, Ne = Math.atan2, mt = Math.cos, tu = Math.exp, eu = Math.log, ft = Math.sin, Oe = Math.sign || function(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}, ae = Math.sqrt, nu = Math.tan;
function su(i) {
  return i > 1 ? 0 : i < -1 ? ht : Math.acos(i);
}
function Se(i) {
  return i > 1 ? Ft : i < -1 ? -Ft : Math.asin(i);
}
function Qt() {
}
function hs(i, t) {
  i && Fa.hasOwnProperty(i.type) && Fa[i.type](i, t);
}
var Ua = {
  Feature: function(i, t) {
    hs(i.geometry, t);
  },
  FeatureCollection: function(i, t) {
    for (var e = i.features, n = -1, s = e.length; ++n < s; ) hs(e[n].geometry, t);
  }
}, Fa = {
  Sphere: function(i, t) {
    t.sphere();
  },
  Point: function(i, t) {
    i = i.coordinates, t.point(i[0], i[1], i[2]);
  },
  MultiPoint: function(i, t) {
    for (var e = i.coordinates, n = -1, s = e.length; ++n < s; ) i = e[n], t.point(i[0], i[1], i[2]);
  },
  LineString: function(i, t) {
    Si(i.coordinates, t, 0);
  },
  MultiLineString: function(i, t) {
    for (var e = i.coordinates, n = -1, s = e.length; ++n < s; ) Si(e[n], t, 0);
  },
  Polygon: function(i, t) {
    Wa(i.coordinates, t);
  },
  MultiPolygon: function(i, t) {
    for (var e = i.coordinates, n = -1, s = e.length; ++n < s; ) Wa(e[n], t);
  },
  GeometryCollection: function(i, t) {
    for (var e = i.geometries, n = -1, s = e.length; ++n < s; ) hs(e[n], t);
  }
};
function Si(i, t, e) {
  var n = -1, s = i.length - e, a;
  for (t.lineStart(); ++n < s; ) a = i[n], t.point(a[0], a[1], a[2]);
  t.lineEnd();
}
function Wa(i, t) {
  var e = -1, n = i.length;
  for (t.polygonStart(); ++e < n; ) Si(i[e], t, 1);
  t.polygonEnd();
}
function qe(i, t) {
  i && Ua.hasOwnProperty(i.type) ? Ua[i.type](i, t) : hs(i, t);
}
function bi(i) {
  return [Ne(i[1], i[0]), Se(i[2])];
}
function an(i) {
  var t = i[0], e = i[1], n = mt(e);
  return [n * mt(t), n * ft(t), ft(e)];
}
function Fn(i, t) {
  return i[0] * t[0] + i[1] * t[1] + i[2] * t[2];
}
function ds(i, t) {
  return [i[1] * t[2] - i[2] * t[1], i[2] * t[0] - i[0] * t[2], i[0] * t[1] - i[1] * t[0]];
}
function qs(i, t) {
  i[0] += t[0], i[1] += t[1], i[2] += t[2];
}
function Wn(i, t) {
  return [i[0] * t, i[1] * t, i[2] * t];
}
function Ti(i) {
  var t = ae(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]);
  i[0] /= t, i[1] /= t, i[2] /= t;
}
function Oi(i, t) {
  function e(n, s) {
    return n = i(n, s), t(n[0], n[1]);
  }
  return i.invert && t.invert && (e.invert = function(n, s) {
    return n = t.invert(n, s), n && i.invert(n[0], n[1]);
  }), e;
}
function Li(i, t) {
  return gt(i) > ht && (i -= Math.round(i / Yt) * Yt), [i, t];
}
Li.invert = Li;
function mo(i, t, e) {
  return (i %= Yt) ? t || e ? Oi(Ya(i), Za(t, e)) : Ya(i) : t || e ? Za(t, e) : Li;
}
function Xa(i) {
  return function(t, e) {
    return t += i, gt(t) > ht && (t -= Math.round(t / Yt) * Yt), [t, e];
  };
}
function Ya(i) {
  var t = Xa(i);
  return t.invert = Xa(-i), t;
}
function Za(i, t) {
  var e = mt(i), n = ft(i), s = mt(t), a = ft(t);
  function r(o, c) {
    var l = mt(c), h = mt(o) * l, d = ft(o) * l, u = ft(c), p = u * e + h * n;
    return [
      Ne(d * s - p * a, h * e - u * n),
      Se(p * s + d * a)
    ];
  }
  return r.invert = function(o, c) {
    var l = mt(c), h = mt(o) * l, d = ft(o) * l, u = ft(c), p = u * s - d * a;
    return [
      Ne(d * s + u * a, h * e + p * n),
      Se(p * e - h * n)
    ];
  }, r;
}
function iu(i) {
  i = mo(i[0] * Ot, i[1] * Ot, i.length > 2 ? i[2] * Ot : 0);
  function t(e) {
    return e = i(e[0] * Ot, e[1] * Ot), e[0] *= Vt, e[1] *= Vt, e;
  }
  return t.invert = function(e) {
    return e = i.invert(e[0] * Ot, e[1] * Ot), e[0] *= Vt, e[1] *= Vt, e;
  }, t;
}
function au(i, t, e, n, s, a) {
  if (e) {
    var r = mt(t), o = ft(t), c = n * e;
    s == null ? (s = t + n * Yt, a = t - c / 2) : (s = qa(r, s), a = qa(r, a), (n > 0 ? s < a : s > a) && (s += n * Yt));
    for (var l, h = s; n > 0 ? h > a : h < a; h -= c)
      l = bi([r, -o * mt(h), -o * ft(h)]), i.point(l[0], l[1]);
  }
}
function qa(i, t) {
  t = an(t), t[0] -= i, Ti(t);
  var e = su(-t[1]);
  return ((-t[2] < 0 ? -e : e) + Yt - vt) % Yt;
}
function vo() {
  var i = [], t;
  return {
    point: function(e, n, s) {
      t.push([e, n, s]);
    },
    lineStart: function() {
      i.push(t = []);
    },
    lineEnd: Qt,
    rejoin: function() {
      i.length > 1 && i.push(i.pop().concat(i.shift()));
    },
    result: function() {
      var e = i;
      return i = [], t = null, e;
    }
  };
}
function os(i, t) {
  return gt(i[0] - t[0]) < vt && gt(i[1] - t[1]) < vt;
}
function Xn(i, t, e, n) {
  this.x = i, this.z = t, this.o = e, this.e = n, this.v = !1, this.n = this.p = null;
}
function yo(i, t, e, n, s) {
  var a = [], r = [], o, c;
  if (i.forEach(function(f) {
    if (!((g = f.length - 1) <= 0)) {
      var g, m = f[0], v = f[g], S;
      if (os(m, v)) {
        if (!m[2] && !v[2]) {
          for (s.lineStart(), o = 0; o < g; ++o) s.point((m = f[o])[0], m[1]);
          s.lineEnd();
          return;
        }
        v[0] += 2 * vt;
      }
      a.push(S = new Xn(m, f, null, !0)), r.push(S.o = new Xn(m, null, S, !1)), a.push(S = new Xn(v, f, null, !1)), r.push(S.o = new Xn(v, null, S, !0));
    }
  }), !!a.length) {
    for (r.sort(t), ja(a), ja(r), o = 0, c = r.length; o < c; ++o)
      r[o].e = e = !e;
    for (var l = a[0], h, d; ; ) {
      for (var u = l, p = !0; u.v; ) if ((u = u.n) === l) return;
      h = u.z, s.lineStart();
      do {
        if (u.v = u.o.v = !0, u.e) {
          if (p)
            for (o = 0, c = h.length; o < c; ++o) s.point((d = h[o])[0], d[1]);
          else
            n(u.x, u.n.x, 1, s);
          u = u.n;
        } else {
          if (p)
            for (h = u.p.z, o = h.length - 1; o >= 0; --o) s.point((d = h[o])[0], d[1]);
          else
            n(u.x, u.p.x, -1, s);
          u = u.p;
        }
        u = u.o, h = u.z, p = !p;
      } while (!u.v);
      s.lineEnd();
    }
  }
}
function ja(i) {
  if (t = i.length) {
    for (var t, e = 0, n = i[0], s; ++e < t; )
      n.n = s = i[e], s.p = n, n = s;
    n.n = s = i[0], s.p = n;
  }
}
function js(i) {
  return gt(i[0]) <= ht ? i[0] : Oe(i[0]) * ((gt(i[0]) + ht) % Yt - ht);
}
function ru(i, t) {
  var e = js(t), n = t[1], s = ft(n), a = [ft(e), -mt(e), 0], r = 0, o = 0, c = new De();
  s === 1 ? n = Ft + vt : s === -1 && (n = -Ft - vt);
  for (var l = 0, h = i.length; l < h; ++l)
    if (u = (d = i[l]).length)
      for (var d, u, p = d[u - 1], f = js(p), g = p[1] / 2 + za, m = ft(g), v = mt(g), S = 0; S < u; ++S, f = E, m = b, v = k, p = y) {
        var y = d[S], E = js(y), x = y[1] / 2 + za, b = ft(x), k = mt(x), _ = E - f, G = _ >= 0 ? 1 : -1, R = G * _, A = R > ht, H = m * b;
        if (c.add(Ne(H * G * ft(R), v * k + H * mt(R))), r += A ? _ + G * Yt : _, A ^ f >= e ^ E >= e) {
          var N = ds(an(p), an(y));
          Ti(N);
          var M = ds(a, N);
          Ti(M);
          var L = (A ^ _ >= 0 ? -1 : 1) * Se(M[2]);
          (n > L || n === L && (N[0] || N[1])) && (o += A ^ _ >= 0 ? 1 : -1);
        }
      }
  return (r < -1e-6 || r < vt && c < -1e-12) ^ o & 1;
}
function Eo(i, t, e, n) {
  return function(s) {
    var a = t(s), r = vo(), o = t(r), c = !1, l, h, d, u = {
      point: p,
      lineStart: g,
      lineEnd: m,
      polygonStart: function() {
        u.point = v, u.lineStart = S, u.lineEnd = y, h = [], l = [];
      },
      polygonEnd: function() {
        u.point = p, u.lineStart = g, u.lineEnd = m, h = uo(h);
        var E = ru(l, n);
        h.length ? (c || (s.polygonStart(), c = !0), yo(h, lu, E, e, s)) : E && (c || (s.polygonStart(), c = !0), s.lineStart(), e(null, null, 1, s), s.lineEnd()), c && (s.polygonEnd(), c = !1), h = l = null;
      },
      sphere: function() {
        s.polygonStart(), s.lineStart(), e(null, null, 1, s), s.lineEnd(), s.polygonEnd();
      }
    };
    function p(E, x) {
      i(E, x) && s.point(E, x);
    }
    function f(E, x) {
      a.point(E, x);
    }
    function g() {
      u.point = f, a.lineStart();
    }
    function m() {
      u.point = p, a.lineEnd();
    }
    function v(E, x) {
      d.push([E, x]), o.point(E, x);
    }
    function S() {
      o.lineStart(), d = [];
    }
    function y() {
      v(d[0][0], d[0][1]), o.lineEnd();
      var E = o.clean(), x = r.result(), b, k = x.length, _, G, R;
      if (d.pop(), l.push(d), d = null, !!k) {
        if (E & 1) {
          if (G = x[0], (_ = G.length - 1) > 0) {
            for (c || (s.polygonStart(), c = !0), s.lineStart(), b = 0; b < _; ++b) s.point((R = G[b])[0], R[1]);
            s.lineEnd();
          }
          return;
        }
        k > 1 && E & 2 && x.push(x.pop().concat(x.shift())), h.push(x.filter(ou));
      }
    }
    return u;
  };
}
function ou(i) {
  return i.length > 1;
}
function lu(i, t) {
  return ((i = i.x)[0] < 0 ? i[1] - Ft - vt : Ft - i[1]) - ((t = t.x)[0] < 0 ? t[1] - Ft - vt : Ft - t[1]);
}
const Ka = Eo(
  function() {
    return !0;
  },
  cu,
  hu,
  [-ht, -Ft]
);
function cu(i) {
  var t = NaN, e = NaN, n = NaN, s;
  return {
    lineStart: function() {
      i.lineStart(), s = 1;
    },
    point: function(a, r) {
      var o = a > 0 ? ht : -ht, c = gt(a - t);
      gt(c - ht) < vt ? (i.point(t, e = (e + r) / 2 > 0 ? Ft : -Ft), i.point(n, e), i.lineEnd(), i.lineStart(), i.point(o, e), i.point(a, e), s = 0) : n !== o && c >= ht && (gt(t - n) < vt && (t -= n * vt), gt(a - o) < vt && (a -= o * vt), e = uu(t, e, a, r), i.point(n, e), i.lineEnd(), i.lineStart(), i.point(o, e), s = 0), i.point(t = a, e = r), n = o;
    },
    lineEnd: function() {
      i.lineEnd(), t = e = NaN;
    },
    clean: function() {
      return 2 - s;
    }
  };
}
function uu(i, t, e, n) {
  var s, a, r = ft(i - e);
  return gt(r) > vt ? go((ft(t) * (a = mt(n)) * ft(e) - ft(n) * (s = mt(t)) * ft(i)) / (s * a * r)) : (t + n) / 2;
}
function hu(i, t, e, n) {
  var s;
  if (i == null)
    s = e * Ft, n.point(-ht, s), n.point(0, s), n.point(ht, s), n.point(ht, 0), n.point(ht, -s), n.point(0, -s), n.point(-ht, -s), n.point(-ht, 0), n.point(-ht, s);
  else if (gt(i[0] - t[0]) > vt) {
    var a = i[0] < t[0] ? ht : -ht;
    s = e * a / 2, n.point(-a, s), n.point(0, s), n.point(a, s);
  } else
    n.point(t[0], t[1]);
}
function du(i) {
  var t = mt(i), e = 2 * Ot, n = t > 0, s = gt(t) > vt;
  function a(h, d, u, p) {
    au(p, i, e, u, h, d);
  }
  function r(h, d) {
    return mt(h) * mt(d) > t;
  }
  function o(h) {
    var d, u, p, f, g;
    return {
      lineStart: function() {
        f = p = !1, g = 1;
      },
      point: function(m, v) {
        var S = [m, v], y, E = r(m, v), x = n ? E ? 0 : l(m, v) : E ? l(m + (m < 0 ? ht : -ht), v) : 0;
        if (!d && (f = p = E) && h.lineStart(), E !== p && (y = c(d, S), (!y || os(d, y) || os(S, y)) && (S[2] = 1)), E !== p)
          g = 0, E ? (h.lineStart(), y = c(S, d), h.point(y[0], y[1])) : (y = c(d, S), h.point(y[0], y[1], 2), h.lineEnd()), d = y;
        else if (s && d && n ^ E) {
          var b;
          !(x & u) && (b = c(S, d, !0)) && (g = 0, n ? (h.lineStart(), h.point(b[0][0], b[0][1]), h.point(b[1][0], b[1][1]), h.lineEnd()) : (h.point(b[1][0], b[1][1]), h.lineEnd(), h.lineStart(), h.point(b[0][0], b[0][1], 3)));
        }
        E && (!d || !os(d, S)) && h.point(S[0], S[1]), d = S, p = E, u = x;
      },
      lineEnd: function() {
        p && h.lineEnd(), d = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return g | (f && p) << 1;
      }
    };
  }
  function c(h, d, u) {
    var p = an(h), f = an(d), g = [1, 0, 0], m = ds(p, f), v = Fn(m, m), S = m[0], y = v - S * S;
    if (!y) return !u && h;
    var E = t * v / y, x = -t * S / y, b = ds(g, m), k = Wn(g, E), _ = Wn(m, x);
    qs(k, _);
    var G = b, R = Fn(k, G), A = Fn(G, G), H = R * R - A * (Fn(k, k) - 1);
    if (!(H < 0)) {
      var N = ae(H), M = Wn(G, (-R - N) / A);
      if (qs(M, k), M = bi(M), !u) return M;
      var L = h[0], P = d[0], $ = h[1], C = d[1], V;
      P < L && (V = L, L = P, P = V);
      var q = P - L, X = gt(q - ht) < vt, F = X || q < vt;
      if (!X && C < $ && (V = $, $ = C, C = V), F ? X ? $ + C > 0 ^ M[1] < (gt(M[0] - L) < vt ? $ : C) : $ <= M[1] && M[1] <= C : q > ht ^ (L <= M[0] && M[0] <= P)) {
        var Z = Wn(G, (-R + N) / A);
        return qs(Z, k), [M, bi(Z)];
      }
    }
  }
  function l(h, d) {
    var u = n ? i : ht - i, p = 0;
    return h < -u ? p |= 1 : h > u && (p |= 2), d < -u ? p |= 4 : d > u && (p |= 8), p;
  }
  return Eo(r, o, a, n ? [0, -i] : [-ht, i - ht]);
}
function pu(i, t, e, n, s, a) {
  var r = i[0], o = i[1], c = t[0], l = t[1], h = 0, d = 1, u = c - r, p = l - o, f;
  if (f = e - r, !(!u && f > 0)) {
    if (f /= u, u < 0) {
      if (f < h) return;
      f < d && (d = f);
    } else if (u > 0) {
      if (f > d) return;
      f > h && (h = f);
    }
    if (f = s - r, !(!u && f < 0)) {
      if (f /= u, u < 0) {
        if (f > d) return;
        f > h && (h = f);
      } else if (u > 0) {
        if (f < h) return;
        f < d && (d = f);
      }
      if (f = n - o, !(!p && f > 0)) {
        if (f /= p, p < 0) {
          if (f < h) return;
          f < d && (d = f);
        } else if (p > 0) {
          if (f > d) return;
          f > h && (h = f);
        }
        if (f = a - o, !(!p && f < 0)) {
          if (f /= p, p < 0) {
            if (f > d) return;
            f > h && (h = f);
          } else if (p > 0) {
            if (f < h) return;
            f < d && (d = f);
          }
          return h > 0 && (i[0] = r + h * u, i[1] = o + h * p), d < 1 && (t[0] = r + d * u, t[1] = o + d * p), !0;
        }
      }
    }
  }
}
var Yn = 1e9, Zn = -1e9;
function fu(i, t, e, n) {
  function s(l, h) {
    return i <= l && l <= e && t <= h && h <= n;
  }
  function a(l, h, d, u) {
    var p = 0, f = 0;
    if (l == null || (p = r(l, d)) !== (f = r(h, d)) || c(l, h) < 0 ^ d > 0)
      do
        u.point(p === 0 || p === 3 ? i : e, p > 1 ? n : t);
      while ((p = (p + d + 4) % 4) !== f);
    else
      u.point(h[0], h[1]);
  }
  function r(l, h) {
    return gt(l[0] - i) < vt ? h > 0 ? 0 : 3 : gt(l[0] - e) < vt ? h > 0 ? 2 : 1 : gt(l[1] - t) < vt ? h > 0 ? 1 : 0 : h > 0 ? 3 : 2;
  }
  function o(l, h) {
    return c(l.x, h.x);
  }
  function c(l, h) {
    var d = r(l, 1), u = r(h, 1);
    return d !== u ? d - u : d === 0 ? h[1] - l[1] : d === 1 ? l[0] - h[0] : d === 2 ? l[1] - h[1] : h[0] - l[0];
  }
  return function(l) {
    var h = l, d = vo(), u, p, f, g, m, v, S, y, E, x, b, k = {
      point: _,
      lineStart: H,
      lineEnd: N,
      polygonStart: R,
      polygonEnd: A
    };
    function _(L, P) {
      s(L, P) && h.point(L, P);
    }
    function G() {
      for (var L = 0, P = 0, $ = p.length; P < $; ++P)
        for (var C = p[P], V = 1, q = C.length, X = C[0], F, Z, rt = X[0], j = X[1]; V < q; ++V)
          F = rt, Z = j, X = C[V], rt = X[0], j = X[1], Z <= n ? j > n && (rt - F) * (n - Z) > (j - Z) * (i - F) && ++L : j <= n && (rt - F) * (n - Z) < (j - Z) * (i - F) && --L;
      return L;
    }
    function R() {
      h = d, u = [], p = [], b = !0;
    }
    function A() {
      var L = G(), P = b && L, $ = (u = uo(u)).length;
      (P || $) && (l.polygonStart(), P && (l.lineStart(), a(null, null, 1, l), l.lineEnd()), $ && yo(u, o, L, a, l), l.polygonEnd()), h = l, u = p = f = null;
    }
    function H() {
      k.point = M, p && p.push(f = []), x = !0, E = !1, S = y = NaN;
    }
    function N() {
      u && (M(g, m), v && E && d.rejoin(), u.push(d.result())), k.point = _, E && h.lineEnd();
    }
    function M(L, P) {
      var $ = s(L, P);
      if (p && f.push([L, P]), x)
        g = L, m = P, v = $, x = !1, $ && (h.lineStart(), h.point(L, P));
      else if ($ && E) h.point(L, P);
      else {
        var C = [S = Math.max(Zn, Math.min(Yn, S)), y = Math.max(Zn, Math.min(Yn, y))], V = [L = Math.max(Zn, Math.min(Yn, L)), P = Math.max(Zn, Math.min(Yn, P))];
        pu(C, V, i, t, e, n) ? (E || (h.lineStart(), h.point(C[0], C[1])), h.point(V[0], V[1]), $ || h.lineEnd(), b = !1) : $ && (h.lineStart(), h.point(L, P), b = !1);
      }
      S = L, y = P, E = $;
    }
    return k;
  };
}
const Ai = (i) => i;
var Ks = new De(), Mi = new De(), xo, So, wi, Ci, Ee = {
  point: Qt,
  lineStart: Qt,
  lineEnd: Qt,
  polygonStart: function() {
    Ee.lineStart = gu, Ee.lineEnd = vu;
  },
  polygonEnd: function() {
    Ee.lineStart = Ee.lineEnd = Ee.point = Qt, Ks.add(gt(Mi)), Mi = new De();
  },
  result: function() {
    var i = Ks / 2;
    return Ks = new De(), i;
  }
};
function gu() {
  Ee.point = mu;
}
function mu(i, t) {
  Ee.point = bo, xo = wi = i, So = Ci = t;
}
function bo(i, t) {
  Mi.add(Ci * i - wi * t), wi = i, Ci = t;
}
function vu() {
  bo(xo, So);
}
var rn = 1 / 0, ps = rn, kn = -rn, fs = kn, gs = {
  point: yu,
  lineStart: Qt,
  lineEnd: Qt,
  polygonStart: Qt,
  polygonEnd: Qt,
  result: function() {
    var i = [[rn, ps], [kn, fs]];
    return kn = fs = -(ps = rn = 1 / 0), i;
  }
};
function yu(i, t) {
  i < rn && (rn = i), i > kn && (kn = i), t < ps && (ps = t), t > fs && (fs = t);
}
var ki = 0, _i = 0, xn = 0, ms = 0, vs = 0, tn = 0, Ii = 0, Ri = 0, Sn = 0, To, Oo, le, ce, Jt = {
  point: Pe,
  lineStart: Ja,
  lineEnd: Qa,
  polygonStart: function() {
    Jt.lineStart = Su, Jt.lineEnd = bu;
  },
  polygonEnd: function() {
    Jt.point = Pe, Jt.lineStart = Ja, Jt.lineEnd = Qa;
  },
  result: function() {
    var i = Sn ? [Ii / Sn, Ri / Sn] : tn ? [ms / tn, vs / tn] : xn ? [ki / xn, _i / xn] : [NaN, NaN];
    return ki = _i = xn = ms = vs = tn = Ii = Ri = Sn = 0, i;
  }
};
function Pe(i, t) {
  ki += i, _i += t, ++xn;
}
function Ja() {
  Jt.point = Eu;
}
function Eu(i, t) {
  Jt.point = xu, Pe(le = i, ce = t);
}
function xu(i, t) {
  var e = i - le, n = t - ce, s = ae(e * e + n * n);
  ms += s * (le + i) / 2, vs += s * (ce + t) / 2, tn += s, Pe(le = i, ce = t);
}
function Qa() {
  Jt.point = Pe;
}
function Su() {
  Jt.point = Tu;
}
function bu() {
  Lo(To, Oo);
}
function Tu(i, t) {
  Jt.point = Lo, Pe(To = le = i, Oo = ce = t);
}
function Lo(i, t) {
  var e = i - le, n = t - ce, s = ae(e * e + n * n);
  ms += s * (le + i) / 2, vs += s * (ce + t) / 2, tn += s, s = ce * i - le * t, Ii += s * (le + i), Ri += s * (ce + t), Sn += s * 3, Pe(le = i, ce = t);
}
function Ao(i) {
  this._context = i;
}
Ao.prototype = {
  _radius: 4.5,
  pointRadius: function(i) {
    return this._radius = i, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(i, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(i, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(i, t);
        break;
      }
      default: {
        this._context.moveTo(i + this._radius, t), this._context.arc(i, t, this._radius, 0, Yt);
        break;
      }
    }
  },
  result: Qt
};
var Di = new De(), Js, Mo, wo, bn, Tn, _n = {
  point: Qt,
  lineStart: function() {
    _n.point = Ou;
  },
  lineEnd: function() {
    Js && Co(Mo, wo), _n.point = Qt;
  },
  polygonStart: function() {
    Js = !0;
  },
  polygonEnd: function() {
    Js = null;
  },
  result: function() {
    var i = +Di;
    return Di = new De(), i;
  }
};
function Ou(i, t) {
  _n.point = Co, Mo = bn = i, wo = Tn = t;
}
function Co(i, t) {
  bn -= i, Tn -= t, Di.add(ae(bn * bn + Tn * Tn)), bn = i, Tn = t;
}
let tr, ys, er, nr;
class sr {
  constructor(t) {
    this._append = t == null ? ko : Lu(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, e) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${e}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${e}`;
        break;
      }
      default: {
        if (this._append`M${t},${e}`, this._radius !== er || this._append !== ys) {
          const n = this._radius, s = this._;
          this._ = "", this._append`m0,${n}a${n},${n} 0 1,1 0,${-2 * n}a${n},${n} 0 1,1 0,${2 * n}z`, er = n, ys = this._append, nr = this._, this._ = s;
        }
        this._ += nr;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function ko(i) {
  let t = 1;
  this._ += i[0];
  for (const e = i.length; t < e; ++t)
    this._ += arguments[t] + i[t];
}
function Lu(i) {
  const t = Math.floor(i);
  if (!(t >= 0)) throw new RangeError(`invalid digits: ${i}`);
  if (t > 15) return ko;
  if (t !== tr) {
    const e = 10 ** t;
    tr = t, ys = function(s) {
      let a = 1;
      this._ += s[0];
      for (const r = s.length; a < r; ++a)
        this._ += Math.round(arguments[a] * e) / e + s[a];
    };
  }
  return ys;
}
function Au(i, t) {
  let e = 3, n = 4.5, s, a;
  function r(o) {
    return o && (typeof n == "function" && a.pointRadius(+n.apply(this, arguments)), qe(o, s(a))), a.result();
  }
  return r.area = function(o) {
    return qe(o, s(Ee)), Ee.result();
  }, r.measure = function(o) {
    return qe(o, s(_n)), _n.result();
  }, r.bounds = function(o) {
    return qe(o, s(gs)), gs.result();
  }, r.centroid = function(o) {
    return qe(o, s(Jt)), Jt.result();
  }, r.projection = function(o) {
    return arguments.length ? (s = o == null ? (i = null, Ai) : (i = o).stream, r) : i;
  }, r.context = function(o) {
    return arguments.length ? (a = o == null ? (t = null, new sr(e)) : new Ao(t = o), typeof n != "function" && a.pointRadius(n), r) : t;
  }, r.pointRadius = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : (a.pointRadius(+o), +o), r) : n;
  }, r.digits = function(o) {
    if (!arguments.length) return e;
    if (o == null) e = null;
    else {
      const c = Math.floor(o);
      if (!(c >= 0)) throw new RangeError(`invalid digits: ${o}`);
      e = c;
    }
    return t === null && (a = new sr(e)), r;
  }, r.projection(i).digits(e).context(t);
}
function Xi(i) {
  return function(t) {
    var e = new Ni();
    for (var n in i) e[n] = i[n];
    return e.stream = t, e;
  };
}
function Ni() {
}
Ni.prototype = {
  constructor: Ni,
  point: function(i, t) {
    this.stream.point(i, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function Yi(i, t, e) {
  var n = i.clipExtent && i.clipExtent();
  return i.scale(150).translate([0, 0]), n != null && i.clipExtent(null), qe(e, i.stream(gs)), t(gs.result()), n != null && i.clipExtent(n), i;
}
function _o(i, t, e) {
  return Yi(i, function(n) {
    var s = t[1][0] - t[0][0], a = t[1][1] - t[0][1], r = Math.min(s / (n[1][0] - n[0][0]), a / (n[1][1] - n[0][1])), o = +t[0][0] + (s - r * (n[1][0] + n[0][0])) / 2, c = +t[0][1] + (a - r * (n[1][1] + n[0][1])) / 2;
    i.scale(150 * r).translate([o, c]);
  }, e);
}
function Mu(i, t, e) {
  return _o(i, [[0, 0], t], e);
}
function wu(i, t, e) {
  return Yi(i, function(n) {
    var s = +t, a = s / (n[1][0] - n[0][0]), r = (s - a * (n[1][0] + n[0][0])) / 2, o = -a * n[0][1];
    i.scale(150 * a).translate([r, o]);
  }, e);
}
function Cu(i, t, e) {
  return Yi(i, function(n) {
    var s = +t, a = s / (n[1][1] - n[0][1]), r = -a * n[0][0], o = (s - a * (n[1][1] + n[0][1])) / 2;
    i.scale(150 * a).translate([r, o]);
  }, e);
}
var ir = 16, ku = mt(30 * Ot);
function ar(i, t) {
  return +t ? Iu(i, t) : _u(i);
}
function _u(i) {
  return Xi({
    point: function(t, e) {
      t = i(t, e), this.stream.point(t[0], t[1]);
    }
  });
}
function Iu(i, t) {
  function e(n, s, a, r, o, c, l, h, d, u, p, f, g, m) {
    var v = l - n, S = h - s, y = v * v + S * S;
    if (y > 4 * t && g--) {
      var E = r + u, x = o + p, b = c + f, k = ae(E * E + x * x + b * b), _ = Se(b /= k), G = gt(gt(b) - 1) < vt || gt(a - d) < vt ? (a + d) / 2 : Ne(x, E), R = i(G, _), A = R[0], H = R[1], N = A - n, M = H - s, L = S * N - v * M;
      (L * L / y > t || gt((v * N + S * M) / y - 0.5) > 0.3 || r * u + o * p + c * f < ku) && (e(n, s, a, r, o, c, A, H, G, E /= k, x /= k, b, g, m), m.point(A, H), e(A, H, G, E, x, b, l, h, d, u, p, f, g, m));
    }
  }
  return function(n) {
    var s, a, r, o, c, l, h, d, u, p, f, g, m = {
      point: v,
      lineStart: S,
      lineEnd: E,
      polygonStart: function() {
        n.polygonStart(), m.lineStart = x;
      },
      polygonEnd: function() {
        n.polygonEnd(), m.lineStart = S;
      }
    };
    function v(_, G) {
      _ = i(_, G), n.point(_[0], _[1]);
    }
    function S() {
      d = NaN, m.point = y, n.lineStart();
    }
    function y(_, G) {
      var R = an([_, G]), A = i(_, G);
      e(d, u, h, p, f, g, d = A[0], u = A[1], h = _, p = R[0], f = R[1], g = R[2], ir, n), n.point(d, u);
    }
    function E() {
      m.point = v, n.lineEnd();
    }
    function x() {
      S(), m.point = b, m.lineEnd = k;
    }
    function b(_, G) {
      y(s = _, G), a = d, r = u, o = p, c = f, l = g, m.point = y;
    }
    function k() {
      e(d, u, h, p, f, g, a, r, s, o, c, l, ir, n), m.lineEnd = E, E();
    }
    return m;
  };
}
var Ru = Xi({
  point: function(i, t) {
    this.stream.point(i * Ot, t * Ot);
  }
});
function Du(i) {
  return Xi({
    point: function(t, e) {
      var n = i(t, e);
      return this.stream.point(n[0], n[1]);
    }
  });
}
function Nu(i, t, e, n, s) {
  function a(r, o) {
    return r *= n, o *= s, [t + i * r, e - i * o];
  }
  return a.invert = function(r, o) {
    return [(r - t) / i * n, (e - o) / i * s];
  }, a;
}
function rr(i, t, e, n, s, a) {
  if (!a) return Nu(i, t, e, n, s);
  var r = mt(a), o = ft(a), c = r * i, l = o * i, h = r / i, d = o / i, u = (o * e - r * t) / i, p = (o * t + r * e) / i;
  function f(g, m) {
    return g *= n, m *= s, [c * g - l * m + t, e - l * g - c * m];
  }
  return f.invert = function(g, m) {
    return [n * (h * g - d * m + u), s * (p - d * g - h * m)];
  }, f;
}
function Ms(i) {
  return Io(function() {
    return i;
  })();
}
function Io(i) {
  var t, e = 150, n = 480, s = 250, a = 0, r = 0, o = 0, c = 0, l = 0, h, d = 0, u = 1, p = 1, f = null, g = Ka, m = null, v, S, y, E = Ai, x = 0.5, b, k, _, G, R;
  function A(L) {
    return _(L[0] * Ot, L[1] * Ot);
  }
  function H(L) {
    return L = _.invert(L[0], L[1]), L && [L[0] * Vt, L[1] * Vt];
  }
  A.stream = function(L) {
    return G && R === L ? G : G = Ru(Du(h)(g(b(E(R = L)))));
  }, A.preclip = function(L) {
    return arguments.length ? (g = L, f = void 0, M()) : g;
  }, A.postclip = function(L) {
    return arguments.length ? (E = L, m = v = S = y = null, M()) : E;
  }, A.clipAngle = function(L) {
    return arguments.length ? (g = +L ? du(f = L * Ot) : (f = null, Ka), M()) : f * Vt;
  }, A.clipExtent = function(L) {
    return arguments.length ? (E = L == null ? (m = v = S = y = null, Ai) : fu(m = +L[0][0], v = +L[0][1], S = +L[1][0], y = +L[1][1]), M()) : m == null ? null : [[m, v], [S, y]];
  }, A.scale = function(L) {
    return arguments.length ? (e = +L, N()) : e;
  }, A.translate = function(L) {
    return arguments.length ? (n = +L[0], s = +L[1], N()) : [n, s];
  }, A.center = function(L) {
    return arguments.length ? (a = L[0] % 360 * Ot, r = L[1] % 360 * Ot, N()) : [a * Vt, r * Vt];
  }, A.rotate = function(L) {
    return arguments.length ? (o = L[0] % 360 * Ot, c = L[1] % 360 * Ot, l = L.length > 2 ? L[2] % 360 * Ot : 0, N()) : [o * Vt, c * Vt, l * Vt];
  }, A.angle = function(L) {
    return arguments.length ? (d = L % 360 * Ot, N()) : d * Vt;
  }, A.reflectX = function(L) {
    return arguments.length ? (u = L ? -1 : 1, N()) : u < 0;
  }, A.reflectY = function(L) {
    return arguments.length ? (p = L ? -1 : 1, N()) : p < 0;
  }, A.precision = function(L) {
    return arguments.length ? (b = ar(k, x = L * L), M()) : ae(x);
  }, A.fitExtent = function(L, P) {
    return _o(A, L, P);
  }, A.fitSize = function(L, P) {
    return Mu(A, L, P);
  }, A.fitWidth = function(L, P) {
    return wu(A, L, P);
  }, A.fitHeight = function(L, P) {
    return Cu(A, L, P);
  };
  function N() {
    var L = rr(e, 0, 0, u, p, d).apply(null, t(a, r)), P = rr(e, n - L[0], s - L[1], u, p, d);
    return h = mo(o, c, l), k = Oi(t, P), _ = Oi(h, k), b = ar(k, x), M();
  }
  function M() {
    return G = R = null, A;
  }
  return function() {
    return t = i.apply(this, arguments), A.invert = t.invert && H, N();
  };
}
function Ro(i) {
  var t = 0, e = ht / 3, n = Io(i), s = n(t, e);
  return s.parallels = function(a) {
    return arguments.length ? n(t = a[0] * Ot, e = a[1] * Ot) : [t * Vt, e * Vt];
  }, s;
}
function Pu(i) {
  var t = mt(i);
  function e(n, s) {
    return [n * t, ft(s) / t];
  }
  return e.invert = function(n, s) {
    return [n / t, Se(s * t)];
  }, e;
}
function $u(i, t) {
  var e = ft(i), n = (e + ft(t)) / 2;
  if (gt(n) < vt) return Pu(i);
  var s = 1 + e * (2 * n - e), a = ae(s) / n;
  function r(o, c) {
    var l = ae(s - 2 * n * ft(c)) / n;
    return [l * ft(o *= n), a - l * mt(o)];
  }
  return r.invert = function(o, c) {
    var l = a - c, h = Ne(o, gt(l)) * Oe(l);
    return l * n < 0 && (h -= ht * Oe(o) * Oe(l)), [h / n, Se((s - (o * o + l * l) * n * n) / (2 * n))];
  }, r;
}
function Do() {
  return Ro($u).scale(155.424).center([0, 33.6442]);
}
function Vu() {
  return Do().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function Zi(i, t) {
  return [i, eu(nu((Ft + t) / 2))];
}
Zi.invert = function(i, t) {
  return [i, 2 * go(tu(t)) - Ft];
};
function Gu() {
  return Hu(Zi).scale(961 / Yt);
}
function Hu(i) {
  var t = Ms(i), e = t.center, n = t.scale, s = t.translate, a = t.clipExtent, r = null, o, c, l;
  t.scale = function(d) {
    return arguments.length ? (n(d), h()) : n();
  }, t.translate = function(d) {
    return arguments.length ? (s(d), h()) : s();
  }, t.center = function(d) {
    return arguments.length ? (e(d), h()) : e();
  }, t.clipExtent = function(d) {
    return arguments.length ? (d == null ? r = o = c = l = null : (r = +d[0][0], o = +d[0][1], c = +d[1][0], l = +d[1][1]), h()) : r == null ? null : [[r, o], [c, l]];
  };
  function h() {
    var d = ht * n(), u = t(iu(t.rotate()).invert([0, 0]));
    return a(r == null ? [[u[0] - d, u[1] - d], [u[0] + d, u[1] + d]] : i === Zi ? [[Math.max(u[0] - d, r), o], [Math.min(u[0] + d, c), l]] : [[r, Math.max(u[1] - d, o)], [c, Math.min(u[1] + d, l)]]);
  }
  return h();
}
function Es(i, t) {
  return [i, t];
}
Es.invert = Es;
function Bu() {
  return Ms(Es).scale(152.63);
}
function zu(i, t) {
  var e = mt(i), n = i === t ? ft(i) : (e - mt(t)) / (t - i), s = e / n + i;
  if (gt(n) < vt) return Es;
  function a(r, o) {
    var c = s - o, l = n * r;
    return [c * ft(l), s - c * mt(l)];
  }
  return a.invert = function(r, o) {
    var c = s - o, l = Ne(r, gt(c)) * Oe(c);
    return c * n < 0 && (l -= ht * Oe(r) * Oe(c)), [l / n, s - Oe(n) * ae(r * r + c * c)];
  }, a;
}
function Uu() {
  return Ro(zu).scale(131.154).center([0, 13.9389]);
}
var Ln = 1.340264, An = -0.081106, Mn = 893e-6, wn = 3796e-6, xs = ae(3) / 2, Fu = 12;
function No(i, t) {
  var e = Se(xs * ft(t)), n = e * e, s = n * n * n;
  return [
    i * mt(e) / (xs * (Ln + 3 * An * n + s * (7 * Mn + 9 * wn * n))),
    e * (Ln + An * n + s * (Mn + wn * n))
  ];
}
No.invert = function(i, t) {
  for (var e = t, n = e * e, s = n * n * n, a = 0, r, o, c; a < Fu && (o = e * (Ln + An * n + s * (Mn + wn * n)) - t, c = Ln + 3 * An * n + s * (7 * Mn + 9 * wn * n), e -= r = o / c, n = e * e, s = n * n * n, !(gt(r) < Qc)); ++a)
    ;
  return [
    xs * i * (Ln + 3 * An * n + s * (7 * Mn + 9 * wn * n)) / mt(e),
    Se(ft(e) / xs)
  ];
};
function Wu() {
  return Ms(No).scale(177.158);
}
function Po(i, t) {
  var e = t * t, n = e * e;
  return [
    i * (0.8707 - 0.131979 * e + n * (-0.013791 + n * (3971e-6 * e - 1529e-6 * n))),
    t * (1.007226 + e * (0.015085 + n * (-0.044475 + 0.028874 * e - 5916e-6 * n)))
  ];
}
Po.invert = function(i, t) {
  var e = t, n = 25, s;
  do {
    var a = e * e, r = a * a;
    e -= s = (e * (1.007226 + a * (0.015085 + r * (-0.044475 + 0.028874 * a - 5916e-6 * r))) - t) / (1.007226 + a * (0.015085 * 3 + r * (-0.044475 * 7 + 0.028874 * 9 * a - 5916e-6 * 11 * r)));
  } while (gt(s) > vt && --n > 0);
  return [
    i / (0.8707 + (a = e * e) * (-0.131979 + a * (-0.013791 + a * a * a * (3971e-6 - 1529e-6 * a)))),
    e
  ];
};
function Xu() {
  return Ms(Po).scale(175.295);
}
function Yu(i, t) {
  return i.parent === t.parent ? 1 : 2;
}
function Zu(i) {
  return i.reduce(qu, 0) / i.length;
}
function qu(i, t) {
  return i + t.x;
}
function ju(i) {
  return 1 + i.reduce(Ku, 0);
}
function Ku(i, t) {
  return Math.max(i, t.y);
}
function Ju(i) {
  for (var t; t = i.children; ) i = t[0];
  return i;
}
function Qu(i) {
  for (var t; t = i.children; ) i = t[t.length - 1];
  return i;
}
function th() {
  var i = Yu, t = 1, e = 1, n = !1;
  function s(a) {
    var r, o = 0;
    a.eachAfter(function(u) {
      var p = u.children;
      p ? (u.x = Zu(p), u.y = ju(p)) : (u.x = r ? o += i(u, r) : 0, u.y = 0, r = u);
    });
    var c = Ju(a), l = Qu(a), h = c.x - i(c, l) / 2, d = l.x + i(l, c) / 2;
    return a.eachAfter(n ? function(u) {
      u.x = (u.x - a.x) * t, u.y = (a.y - u.y) * e;
    } : function(u) {
      u.x = (u.x - h) / (d - h) * t, u.y = (1 - (a.y ? u.y / a.y : 1)) * e;
    });
  }
  return s.separation = function(a) {
    return arguments.length ? (i = a, s) : i;
  }, s.size = function(a) {
    return arguments.length ? (n = !1, t = +a[0], e = +a[1], s) : n ? null : [t, e];
  }, s.nodeSize = function(a) {
    return arguments.length ? (n = !0, t = +a[0], e = +a[1], s) : n ? [t, e] : null;
  }, s;
}
function eh(i) {
  var t = 0, e = i.children, n = e && e.length;
  if (!n) t = 1;
  else for (; --n >= 0; ) t += e[n].value;
  i.value = t;
}
function nh() {
  return this.eachAfter(eh);
}
function sh(i, t) {
  let e = -1;
  for (const n of this)
    i.call(t, n, ++e, this);
  return this;
}
function ih(i, t) {
  for (var e = this, n = [e], s, a, r = -1; e = n.pop(); )
    if (i.call(t, e, ++r, this), s = e.children)
      for (a = s.length - 1; a >= 0; --a)
        n.push(s[a]);
  return this;
}
function ah(i, t) {
  for (var e = this, n = [e], s = [], a, r, o, c = -1; e = n.pop(); )
    if (s.push(e), a = e.children)
      for (r = 0, o = a.length; r < o; ++r)
        n.push(a[r]);
  for (; e = s.pop(); )
    i.call(t, e, ++c, this);
  return this;
}
function rh(i, t) {
  let e = -1;
  for (const n of this)
    if (i.call(t, n, ++e, this))
      return n;
}
function oh(i) {
  return this.eachAfter(function(t) {
    for (var e = +i(t.data) || 0, n = t.children, s = n && n.length; --s >= 0; ) e += n[s].value;
    t.value = e;
  });
}
function lh(i) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(i);
  });
}
function ch(i) {
  for (var t = this, e = uh(t, i), n = [t]; t !== e; )
    t = t.parent, n.push(t);
  for (var s = n.length; i !== e; )
    n.splice(s, 0, i), i = i.parent;
  return n;
}
function uh(i, t) {
  if (i === t) return i;
  var e = i.ancestors(), n = t.ancestors(), s = null;
  for (i = e.pop(), t = n.pop(); i === t; )
    s = i, i = e.pop(), t = n.pop();
  return s;
}
function hh() {
  for (var i = this, t = [i]; i = i.parent; )
    t.push(i);
  return t;
}
function dh() {
  return Array.from(this);
}
function ph() {
  var i = [];
  return this.eachBefore(function(t) {
    t.children || i.push(t);
  }), i;
}
function fh() {
  var i = this, t = [];
  return i.each(function(e) {
    e !== i && t.push({ source: e.parent, target: e });
  }), t;
}
function* gh() {
  var i = this, t, e = [i], n, s, a;
  do
    for (t = e.reverse(), e = []; i = t.pop(); )
      if (yield i, n = i.children)
        for (s = 0, a = n.length; s < a; ++s)
          e.push(n[s]);
  while (e.length);
}
function Dn(i, t) {
  i instanceof Map ? (i = [void 0, i], t === void 0 && (t = yh)) : t === void 0 && (t = vh);
  for (var e = new In(i), n, s = [e], a, r, o, c; n = s.pop(); )
    if ((r = t(n.data)) && (c = (r = Array.from(r)).length))
      for (n.children = r, o = c - 1; o >= 0; --o)
        s.push(a = r[o] = new In(r[o])), a.parent = n, a.depth = n.depth + 1;
  return e.eachBefore(xh);
}
function mh() {
  return Dn(this).eachBefore(Eh);
}
function vh(i) {
  return i.children;
}
function yh(i) {
  return Array.isArray(i) ? i[1] : null;
}
function Eh(i) {
  i.data.value !== void 0 && (i.value = i.data.value), i.data = i.data.data;
}
function xh(i) {
  var t = 0;
  do
    i.height = t;
  while ((i = i.parent) && i.height < ++t);
}
function In(i) {
  this.data = i, this.depth = this.height = 0, this.parent = null;
}
In.prototype = Dn.prototype = {
  constructor: In,
  count: nh,
  each: sh,
  eachAfter: ah,
  eachBefore: ih,
  find: rh,
  sum: oh,
  sort: lh,
  path: ch,
  ancestors: hh,
  descendants: dh,
  leaves: ph,
  links: fh,
  copy: mh,
  [Symbol.iterator]: gh
};
function Sh(i) {
  return i == null ? null : $o(i);
}
function $o(i) {
  if (typeof i != "function") throw new Error();
  return i;
}
function Ie() {
  return 0;
}
function je(i) {
  return function() {
    return i;
  };
}
const bh = 1664525, Th = 1013904223, or = 4294967296;
function Oh() {
  let i = 1;
  return () => (i = (bh * i + Th) % or) / or;
}
function Lh(i) {
  return typeof i == "object" && "length" in i ? i : Array.from(i);
}
function Ah(i, t) {
  let e = i.length, n, s;
  for (; e; )
    s = t() * e-- | 0, n = i[e], i[e] = i[s], i[s] = n;
  return i;
}
function Mh(i, t) {
  for (var e = 0, n = (i = Ah(Array.from(i), t)).length, s = [], a, r; e < n; )
    a = i[e], r && Vo(r, a) ? ++e : (r = Ch(s = wh(s, a)), e = 0);
  return r;
}
function wh(i, t) {
  var e, n;
  if (Qs(t, i)) return [t];
  for (e = 0; e < i.length; ++e)
    if (qn(t, i[e]) && Qs(On(i[e], t), i))
      return [i[e], t];
  for (e = 0; e < i.length - 1; ++e)
    for (n = e + 1; n < i.length; ++n)
      if (qn(On(i[e], i[n]), t) && qn(On(i[e], t), i[n]) && qn(On(i[n], t), i[e]) && Qs(Go(i[e], i[n], t), i))
        return [i[e], i[n], t];
  throw new Error();
}
function qn(i, t) {
  var e = i.r - t.r, n = t.x - i.x, s = t.y - i.y;
  return e < 0 || e * e < n * n + s * s;
}
function Vo(i, t) {
  var e = i.r - t.r + Math.max(i.r, t.r, 1) * 1e-9, n = t.x - i.x, s = t.y - i.y;
  return e > 0 && e * e > n * n + s * s;
}
function Qs(i, t) {
  for (var e = 0; e < t.length; ++e)
    if (!Vo(i, t[e]))
      return !1;
  return !0;
}
function Ch(i) {
  switch (i.length) {
    case 1:
      return kh(i[0]);
    case 2:
      return On(i[0], i[1]);
    case 3:
      return Go(i[0], i[1], i[2]);
  }
}
function kh(i) {
  return {
    x: i.x,
    y: i.y,
    r: i.r
  };
}
function On(i, t) {
  var e = i.x, n = i.y, s = i.r, a = t.x, r = t.y, o = t.r, c = a - e, l = r - n, h = o - s, d = Math.sqrt(c * c + l * l);
  return {
    x: (e + a + c / d * h) / 2,
    y: (n + r + l / d * h) / 2,
    r: (d + s + o) / 2
  };
}
function Go(i, t, e) {
  var n = i.x, s = i.y, a = i.r, r = t.x, o = t.y, c = t.r, l = e.x, h = e.y, d = e.r, u = n - r, p = n - l, f = s - o, g = s - h, m = c - a, v = d - a, S = n * n + s * s - a * a, y = S - r * r - o * o + c * c, E = S - l * l - h * h + d * d, x = p * f - u * g, b = (f * E - g * y) / (x * 2) - n, k = (g * m - f * v) / x, _ = (p * y - u * E) / (x * 2) - s, G = (u * v - p * m) / x, R = k * k + G * G - 1, A = 2 * (a + b * k + _ * G), H = b * b + _ * _ - a * a, N = -(Math.abs(R) > 1e-6 ? (A + Math.sqrt(A * A - 4 * R * H)) / (2 * R) : H / A);
  return {
    x: n + b + k * N,
    y: s + _ + G * N,
    r: N
  };
}
function lr(i, t, e) {
  var n = i.x - t.x, s, a, r = i.y - t.y, o, c, l = n * n + r * r;
  l ? (a = t.r + e.r, a *= a, c = i.r + e.r, c *= c, a > c ? (s = (l + c - a) / (2 * l), o = Math.sqrt(Math.max(0, c / l - s * s)), e.x = i.x - s * n - o * r, e.y = i.y - s * r + o * n) : (s = (l + a - c) / (2 * l), o = Math.sqrt(Math.max(0, a / l - s * s)), e.x = t.x + s * n - o * r, e.y = t.y + s * r + o * n)) : (e.x = t.x + e.r, e.y = t.y);
}
function cr(i, t) {
  var e = i.r + t.r - 1e-6, n = t.x - i.x, s = t.y - i.y;
  return e > 0 && e * e > n * n + s * s;
}
function ur(i) {
  var t = i._, e = i.next._, n = t.r + e.r, s = (t.x * e.r + e.x * t.r) / n, a = (t.y * e.r + e.y * t.r) / n;
  return s * s + a * a;
}
function jn(i) {
  this._ = i, this.next = null, this.previous = null;
}
function _h(i, t) {
  if (!(a = (i = Lh(i)).length)) return 0;
  var e, n, s, a, r, o, c, l, h, d, u;
  if (e = i[0], e.x = 0, e.y = 0, !(a > 1)) return e.r;
  if (n = i[1], e.x = -n.r, n.x = e.r, n.y = 0, !(a > 2)) return e.r + n.r;
  lr(n, e, s = i[2]), e = new jn(e), n = new jn(n), s = new jn(s), e.next = s.previous = n, n.next = e.previous = s, s.next = n.previous = e;
  t: for (c = 3; c < a; ++c) {
    lr(e._, n._, s = i[c]), s = new jn(s), l = n.next, h = e.previous, d = n._.r, u = e._.r;
    do
      if (d <= u) {
        if (cr(l._, s._)) {
          n = l, e.next = n, n.previous = e, --c;
          continue t;
        }
        d += l._.r, l = l.next;
      } else {
        if (cr(h._, s._)) {
          e = h, e.next = n, n.previous = e, --c;
          continue t;
        }
        u += h._.r, h = h.previous;
      }
    while (l !== h.next);
    for (s.previous = e, s.next = n, e.next = n.previous = n = s, r = ur(e); (s = s.next) !== n; )
      (o = ur(s)) < r && (e = s, r = o);
    n = e.next;
  }
  for (e = [n._], s = n; (s = s.next) !== n; ) e.push(s._);
  for (s = Mh(e, t), c = 0; c < a; ++c) e = i[c], e.x -= s.x, e.y -= s.y;
  return s.r;
}
function Ih(i) {
  return Math.sqrt(i.value);
}
function Rh() {
  var i = null, t = 1, e = 1, n = Ie;
  function s(a) {
    const r = Oh();
    return a.x = t / 2, a.y = e / 2, i ? a.eachBefore(hr(i)).eachAfter(ti(n, 0.5, r)).eachBefore(dr(1)) : a.eachBefore(hr(Ih)).eachAfter(ti(Ie, 1, r)).eachAfter(ti(n, a.r / Math.min(t, e), r)).eachBefore(dr(Math.min(t, e) / (2 * a.r))), a;
  }
  return s.radius = function(a) {
    return arguments.length ? (i = Sh(a), s) : i;
  }, s.size = function(a) {
    return arguments.length ? (t = +a[0], e = +a[1], s) : [t, e];
  }, s.padding = function(a) {
    return arguments.length ? (n = typeof a == "function" ? a : je(+a), s) : n;
  }, s;
}
function hr(i) {
  return function(t) {
    t.children || (t.r = Math.max(0, +i(t) || 0));
  };
}
function ti(i, t, e) {
  return function(n) {
    if (s = n.children) {
      var s, a, r = s.length, o = i(n) * t || 0, c;
      if (o) for (a = 0; a < r; ++a) s[a].r += o;
      if (c = _h(s, e), o) for (a = 0; a < r; ++a) s[a].r -= o;
      n.r = c + o;
    }
  };
}
function dr(i) {
  return function(t) {
    var e = t.parent;
    t.r *= i, e && (t.x = e.x + i * t.x, t.y = e.y + i * t.y);
  };
}
function Dh(i) {
  i.x0 = Math.round(i.x0), i.y0 = Math.round(i.y0), i.x1 = Math.round(i.x1), i.y1 = Math.round(i.y1);
}
function Nh(i, t, e, n, s) {
  for (var a = i.children, r, o = -1, c = a.length, l = i.value && (n - t) / i.value; ++o < c; )
    r = a[o], r.y0 = e, r.y1 = s, r.x0 = t, r.x1 = t += r.value * l;
}
function Ph(i, t) {
  return i.parent === t.parent ? 1 : 2;
}
function ei(i) {
  var t = i.children;
  return t ? t[0] : i.t;
}
function ni(i) {
  var t = i.children;
  return t ? t[t.length - 1] : i.t;
}
function $h(i, t, e) {
  var n = e / (t.i - i.i);
  t.c -= n, t.s += e, i.c += n, t.z += e, t.m += e;
}
function Vh(i) {
  for (var t = 0, e = 0, n = i.children, s = n.length, a; --s >= 0; )
    a = n[s], a.z += t, a.m += t, t += a.s + (e += a.c);
}
function Gh(i, t, e) {
  return i.a.parent === t.parent ? i.a : e;
}
function ls(i, t) {
  this._ = i, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
ls.prototype = Object.create(In.prototype);
function Hh(i) {
  for (var t = new ls(i, 0), e, n = [t], s, a, r, o; e = n.pop(); )
    if (a = e._.children)
      for (e.children = new Array(o = a.length), r = o - 1; r >= 0; --r)
        n.push(s = e.children[r] = new ls(a[r], r)), s.parent = e;
  return (t.parent = new ls(null, 0)).children = [t], t;
}
function Bh() {
  var i = Ph, t = 1, e = 1, n = null;
  function s(l) {
    var h = Hh(l);
    if (h.eachAfter(a), h.parent.m = -h.z, h.eachBefore(r), n) l.eachBefore(c);
    else {
      var d = l, u = l, p = l;
      l.eachBefore(function(S) {
        S.x < d.x && (d = S), S.x > u.x && (u = S), S.depth > p.depth && (p = S);
      });
      var f = d === u ? 1 : i(d, u) / 2, g = f - d.x, m = t / (u.x + f + g), v = e / (p.depth || 1);
      l.eachBefore(function(S) {
        S.x = (S.x + g) * m, S.y = S.depth * v;
      });
    }
    return l;
  }
  function a(l) {
    var h = l.children, d = l.parent.children, u = l.i ? d[l.i - 1] : null;
    if (h) {
      Vh(l);
      var p = (h[0].z + h[h.length - 1].z) / 2;
      u ? (l.z = u.z + i(l._, u._), l.m = l.z - p) : l.z = p;
    } else u && (l.z = u.z + i(l._, u._));
    l.parent.A = o(l, u, l.parent.A || d[0]);
  }
  function r(l) {
    l._.x = l.z + l.parent.m, l.m += l.parent.m;
  }
  function o(l, h, d) {
    if (h) {
      for (var u = l, p = l, f = h, g = u.parent.children[0], m = u.m, v = p.m, S = f.m, y = g.m, E; f = ni(f), u = ei(u), f && u; )
        g = ei(g), p = ni(p), p.a = l, E = f.z + S - u.z - m + i(f._, u._), E > 0 && ($h(Gh(f, l, d), l, E), m += E, v += E), S += f.m, m += u.m, y += g.m, v += p.m;
      f && !ni(p) && (p.t = f, p.m += S - v), u && !ei(g) && (g.t = u, g.m += m - y, d = l);
    }
    return d;
  }
  function c(l) {
    l.x *= t, l.y = l.depth * e;
  }
  return s.separation = function(l) {
    return arguments.length ? (i = l, s) : i;
  }, s.size = function(l) {
    return arguments.length ? (n = !1, t = +l[0], e = +l[1], s) : n ? null : [t, e];
  }, s.nodeSize = function(l) {
    return arguments.length ? (n = !0, t = +l[0], e = +l[1], s) : n ? [t, e] : null;
  }, s;
}
function zh(i, t, e, n, s) {
  for (var a = i.children, r, o = -1, c = a.length, l = i.value && (s - e) / i.value; ++o < c; )
    r = a[o], r.x0 = t, r.x1 = n, r.y0 = e, r.y1 = e += r.value * l;
}
var Uh = (1 + Math.sqrt(5)) / 2;
function Fh(i, t, e, n, s, a) {
  for (var r = [], o = t.children, c, l, h = 0, d = 0, u = o.length, p, f, g = t.value, m, v, S, y, E, x, b; h < u; ) {
    p = s - e, f = a - n;
    do
      m = o[d++].value;
    while (!m && d < u);
    for (v = S = m, x = Math.max(f / p, p / f) / (g * i), b = m * m * x, E = Math.max(S / b, b / v); d < u; ++d) {
      if (m += l = o[d].value, l < v && (v = l), l > S && (S = l), b = m * m * x, y = Math.max(S / b, b / v), y > E) {
        m -= l;
        break;
      }
      E = y;
    }
    r.push(c = { value: m, dice: p < f, children: o.slice(h, d) }), c.dice ? Nh(c, e, n, s, g ? n += f * m / g : a) : zh(c, e, n, g ? e += p * m / g : s, a), g -= m, h = d;
  }
  return r;
}
const Wh = function i(t) {
  function e(n, s, a, r, o) {
    Fh(t, n, s, a, r, o);
  }
  return e.ratio = function(n) {
    return i((n = +n) > 1 ? n : 1);
  }, e;
}(Uh);
function Xh() {
  var i = Wh, t = !1, e = 1, n = 1, s = [0], a = Ie, r = Ie, o = Ie, c = Ie, l = Ie;
  function h(u) {
    return u.x0 = u.y0 = 0, u.x1 = e, u.y1 = n, u.eachBefore(d), s = [0], t && u.eachBefore(Dh), u;
  }
  function d(u) {
    var p = s[u.depth], f = u.x0 + p, g = u.y0 + p, m = u.x1 - p, v = u.y1 - p;
    m < f && (f = m = (f + m) / 2), v < g && (g = v = (g + v) / 2), u.x0 = f, u.y0 = g, u.x1 = m, u.y1 = v, u.children && (p = s[u.depth + 1] = a(u) / 2, f += l(u) - p, g += r(u) - p, m -= o(u) - p, v -= c(u) - p, m < f && (f = m = (f + m) / 2), v < g && (g = v = (g + v) / 2), i(u, f, g, m, v));
  }
  return h.round = function(u) {
    return arguments.length ? (t = !!u, h) : t;
  }, h.size = function(u) {
    return arguments.length ? (e = +u[0], n = +u[1], h) : [e, n];
  }, h.tile = function(u) {
    return arguments.length ? (i = $o(u), h) : i;
  }, h.padding = function(u) {
    return arguments.length ? h.paddingInner(u).paddingOuter(u) : h.paddingInner();
  }, h.paddingInner = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : je(+u), h) : a;
  }, h.paddingOuter = function(u) {
    return arguments.length ? h.paddingTop(u).paddingRight(u).paddingBottom(u).paddingLeft(u) : h.paddingTop();
  }, h.paddingTop = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : je(+u), h) : r;
  }, h.paddingRight = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : je(+u), h) : o;
  }, h.paddingBottom = function(u) {
    return arguments.length ? (c = typeof u == "function" ? u : je(+u), h) : c;
  }, h.paddingLeft = function(u) {
    return arguments.length ? (l = typeof u == "function" ? u : je(+u), h) : l;
  }, h;
}
function ws(i) {
  let t = 3;
  return i.digits = function(e) {
    if (!arguments.length) return t;
    if (e == null)
      t = null;
    else {
      const n = Math.floor(e);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${e}`);
      t = n;
    }
    return i;
  }, () => new Wi(t);
}
function Yh(i) {
  return i.innerRadius;
}
function Zh(i) {
  return i.outerRadius;
}
function qh(i) {
  return i.startAngle;
}
function jh(i) {
  return i.endAngle;
}
function Kh(i) {
  return i && i.padAngle;
}
function Jh(i, t, e, n, s, a, r, o) {
  var c = e - i, l = n - t, h = r - s, d = o - a, u = d * c - h * l;
  if (!(u * u < Ut))
    return u = (h * (t - a) - d * (i - s)) / u, [i + u * c, t + u * l];
}
function Kn(i, t, e, n, s, a, r) {
  var o = i - e, c = t - n, l = (r ? a : -a) / Qe(o * o + c * c), h = l * c, d = -l * o, u = i + h, p = t + d, f = e + h, g = n + d, m = (u + f) / 2, v = (p + g) / 2, S = f - u, y = g - p, E = S * S + y * y, x = s - a, b = u * g - f * p, k = (y < 0 ? -1 : 1) * Qe(Ol(0, x * x * E - b * b)), _ = (b * y - S * k) / E, G = (-b * S - y * k) / E, R = (b * y + S * k) / E, A = (-b * S + y * k) / E, H = _ - m, N = G - v, M = R - m, L = A - v;
  return H * H + N * N > M * M + L * L && (_ = R, G = A), {
    cx: _,
    cy: G,
    x01: -h,
    y01: -d,
    x11: _ * (s / x - 1),
    y11: G * (s / x - 1)
  };
}
function Rn() {
  var i = Yh, t = Zh, e = pt(0), n = null, s = qh, a = jh, r = Kh, o = null, c = ws(l);
  function l() {
    var h, d, u = +i.apply(this, arguments), p = +t.apply(this, arguments), f = s.apply(this, arguments) - La, g = a.apply(this, arguments) - La, m = Aa(g - f), v = g > f;
    if (o || (o = h = c()), p < u && (d = p, p = u, u = d), !(p > Ut)) o.moveTo(0, 0);
    else if (m > ss - Ut)
      o.moveTo(p * Ce(f), p * oe(f)), o.arc(0, 0, p, f, g, !v), u > Ut && (o.moveTo(u * Ce(g), u * oe(g)), o.arc(0, 0, u, g, f, v));
    else {
      var S = f, y = g, E = f, x = g, b = m, k = m, _ = r.apply(this, arguments) / 2, G = _ > Ut && (n ? +n.apply(this, arguments) : Qe(u * u + p * p)), R = Us(Aa(p - u) / 2, +e.apply(this, arguments)), A = R, H = R, N, M;
      if (G > Ut) {
        var L = wa(G / u * oe(_)), P = wa(G / p * oe(_));
        (b -= L * 2) > Ut ? (L *= v ? 1 : -1, E += L, x -= L) : (b = 0, E = x = (f + g) / 2), (k -= P * 2) > Ut ? (P *= v ? 1 : -1, S += P, y -= P) : (k = 0, S = y = (f + g) / 2);
      }
      var $ = p * Ce(S), C = p * oe(S), V = u * Ce(x), q = u * oe(x);
      if (R > Ut) {
        var X = p * Ce(y), F = p * oe(y), Z = u * Ce(E), rt = u * oe(E), j;
        if (m < Ma)
          if (j = Jh($, C, Z, rt, X, F, V, q)) {
            var Y = $ - j[0], K = C - j[1], ot = X - j[0], ct = F - j[1], st = 1 / oe(Tl((Y * ot + K * ct) / (Qe(Y * Y + K * K) * Qe(ot * ot + ct * ct))) / 2), it = Qe(j[0] * j[0] + j[1] * j[1]);
            A = Us(R, (u - it) / (st - 1)), H = Us(R, (p - it) / (st + 1));
          } else
            A = H = 0;
      }
      k > Ut ? H > Ut ? (N = Kn(Z, rt, $, C, p, H, v), M = Kn(X, F, V, q, p, H, v), o.moveTo(N.cx + N.x01, N.cy + N.y01), H < R ? o.arc(N.cx, N.cy, H, Dt(N.y01, N.x01), Dt(M.y01, M.x01), !v) : (o.arc(N.cx, N.cy, H, Dt(N.y01, N.x01), Dt(N.y11, N.x11), !v), o.arc(0, 0, p, Dt(N.cy + N.y11, N.cx + N.x11), Dt(M.cy + M.y11, M.cx + M.x11), !v), o.arc(M.cx, M.cy, H, Dt(M.y11, M.x11), Dt(M.y01, M.x01), !v))) : (o.moveTo($, C), o.arc(0, 0, p, S, y, !v)) : o.moveTo($, C), !(u > Ut) || !(b > Ut) ? o.lineTo(V, q) : A > Ut ? (N = Kn(V, q, X, F, u, -A, v), M = Kn($, C, Z, rt, u, -A, v), o.lineTo(N.cx + N.x01, N.cy + N.y01), A < R ? o.arc(N.cx, N.cy, A, Dt(N.y01, N.x01), Dt(M.y01, M.x01), !v) : (o.arc(N.cx, N.cy, A, Dt(N.y01, N.x01), Dt(N.y11, N.x11), !v), o.arc(0, 0, u, Dt(N.cy + N.y11, N.cx + N.x11), Dt(M.cy + M.y11, M.cx + M.x11), v), o.arc(M.cx, M.cy, A, Dt(M.y11, M.x11), Dt(M.y01, M.x01), !v))) : o.arc(0, 0, u, x, E, v);
    }
    if (o.closePath(), h) return o = null, h + "" || null;
  }
  return l.centroid = function() {
    var h = (+i.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+s.apply(this, arguments) + +a.apply(this, arguments)) / 2 - Ma / 2;
    return [Ce(d) * h, oe(d) * h];
  }, l.innerRadius = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : pt(+h), l) : i;
  }, l.outerRadius = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : pt(+h), l) : t;
  }, l.cornerRadius = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : pt(+h), l) : e;
  }, l.padRadius = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : pt(+h), l) : n;
  }, l.startAngle = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : pt(+h), l) : s;
  }, l.endAngle = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : pt(+h), l) : a;
  }, l.padAngle = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : pt(+h), l) : r;
  }, l.context = function(h) {
    return arguments.length ? (o = h ?? null, l) : o;
  }, l;
}
function qi(i) {
  return i[0];
}
function ji(i) {
  return i[1];
}
function Nn(i, t) {
  var e = pt(!0), n = null, s = Bi, a = null, r = ws(o);
  i = typeof i == "function" ? i : i === void 0 ? qi : pt(i), t = typeof t == "function" ? t : t === void 0 ? ji : pt(t);
  function o(c) {
    var l, h = (c = Ui(c)).length, d, u = !1, p;
    for (n == null && (a = s(p = r())), l = 0; l <= h; ++l)
      !(l < h && e(d = c[l], l, c)) === u && ((u = !u) ? a.lineStart() : a.lineEnd()), u && a.point(+i(d, l, c), +t(d, l, c));
    if (p) return a = null, p + "" || null;
  }
  return o.x = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : pt(+c), o) : i;
  }, o.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : pt(+c), o) : t;
  }, o.defined = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : pt(!!c), o) : e;
  }, o.curve = function(c) {
    return arguments.length ? (s = c, n != null && (a = s(n)), o) : s;
  }, o.context = function(c) {
    return arguments.length ? (c == null ? n = a = null : a = s(n = c), o) : n;
  }, o;
}
function Ki(i, t, e) {
  var n = null, s = pt(!0), a = null, r = Bi, o = null, c = ws(l);
  i = typeof i == "function" ? i : i === void 0 ? qi : pt(+i), t = typeof t == "function" ? t : t === void 0 ? pt(0) : pt(+t), e = typeof e == "function" ? e : e === void 0 ? ji : pt(+e);
  function l(d) {
    var u, p, f, g = (d = Ui(d)).length, m, v = !1, S, y = new Array(g), E = new Array(g);
    for (a == null && (o = r(S = c())), u = 0; u <= g; ++u) {
      if (!(u < g && s(m = d[u], u, d)) === v)
        if (v = !v)
          p = u, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), f = u - 1; f >= p; --f)
            o.point(y[f], E[f]);
          o.lineEnd(), o.areaEnd();
        }
      v && (y[u] = +i(m, u, d), E[u] = +t(m, u, d), o.point(n ? +n(m, u, d) : y[u], e ? +e(m, u, d) : E[u]));
    }
    if (S) return o = null, S + "" || null;
  }
  function h() {
    return Nn().defined(s).curve(r).context(a);
  }
  return l.x = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : pt(+d), n = null, l) : i;
  }, l.x0 = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : pt(+d), l) : i;
  }, l.x1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : pt(+d), l) : n;
  }, l.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : pt(+d), e = null, l) : t;
  }, l.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : pt(+d), l) : t;
  }, l.y1 = function(d) {
    return arguments.length ? (e = d == null ? null : typeof d == "function" ? d : pt(+d), l) : e;
  }, l.lineX0 = l.lineY0 = function() {
    return h().x(i).y(t);
  }, l.lineY1 = function() {
    return h().x(i).y(e);
  }, l.lineX1 = function() {
    return h().x(n).y(t);
  }, l.defined = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : pt(!!d), l) : s;
  }, l.curve = function(d) {
    return arguments.length ? (r = d, a != null && (o = r(a)), l) : r;
  }, l.context = function(d) {
    return arguments.length ? (d == null ? a = o = null : o = r(a = d), l) : a;
  }, l;
}
function Qh(i, t) {
  return t < i ? -1 : t > i ? 1 : t >= i ? 0 : NaN;
}
function td(i) {
  return i;
}
function ed() {
  var i = td, t = Qh, e = null, n = pt(0), s = pt(ss), a = pt(0);
  function r(o) {
    var c, l = (o = Ui(o)).length, h, d, u = 0, p = new Array(l), f = new Array(l), g = +n.apply(this, arguments), m = Math.min(ss, Math.max(-ss, s.apply(this, arguments) - g)), v, S = Math.min(Math.abs(m) / l, a.apply(this, arguments)), y = S * (m < 0 ? -1 : 1), E;
    for (c = 0; c < l; ++c)
      (E = f[p[c] = c] = +i(o[c], c, o)) > 0 && (u += E);
    for (t != null ? p.sort(function(x, b) {
      return t(f[x], f[b]);
    }) : e != null && p.sort(function(x, b) {
      return e(o[x], o[b]);
    }), c = 0, d = u ? (m - l * y) / u : 0; c < l; ++c, g = v)
      h = p[c], E = f[h], v = g + (E > 0 ? E * d : 0) + y, f[h] = {
        data: o[h],
        index: c,
        value: E,
        startAngle: g,
        endAngle: v,
        padAngle: S
      };
    return f;
  }
  return r.value = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : pt(+o), r) : i;
  }, r.sortValues = function(o) {
    return arguments.length ? (t = o, e = null, r) : t;
  }, r.sort = function(o) {
    return arguments.length ? (e = o, t = null, r) : e;
  }, r.startAngle = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : pt(+o), r) : n;
  }, r.endAngle = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : pt(+o), r) : s;
  }, r.padAngle = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : pt(+o), r) : a;
  }, r;
}
var nd = Bo(Bi);
function Ho(i) {
  this._curve = i;
}
Ho.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(i, t) {
    this._curve.point(t * Math.sin(i), t * -Math.cos(i));
  }
};
function Bo(i) {
  function t(e) {
    return new Ho(i(e));
  }
  return t._curve = i, t;
}
function sd(i) {
  var t = i.curve;
  return i.angle = i.x, delete i.x, i.radius = i.y, delete i.y, i.curve = function(e) {
    return arguments.length ? t(Bo(e)) : t()._curve;
  }, i;
}
function id() {
  return sd(Nn().curve(nd));
}
class ad {
  constructor(t, e) {
    this._context = t, this._x = e;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, e, t, e) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + e) / 2, t, this._y0, t, e);
        break;
      }
    }
    this._x0 = t, this._y0 = e;
  }
}
function rd(i) {
  return new ad(i, !0);
}
function od(i) {
  return i.source;
}
function ld(i) {
  return i.target;
}
function cd(i) {
  let t = od, e = ld, n = qi, s = ji, a = null, r = null, o = ws(c);
  function c() {
    let l;
    const h = Cl.call(arguments), d = t.apply(this, h), u = e.apply(this, h);
    if (a == null && (r = i(l = o())), r.lineStart(), h[0] = d, r.point(+n.apply(this, h), +s.apply(this, h)), h[0] = u, r.point(+n.apply(this, h), +s.apply(this, h)), r.lineEnd(), l) return r = null, l + "" || null;
  }
  return c.source = function(l) {
    return arguments.length ? (t = l, c) : t;
  }, c.target = function(l) {
    return arguments.length ? (e = l, c) : e;
  }, c.x = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : pt(+l), c) : n;
  }, c.y = function(l) {
    return arguments.length ? (s = typeof l == "function" ? l : pt(+l), c) : s;
  }, c.context = function(l) {
    return arguments.length ? (l == null ? a = r = null : r = i(a = l), c) : a;
  }, c;
}
function ud() {
  return cd(rd);
}
class dt {
  constructor(t, e, n) {
    if (this.type = "", this.renderType = at.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = t, this.services = e, n && (this.configs = n, this.configs.id)) {
      const s = O(this.model.getOptions(), "style", "prefix");
      this.id = `${s}--${this.configs.id}`;
    }
    this.parent || this.setParent(
      D(
        this.services.domUtils.getMainContainer()
      )
    );
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down information to the components
  setServices(t) {
    this.services = t;
  }
  setParent(t) {
    var n;
    const e = this.parent;
    if (this.parent = t, !(e && e.node() === t.node()) && this.type) {
      const s = O(this.model.getOptions(), "style", "prefix");
      (n = this.parent) == null || n.classed(`${Kt}--${s}--${this.type}`, !0), e && e.classed(`${Kt}--${s}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(t = { ariaLabel: null, isPresentational: !1, withinChartClip: !1 }) {
    if (this.type) {
      const e = O(this.model.getOptions(), "style", "prefix"), n = this.id ? `#${this.id}` : "", s = I.appendOrSelect(
        this.parent,
        `${this.renderType === at.SVG ? "svg" : "div"}${n}.${Kt}--${e}--${this.type}`
      );
      if (t.ariaLabel && s.attr("aria-label", t.ariaLabel), t.isPresentational && s.attr("role", "presentation"), t.withinChartClip) {
        const a = this.model.get("chartClipId");
        if (a) {
          const o = D(`#${a}`).select("rect");
          if (o.size() !== 0) {
            const c = parseFloat(o.attr("height")), l = parseFloat(o.attr("width"));
            !isNaN(c) && !isNaN(l) && c > 0 && l > 0 && s.attr("clip-path", `url(#${a})`);
          }
        }
      }
      return s.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? nn({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
}
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries: zo,
  setPrototypeOf: pr,
  isFrozen: hd,
  getPrototypeOf: dd,
  getOwnPropertyDescriptor: pd
} = Object;
let {
  freeze: Ht,
  seal: ee,
  create: Uo
} = Object, {
  apply: Pi,
  construct: $i
} = typeof Reflect < "u" && Reflect;
Ht || (Ht = function(t) {
  return t;
});
ee || (ee = function(t) {
  return t;
});
Pi || (Pi = function(t, e, n) {
  return t.apply(e, n);
});
$i || ($i = function(t, e) {
  return new t(...e);
});
const Jn = Bt(Array.prototype.forEach), fd = Bt(Array.prototype.lastIndexOf), fr = Bt(Array.prototype.pop), dn = Bt(Array.prototype.push), gd = Bt(Array.prototype.splice), cs = Bt(String.prototype.toLowerCase), si = Bt(String.prototype.toString), gr = Bt(String.prototype.match), pn = Bt(String.prototype.replace), md = Bt(String.prototype.indexOf), vd = Bt(String.prototype.trim), ie = Bt(Object.prototype.hasOwnProperty), $t = Bt(RegExp.prototype.test), fn = yd(TypeError);
function Bt(i) {
  return function(t) {
    t instanceof RegExp && (t.lastIndex = 0);
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++)
      n[s - 1] = arguments[s];
    return Pi(i, t, n);
  };
}
function yd(i) {
  return function() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return $i(i, e);
  };
}
function ut(i, t) {
  let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : cs;
  pr && pr(i, null);
  let n = t.length;
  for (; n--; ) {
    let s = t[n];
    if (typeof s == "string") {
      const a = e(s);
      a !== s && (hd(t) || (t[n] = a), s = a);
    }
    i[s] = !0;
  }
  return i;
}
function Ed(i) {
  for (let t = 0; t < i.length; t++)
    ie(i, t) || (i[t] = null);
  return i;
}
function me(i) {
  const t = Uo(null);
  for (const [e, n] of zo(i))
    ie(i, e) && (Array.isArray(n) ? t[e] = Ed(n) : n && typeof n == "object" && n.constructor === Object ? t[e] = me(n) : t[e] = n);
  return t;
}
function gn(i, t) {
  for (; i !== null; ) {
    const n = pd(i, t);
    if (n) {
      if (n.get)
        return Bt(n.get);
      if (typeof n.value == "function")
        return Bt(n.value);
    }
    i = dd(i);
  }
  function e() {
    return null;
  }
  return e;
}
const mr = Ht(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), ii = Ht(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ai = Ht(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), xd = Ht(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), ri = Ht(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Sd = Ht(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), vr = Ht(["#text"]), yr = Ht(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), oi = Ht(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Er = Ht(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Qn = Ht(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), bd = ee(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Td = ee(/<%[\w\W]*|[\w\W]*%>/gm), Od = ee(/\$\{[\w\W]*/gm), Ld = ee(/^data-[\-\w.\u00B7-\uFFFF]+$/), Ad = ee(/^aria-[\-\w]+$/), Fo = ee(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), Md = ee(/^(?:\w+script|data):/i), wd = ee(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Wo = ee(/^html$/i), Cd = ee(/^[a-z][.\w]*(-[.\w]+)+$/i);
var xr = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: Ad,
  ATTR_WHITESPACE: wd,
  CUSTOM_ELEMENT: Cd,
  DATA_ATTR: Ld,
  DOCTYPE_NAME: Wo,
  ERB_EXPR: Td,
  IS_ALLOWED_URI: Fo,
  IS_SCRIPT_OR_DATA: Md,
  MUSTACHE_EXPR: bd,
  TMPLIT_EXPR: Od
});
const mn = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, kd = function() {
  return typeof window > "u" ? null : window;
}, _d = function(t, e) {
  if (typeof t != "object" || typeof t.createPolicy != "function")
    return null;
  let n = null;
  const s = "data-tt-policy-suffix";
  e && e.hasAttribute(s) && (n = e.getAttribute(s));
  const a = "dompurify" + (n ? "#" + n : "");
  try {
    return t.createPolicy(a, {
      createHTML(r) {
        return r;
      },
      createScriptURL(r) {
        return r;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + a + " could not be created."), null;
  }
}, Sr = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function Xo() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : kd();
  const t = (tt) => Xo(tt);
  if (t.version = "3.2.6", t.removed = [], !i || !i.document || i.document.nodeType !== mn.document || !i.Element)
    return t.isSupported = !1, t;
  let {
    document: e
  } = i;
  const n = e, s = n.currentScript, {
    DocumentFragment: a,
    HTMLTemplateElement: r,
    Node: o,
    Element: c,
    NodeFilter: l,
    NamedNodeMap: h = i.NamedNodeMap || i.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: u,
    trustedTypes: p
  } = i, f = c.prototype, g = gn(f, "cloneNode"), m = gn(f, "remove"), v = gn(f, "nextSibling"), S = gn(f, "childNodes"), y = gn(f, "parentNode");
  if (typeof r == "function") {
    const tt = e.createElement("template");
    tt.content && tt.content.ownerDocument && (e = tt.content.ownerDocument);
  }
  let E, x = "";
  const {
    implementation: b,
    createNodeIterator: k,
    createDocumentFragment: _,
    getElementsByTagName: G
  } = e, {
    importNode: R
  } = n;
  let A = Sr();
  t.isSupported = typeof zo == "function" && typeof y == "function" && b && b.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: H,
    ERB_EXPR: N,
    TMPLIT_EXPR: M,
    DATA_ATTR: L,
    ARIA_ATTR: P,
    IS_SCRIPT_OR_DATA: $,
    ATTR_WHITESPACE: C,
    CUSTOM_ELEMENT: V
  } = xr;
  let {
    IS_ALLOWED_URI: q
  } = xr, X = null;
  const F = ut({}, [...mr, ...ii, ...ai, ...ri, ...vr]);
  let Z = null;
  const rt = ut({}, [...yr, ...oi, ...Er, ...Qn]);
  let j = Object.seal(Uo(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Y = null, K = null, ot = !0, ct = !0, st = !1, it = !0, z = !1, B = !0, U = !1, wt = !1, be = !1, et = !1, yt = !1, Zt = !1, Wt = !0, on = !1;
  const ln = "user-content-";
  let Le = !0, ne = !1, $e = {}, Ve = null;
  const na = ut({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let sa = null;
  const ia = ut({}, ["audio", "video", "img", "source", "image", "track"]);
  let ks = null;
  const aa = ut({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Pn = "http://www.w3.org/1998/Math/MathML", $n = "http://www.w3.org/2000/svg", he = "http://www.w3.org/1999/xhtml";
  let Ge = he, _s = !1, Is = null;
  const Jo = ut({}, [Pn, $n, he], si);
  let Vn = ut({}, ["mi", "mo", "mn", "ms", "mtext"]), Gn = ut({}, ["annotation-xml"]);
  const Qo = ut({}, ["title", "style", "font", "a", "script"]);
  let cn = null;
  const tl = ["application/xhtml+xml", "text/html"], el = "text/html";
  let Ct = null, He = null;
  const nl = e.createElement("form"), ra = function(w) {
    return w instanceof RegExp || w instanceof Function;
  }, Rs = function() {
    let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(He && He === w)) {
      if ((!w || typeof w != "object") && (w = {}), w = me(w), cn = // eslint-disable-next-line unicorn/prefer-includes
      tl.indexOf(w.PARSER_MEDIA_TYPE) === -1 ? el : w.PARSER_MEDIA_TYPE, Ct = cn === "application/xhtml+xml" ? si : cs, X = ie(w, "ALLOWED_TAGS") ? ut({}, w.ALLOWED_TAGS, Ct) : F, Z = ie(w, "ALLOWED_ATTR") ? ut({}, w.ALLOWED_ATTR, Ct) : rt, Is = ie(w, "ALLOWED_NAMESPACES") ? ut({}, w.ALLOWED_NAMESPACES, si) : Jo, ks = ie(w, "ADD_URI_SAFE_ATTR") ? ut(me(aa), w.ADD_URI_SAFE_ATTR, Ct) : aa, sa = ie(w, "ADD_DATA_URI_TAGS") ? ut(me(ia), w.ADD_DATA_URI_TAGS, Ct) : ia, Ve = ie(w, "FORBID_CONTENTS") ? ut({}, w.FORBID_CONTENTS, Ct) : na, Y = ie(w, "FORBID_TAGS") ? ut({}, w.FORBID_TAGS, Ct) : me({}), K = ie(w, "FORBID_ATTR") ? ut({}, w.FORBID_ATTR, Ct) : me({}), $e = ie(w, "USE_PROFILES") ? w.USE_PROFILES : !1, ot = w.ALLOW_ARIA_ATTR !== !1, ct = w.ALLOW_DATA_ATTR !== !1, st = w.ALLOW_UNKNOWN_PROTOCOLS || !1, it = w.ALLOW_SELF_CLOSE_IN_ATTR !== !1, z = w.SAFE_FOR_TEMPLATES || !1, B = w.SAFE_FOR_XML !== !1, U = w.WHOLE_DOCUMENT || !1, et = w.RETURN_DOM || !1, yt = w.RETURN_DOM_FRAGMENT || !1, Zt = w.RETURN_TRUSTED_TYPE || !1, be = w.FORCE_BODY || !1, Wt = w.SANITIZE_DOM !== !1, on = w.SANITIZE_NAMED_PROPS || !1, Le = w.KEEP_CONTENT !== !1, ne = w.IN_PLACE || !1, q = w.ALLOWED_URI_REGEXP || Fo, Ge = w.NAMESPACE || he, Vn = w.MATHML_TEXT_INTEGRATION_POINTS || Vn, Gn = w.HTML_INTEGRATION_POINTS || Gn, j = w.CUSTOM_ELEMENT_HANDLING || {}, w.CUSTOM_ELEMENT_HANDLING && ra(w.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (j.tagNameCheck = w.CUSTOM_ELEMENT_HANDLING.tagNameCheck), w.CUSTOM_ELEMENT_HANDLING && ra(w.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (j.attributeNameCheck = w.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), w.CUSTOM_ELEMENT_HANDLING && typeof w.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (j.allowCustomizedBuiltInElements = w.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), z && (ct = !1), yt && (et = !0), $e && (X = ut({}, vr), Z = [], $e.html === !0 && (ut(X, mr), ut(Z, yr)), $e.svg === !0 && (ut(X, ii), ut(Z, oi), ut(Z, Qn)), $e.svgFilters === !0 && (ut(X, ai), ut(Z, oi), ut(Z, Qn)), $e.mathMl === !0 && (ut(X, ri), ut(Z, Er), ut(Z, Qn))), w.ADD_TAGS && (X === F && (X = me(X)), ut(X, w.ADD_TAGS, Ct)), w.ADD_ATTR && (Z === rt && (Z = me(Z)), ut(Z, w.ADD_ATTR, Ct)), w.ADD_URI_SAFE_ATTR && ut(ks, w.ADD_URI_SAFE_ATTR, Ct), w.FORBID_CONTENTS && (Ve === na && (Ve = me(Ve)), ut(Ve, w.FORBID_CONTENTS, Ct)), Le && (X["#text"] = !0), U && ut(X, ["html", "head", "body"]), X.table && (ut(X, ["tbody"]), delete Y.tbody), w.TRUSTED_TYPES_POLICY) {
        if (typeof w.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw fn('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof w.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw fn('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        E = w.TRUSTED_TYPES_POLICY, x = E.createHTML("");
      } else
        E === void 0 && (E = _d(p, s)), E !== null && typeof x == "string" && (x = E.createHTML(""));
      Ht && Ht(w), He = w;
    }
  }, oa = ut({}, [...ii, ...ai, ...xd]), la = ut({}, [...ri, ...Sd]), sl = function(w) {
    let W = y(w);
    (!W || !W.tagName) && (W = {
      namespaceURI: Ge,
      tagName: "template"
    });
    const Q = cs(w.tagName), St = cs(W.tagName);
    return Is[w.namespaceURI] ? w.namespaceURI === $n ? W.namespaceURI === he ? Q === "svg" : W.namespaceURI === Pn ? Q === "svg" && (St === "annotation-xml" || Vn[St]) : !!oa[Q] : w.namespaceURI === Pn ? W.namespaceURI === he ? Q === "math" : W.namespaceURI === $n ? Q === "math" && Gn[St] : !!la[Q] : w.namespaceURI === he ? W.namespaceURI === $n && !Gn[St] || W.namespaceURI === Pn && !Vn[St] ? !1 : !la[Q] && (Qo[Q] || !oa[Q]) : !!(cn === "application/xhtml+xml" && Is[w.namespaceURI]) : !1;
  }, re = function(w) {
    dn(t.removed, {
      element: w
    });
    try {
      y(w).removeChild(w);
    } catch {
      m(w);
    }
  }, Be = function(w, W) {
    try {
      dn(t.removed, {
        attribute: W.getAttributeNode(w),
        from: W
      });
    } catch {
      dn(t.removed, {
        attribute: null,
        from: W
      });
    }
    if (W.removeAttribute(w), w === "is")
      if (et || yt)
        try {
          re(W);
        } catch {
        }
      else
        try {
          W.setAttribute(w, "");
        } catch {
        }
  }, ca = function(w) {
    let W = null, Q = null;
    if (be)
      w = "<remove></remove>" + w;
    else {
      const At = gr(w, /^[\r\n\t ]+/);
      Q = At && At[0];
    }
    cn === "application/xhtml+xml" && Ge === he && (w = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + w + "</body></html>");
    const St = E ? E.createHTML(w) : w;
    if (Ge === he)
      try {
        W = new u().parseFromString(St, cn);
      } catch {
      }
    if (!W || !W.documentElement) {
      W = b.createDocument(Ge, "template", null);
      try {
        W.documentElement.innerHTML = _s ? x : St;
      } catch {
      }
    }
    const It = W.body || W.documentElement;
    return w && Q && It.insertBefore(e.createTextNode(Q), It.childNodes[0] || null), Ge === he ? G.call(W, U ? "html" : "body")[0] : U ? W.documentElement : It;
  }, ua = function(w) {
    return k.call(
      w.ownerDocument || w,
      w,
      // eslint-disable-next-line no-bitwise
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT | l.SHOW_PROCESSING_INSTRUCTION | l.SHOW_CDATA_SECTION,
      null
    );
  }, Ds = function(w) {
    return w instanceof d && (typeof w.nodeName != "string" || typeof w.textContent != "string" || typeof w.removeChild != "function" || !(w.attributes instanceof h) || typeof w.removeAttribute != "function" || typeof w.setAttribute != "function" || typeof w.namespaceURI != "string" || typeof w.insertBefore != "function" || typeof w.hasChildNodes != "function");
  }, ha = function(w) {
    return typeof o == "function" && w instanceof o;
  };
  function de(tt, w, W) {
    Jn(tt, (Q) => {
      Q.call(t, w, W, He);
    });
  }
  const da = function(w) {
    let W = null;
    if (de(A.beforeSanitizeElements, w, null), Ds(w))
      return re(w), !0;
    const Q = Ct(w.nodeName);
    if (de(A.uponSanitizeElement, w, {
      tagName: Q,
      allowedTags: X
    }), B && w.hasChildNodes() && !ha(w.firstElementChild) && $t(/<[/\w!]/g, w.innerHTML) && $t(/<[/\w!]/g, w.textContent) || w.nodeType === mn.progressingInstruction || B && w.nodeType === mn.comment && $t(/<[/\w]/g, w.data))
      return re(w), !0;
    if (!X[Q] || Y[Q]) {
      if (!Y[Q] && fa(Q) && (j.tagNameCheck instanceof RegExp && $t(j.tagNameCheck, Q) || j.tagNameCheck instanceof Function && j.tagNameCheck(Q)))
        return !1;
      if (Le && !Ve[Q]) {
        const St = y(w) || w.parentNode, It = S(w) || w.childNodes;
        if (It && St) {
          const At = It.length;
          for (let zt = At - 1; zt >= 0; --zt) {
            const pe = g(It[zt], !0);
            pe.__removalCount = (w.__removalCount || 0) + 1, St.insertBefore(pe, v(w));
          }
        }
      }
      return re(w), !0;
    }
    return w instanceof c && !sl(w) || (Q === "noscript" || Q === "noembed" || Q === "noframes") && $t(/<\/no(script|embed|frames)/i, w.innerHTML) ? (re(w), !0) : (z && w.nodeType === mn.text && (W = w.textContent, Jn([H, N, M], (St) => {
      W = pn(W, St, " ");
    }), w.textContent !== W && (dn(t.removed, {
      element: w.cloneNode()
    }), w.textContent = W)), de(A.afterSanitizeElements, w, null), !1);
  }, pa = function(w, W, Q) {
    if (Wt && (W === "id" || W === "name") && (Q in e || Q in nl))
      return !1;
    if (!(ct && !K[W] && $t(L, W))) {
      if (!(ot && $t(P, W))) {
        if (!Z[W] || K[W]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(fa(w) && (j.tagNameCheck instanceof RegExp && $t(j.tagNameCheck, w) || j.tagNameCheck instanceof Function && j.tagNameCheck(w)) && (j.attributeNameCheck instanceof RegExp && $t(j.attributeNameCheck, W) || j.attributeNameCheck instanceof Function && j.attributeNameCheck(W)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            W === "is" && j.allowCustomizedBuiltInElements && (j.tagNameCheck instanceof RegExp && $t(j.tagNameCheck, Q) || j.tagNameCheck instanceof Function && j.tagNameCheck(Q)))
          ) return !1;
        } else if (!ks[W]) {
          if (!$t(q, pn(Q, C, ""))) {
            if (!((W === "src" || W === "xlink:href" || W === "href") && w !== "script" && md(Q, "data:") === 0 && sa[w])) {
              if (!(st && !$t($, pn(Q, C, "")))) {
                if (Q)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, fa = function(w) {
    return w !== "annotation-xml" && gr(w, V);
  }, ga = function(w) {
    de(A.beforeSanitizeAttributes, w, null);
    const {
      attributes: W
    } = w;
    if (!W || Ds(w))
      return;
    const Q = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: Z,
      forceKeepAttr: void 0
    };
    let St = W.length;
    for (; St--; ) {
      const It = W[St], {
        name: At,
        namespaceURI: zt,
        value: pe
      } = It, un = Ct(At), Ns = pe;
      let Rt = At === "value" ? Ns : vd(Ns);
      if (Q.attrName = un, Q.attrValue = Rt, Q.keepAttr = !0, Q.forceKeepAttr = void 0, de(A.uponSanitizeAttribute, w, Q), Rt = Q.attrValue, on && (un === "id" || un === "name") && (Be(At, w), Rt = ln + Rt), B && $t(/((--!?|])>)|<\/(style|title)/i, Rt)) {
        Be(At, w);
        continue;
      }
      if (Q.forceKeepAttr)
        continue;
      if (!Q.keepAttr) {
        Be(At, w);
        continue;
      }
      if (!it && $t(/\/>/i, Rt)) {
        Be(At, w);
        continue;
      }
      z && Jn([H, N, M], (va) => {
        Rt = pn(Rt, va, " ");
      });
      const ma = Ct(w.nodeName);
      if (!pa(ma, un, Rt)) {
        Be(At, w);
        continue;
      }
      if (E && typeof p == "object" && typeof p.getAttributeType == "function" && !zt)
        switch (p.getAttributeType(ma, un)) {
          case "TrustedHTML": {
            Rt = E.createHTML(Rt);
            break;
          }
          case "TrustedScriptURL": {
            Rt = E.createScriptURL(Rt);
            break;
          }
        }
      if (Rt !== Ns)
        try {
          zt ? w.setAttributeNS(zt, At, Rt) : w.setAttribute(At, Rt), Ds(w) ? re(w) : fr(t.removed);
        } catch {
          Be(At, w);
        }
    }
    de(A.afterSanitizeAttributes, w, null);
  }, il = function tt(w) {
    let W = null;
    const Q = ua(w);
    for (de(A.beforeSanitizeShadowDOM, w, null); W = Q.nextNode(); )
      de(A.uponSanitizeShadowNode, W, null), da(W), ga(W), W.content instanceof a && tt(W.content);
    de(A.afterSanitizeShadowDOM, w, null);
  };
  return t.sanitize = function(tt) {
    let w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, W = null, Q = null, St = null, It = null;
    if (_s = !tt, _s && (tt = "<!-->"), typeof tt != "string" && !ha(tt))
      if (typeof tt.toString == "function") {
        if (tt = tt.toString(), typeof tt != "string")
          throw fn("dirty is not a string, aborting");
      } else
        throw fn("toString is not a function");
    if (!t.isSupported)
      return tt;
    if (wt || Rs(w), t.removed = [], typeof tt == "string" && (ne = !1), ne) {
      if (tt.nodeName) {
        const pe = Ct(tt.nodeName);
        if (!X[pe] || Y[pe])
          throw fn("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (tt instanceof o)
      W = ca("<!---->"), Q = W.ownerDocument.importNode(tt, !0), Q.nodeType === mn.element && Q.nodeName === "BODY" || Q.nodeName === "HTML" ? W = Q : W.appendChild(Q);
    else {
      if (!et && !z && !U && // eslint-disable-next-line unicorn/prefer-includes
      tt.indexOf("<") === -1)
        return E && Zt ? E.createHTML(tt) : tt;
      if (W = ca(tt), !W)
        return et ? null : Zt ? x : "";
    }
    W && be && re(W.firstChild);
    const At = ua(ne ? tt : W);
    for (; St = At.nextNode(); )
      da(St), ga(St), St.content instanceof a && il(St.content);
    if (ne)
      return tt;
    if (et) {
      if (yt)
        for (It = _.call(W.ownerDocument); W.firstChild; )
          It.appendChild(W.firstChild);
      else
        It = W;
      return (Z.shadowroot || Z.shadowrootmode) && (It = R.call(n, It, !0)), It;
    }
    let zt = U ? W.outerHTML : W.innerHTML;
    return U && X["!doctype"] && W.ownerDocument && W.ownerDocument.doctype && W.ownerDocument.doctype.name && $t(Wo, W.ownerDocument.doctype.name) && (zt = "<!DOCTYPE " + W.ownerDocument.doctype.name + `>
` + zt), z && Jn([H, N, M], (pe) => {
      zt = pn(zt, pe, " ");
    }), E && Zt ? E.createHTML(zt) : zt;
  }, t.setConfig = function() {
    let tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Rs(tt), wt = !0;
  }, t.clearConfig = function() {
    He = null, wt = !1;
  }, t.isValidAttribute = function(tt, w, W) {
    He || Rs({});
    const Q = Ct(tt), St = Ct(w);
    return pa(Q, St, W);
  }, t.addHook = function(tt, w) {
    typeof w == "function" && dn(A[tt], w);
  }, t.removeHook = function(tt, w) {
    if (w !== void 0) {
      const W = fd(A[tt], w);
      return W === -1 ? void 0 : gd(A[tt], W, 1)[0];
    }
    return fr(A[tt]);
  }, t.removeHooks = function(tt) {
    A[tt] = [];
  }, t.removeAllHooks = function() {
    A = Sr();
  }, t;
}
var Ji = Xo();
const ts = (i) => Ji.sanitize(i, {
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), Id = (i) => Ji.sanitize(i, {
  NAMESPACE: "http://www.w3.org/2000/svg",
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), ue = (i) => Ji.sanitize(i, { ALLOWED_TAGS: [] }), bs = class bs extends dt {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = at.HTML;
  }
  init() {
    const t = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(T.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", t);
    }), this.services.events.addEventListener(T.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", t);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "toolbar"
    }).attr("role", "group");
    if (O(this.getOptions(), "data", "loading"))
      e.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = e.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: s, overflowMenuItemList: a } = this.getControlConfigs();
      a && s.push(this.getOverflowButtonConfig());
      const r = e.selectAll("div.toolbar-control").data(s, (l) => l.id);
      r.exit().remove();
      const o = r.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu"), c = this;
      o.merge(r).classed("disabled", (l) => l.shouldBeDisabled()).attr("role", "button").attr("aria-disabled", (l) => l.shouldBeDisabled()).attr("aria-label", (l) => l.title).html((l) => `
			<button
	 			type="button"
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
        `control-${ue(l.id)}`
      )}" aria-label="${ue(l.title)}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${Id(l.iconSVG.content)}
				</svg>
			</button>`).each(function(l, h) {
        D(this).select("svg").style("pointer-events", "none").style("will-change", "transform").style("width", l.iconSVG.width !== void 0 ? l.iconSVG.width : "20px").style("height", l.iconSVG.height !== void 0 ? l.iconSVG.height : "20px"), D(this).select("button").on("mouseover focus", function(d) {
          const u = D(this);
          u.classed("hovered", !0), c.services.events.dispatchEvent(T.Toolbar.SHOW_TOOLTIP, {
            event: d,
            hoveredElement: u,
            content: l.title,
            noWrap: !0,
            placements: ["top", "bottom"]
          });
        }).on("mouseout blur", function() {
          c.services.events.dispatchEvent(T.Toolbar.HIDE_TOOLTIP);
        }).on("click", (d) => {
          l.shouldBeDisabled() || c.triggerFunctionAndEvent(l, d, this);
        }).on("keydown", (d) => {
          d.key && d.key === "Enter" || d.key === " " ? (d.preventDefault(), c.triggerFunctionAndEvent(l, d, this)) : d.key && d.key === "ArrowLeft" ? c.focusOnPreviousEnabledToolbarItem(h) : d.key && d.key === "ArrowRight" && c.focusOnNextEnabledToolbarItem(h);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: t } = this.getControlConfigs(), e = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(t, (s) => O(s, "id"));
    e.exit().remove();
    const n = e.enter().append("li").attr("id", (s) => this.services.domUtils.generateElementIDString(`control-${s.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    n.append("button").attr("type", "button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), n.merge(e).classed("cds--overflow-menu-options__option--disabled", (s) => s.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (s) => s.shouldBeDisabled()).attr("aria-disabled", (s) => s.shouldBeDisabled()).selectAll("button").text((s) => s.title);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(t) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", t), this.overflowButton && (this.overflowButton.attr("aria-expanded", t), D(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", t).classed("cds--overflow-menu--open", t)), t ? this.services.events.dispatchEvent(T.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(T.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(t) {
    const e = this.getToolbarButtonItems();
    let n = e.length;
    for (let s = t - 1; s >= 0; s--)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n < e.length) {
      const s = D(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )}`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnNextEnabledToolbarItem(t) {
    const e = this.getToolbarButtonItems();
    let n = -1;
    for (let s = t + 1; s < e.length; s++)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n > -1) {
      const s = D(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )}`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(t) {
    const e = this.getOverflowMenuItems();
    let n = e.length;
    for (let s = t - 1; s >= 0; s--)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n < e.length) {
      const s = D(
        `#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )} button`
      ).node();
      "focus" in s && s.focus();
    }
  }
  focusOnNextEnabledMenuItem(t) {
    const e = this.getOverflowMenuItems();
    let n = -1;
    for (let s = t + 1; s < e.length; s++)
      if (!e[s].shouldBeDisabled()) {
        n = s;
        break;
      }
    if (n > -1) {
      const s = D(
        `#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )} button`
      ).node();
      "focus" in s && s.focus();
    }
  }
  toggleOverflowMenu(t) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const e = this;
      this.getOverflowMenuItems().forEach((s, a) => {
        const r = D(
          `#${this.services.domUtils.generateElementIDString(`control-${s.id}`)}`
        );
        r !== null && (r.on("click", () => {
          e.triggerFunctionAndEvent(s, t, r.node()), e.updateOverflowMenu(!1);
        }), r.on("keydown", (o) => {
          o && o.key === "Enter" ? e.triggerFunctionAndEvent(s, t, r.node()) : o && o.key === "ArrowUp" ? e.focusOnPreviousEnabledMenuItem(a) : o && o.key === "ArrowDown" ? e.focusOnNextEnabledMenuItem(a) : o && o.key === "Escape" && e.updateOverflowMenu(!1), o.preventDefault();
        }));
      }), e.focusOnNextEnabledMenuItem(-1);
    }
    t && t.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(t, e, n) {
    typeof t.shouldBeDisabled == "function" && t.shouldBeDisabled() || (typeof t.clickFunction == "function" && t.clickFunction(e), this.services.events.dispatchEvent(T.Toolbar.BUTTON_CLICK, {
      control: t,
      event: e,
      element: n
    }));
  }
  getControlConfigs() {
    const t = O(this.getOptions(), "toolbar", "numberOfIcons") - 1, e = O(this.getOptions(), "toolbar", "controls"), n = [], s = [], a = [];
    return e.forEach((r) => {
      let o = null;
      if (r.type === bt.CUSTOM)
        O(r, "id") === null && (r.id = `toolbar-button-${bs.buttonID++}`), O(r, "shouldBeDisabled") === null && (r.shouldBeDisabled = () => !1), o = r;
      else {
        const c = this.services.domUtils.isFullScreenMode();
        r.type === bt.MAKE_FULLSCREEN && c ? r.type = bt.EXIT_FULLSCREEN : r.type === bt.EXIT_FULLSCREEN && !c && (r.type = bt.MAKE_FULLSCREEN), o = this.getControlConfigByType(r.type);
      }
      o && (o.text = r.text ? r.text : r.type, o.id.indexOf("toolbar-export") !== -1 ? n.push(o) : s.length < t ? O(o, "iconSVG", "content") === null ? a.push(o) : s.push(o) : a.push(o));
    }), a.push(...n), a.length ? {
      buttonList: s,
      overflowMenuItemList: a
    } : {
      buttonList: s
    };
  }
  getToolbarButtonItems() {
    const { buttonList: t, overflowMenuItemList: e } = this.getControlConfigs();
    return e && t.push(this.getOverflowButtonConfig()), t || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: t } = this.getControlConfigs();
    return t || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    const { moreOptions: t } = O(
      this.model.getOptions(),
      "locale",
      "translations",
      "toolbar"
    );
    return {
      id: "toolbar-overflow-menu",
      title: t,
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (e) => this.toggleOverflowMenu(e)
    };
  }
  getControlConfigByType(t) {
    const e = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), n = this.model.getDisplayData(), s = this.model.getOptions(), {
      exportAsCSV: a,
      exportAsJPG: r,
      exportAsPNG: o,
      zoomIn: c,
      zoomOut: l,
      resetZoom: h,
      makeFullScreen: d,
      exitFullScreen: u,
      showAsTable: p
    } = O(s, "locale", "translations", "toolbar");
    let f;
    switch (t) {
      case bt.ZOOM_IN:
        e && (f = {
          id: "toolbar-zoomIn",
          title: c,
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case bt.ZOOM_OUT:
        e && (f = {
          id: "toolbar-zoomOut",
          title: l,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case bt.RESET_ZOOM:
        e && (f = {
          id: "toolbar-resetZoom",
          title: h,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case bt.MAKE_FULLSCREEN:
        f = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: d,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case bt.EXIT_FULLSCREEN:
        f = {
          id: "toolbar-exitfullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: u,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case bt.SHOW_AS_DATATABLE:
        f = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          title: p,
          shouldBeDisabled: () => n.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(T.Modal.SHOW)
        };
        break;
      case bt.EXPORT_CSV:
        f = {
          id: "toolbar-export-CSV",
          title: a,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case bt.EXPORT_PNG:
        f = {
          id: "toolbar-export-PNG",
          title: o,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case bt.EXPORT_JPG:
        f = {
          id: "toolbar-export-JPG",
          title: r,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      // add more toolbar control configuration here
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
    return f;
  }
  getControlIconByType(t) {
    switch (t) {
      case bt.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case bt.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case bt.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case bt.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case bt.EXIT_FULLSCREEN:
        return '<polygon points="4 18 4 20 10.586 20 2 28.582 3.414 30 12 21.414 12 28 14 28 14 18 4 18"/><polygon points="30 3.416 28.592 2 20 10.586 20 4 18 4 18 14 28 14 28 12 21.414 12 30 3.416"/>';
      case bt.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case bt.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case bt.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case bt.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      // add more icons here
      // svg icon must be with 32x32 viewBox
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
  }
};
bs.buttonID = 0;
let br = bs;
const Ts = class Ts extends dt {
  constructor(t, e, n, s) {
    super(t, e, s), this.type = "layout", this.configs = s, this.children = n, this._instanceID = Ts.instanceID++, this.init();
  }
  init() {
    this.children.forEach((t) => {
      t.components.forEach((e) => {
        e.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const t = this.parent;
    let e = 0;
    return t.selectAll(`div.layout-child-${this._instanceID}`).filter((n) => {
      const s = O(n, "growth");
      return s === Te.PREFERRED || s === Te.FIXED;
    }).each(function(n) {
      e += n.size;
    }), e;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((e) => O(e, "growth") === Te.STRETCH).size();
  }
  render(t = !0) {
    const e = this.model.getOptions(), n = this.parent, { width: s, height: a } = I.getHTMLElementSize(n.node()), r = this.configs.direction === ze.ROW || this.configs.direction === ze.ROW_REVERSE, o = O(this.model.getOptions(), "style", "prefix"), c = n.classed(
      `${Kt}--${o}--layout-row`,
      this.configs.direction === ze.ROW
    ).classed(
      `${Kt}--${o}--layout-row-reverse`,
      this.configs.direction === ze.ROW_REVERSE
    ).classed(
      `${Kt}--${o}--layout-column`,
      this.configs.direction === ze.COLUMN
    ).classed(
      `${Kt}--${o}--layout-column-reverse`,
      this.configs.direction === ze.COLUMN_REVERSE
    ).classed(
      `${Kt}--${o}--layout-alignitems-center`,
      this.configs.alignItems === xl.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    c.enter().append("div").merge(n.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (d) => `layout-child layout-child-${this._instanceID} ${d.id}`).each(function(d) {
      d.components.forEach((u) => {
        var v;
        const p = D(this), g = O(d, "renderType") === at.SVG;
        u.setParent(
          g ? I.appendOrSelect(p, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : p
        ), g && !p.select("svg.layout-svg-wrapper").attr("aria-label") && p.select("svg.layout-svg-wrapper").attr("aria-label", ((v = e == null ? void 0 : e.accessibility) == null ? void 0 : v.svgAriaLabel) || (e == null ? void 0 : e.title));
        const m = O(d, "growth");
        (m === Te.PREFERRED || m === Te.FIXED) && u.render(t);
      });
    }), n.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(d) {
      const u = O(d, "growth"), f = O(d, "renderType") === at.SVG ? I.getSVGElementSize(D(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : I.getHTMLElementSize(this);
      if (u === Te.PREFERRED) {
        const g = r ? f.width : f.height, m = r ? s : a;
        d.size = g / m * 100;
      }
    }), c.exit().remove(), this.children.filter((d) => O(d, "growth") === Te.STRETCH).forEach((d) => {
      d.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const h = n.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (d) => d.id);
    r ? h.style("width", (d) => `${d.size / 100 * s}px`).style("height", "100%") : h.style("height", (d) => `${d.size / 100 * a}px`).style("width", "100%"), h.each(function(d) {
      d.components.forEach((u) => {
        O(d, "growth") === Te.STRETCH && u.render(t);
      });
    });
  }
  // Pass on model to children as well
  setModel(t) {
    super.setModel(t), this.children.forEach((e) => {
      e.components.forEach((n) => n.setModel(t));
    });
  }
  // Pass on essentials to children as well
  setServices(t) {
    super.setServices(t), this.children.forEach((e) => {
      e.components.forEach((n) => n.setServices(t));
    });
  }
  destroy() {
    this.children.forEach((t) => {
      t.components.forEach((e) => e.destroy());
    });
  }
};
Ts.instanceID = Math.floor(Math.random() * 99999999999);
let Tr = Ts;
class om extends dt {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    this.getComponentContainer({
      isPresentational: !0
    }).style("width", `${this.configs.size || Ea.default.size}px`).style("height", `${this.configs.size || Ea.default.size}px`).attr("opacity", 0);
  }
}
class lm extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      const s = this.services.domUtils.getChartID();
      this.modal.attr("data-modal", !0).attr("class", "cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", `${s}__modal-title`).attr("aria-describedby", `${s}__modal-description`).attr("tabindex", -1).style("opacity", 1).style("visibility", "visible"), this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), this.modal.on("click", this.handleHideModal), this.modal.select(".cds--modal-container").on("click", (a) => {
        a.stopPropagation();
      }), this.modal.select(".cds--modal-close").on("click", this.handleHideModal), typeof window < "u" && window.addEventListener("keydown", this.handleEscapeKey);
    }, this.handleEscapeKey = (s) => {
      s.key === "Escape" && this.handleHideModal();
    }, this.handleHideModal = () => {
      this.modal.attr("role", null).attr("aria-modal", null).attr("aria-labelledby", null).attr("aria-describedby", null).attr("tabindex", null).style("opacity", 0).style("visibility", "hidden"), this.modal.on("click", null), this.modal.select(".cds--modal-container").on("click", null), this.modal.select(".cds--modal-close").on("click", null), typeof window < "u" && window.removeEventListener("keydown", this.handleEscapeKey);
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(T.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(T.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const t = this.services.domUtils.getChartID(), e = this.model.getOptions(), { title: n, downloadAsCSV: s } = O(e, "locale", "translations", "tabularRep"), a = O(e, "style", "prefix"), r = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container">
			<div class="cds--modal-header">

				<p class="cds--modal-header__label cds--type-delta" id="modal-title">${n}</p>

				<p class="cds--modal-header__heading cds--type-beta" id="${t}__modal-description">${ue(
      e.title
    )}</p>

				<button class="cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${xt(r, 0).map(
      (o) => `<th scope="col">
								<div class="cds--table-header-label">${ue(o)}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${r.slice(1).map(
      (o) => `
							<tr>
								${o.map((c) => `<td>${ue(c)}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer">
			  <div class="${Kt}--${a}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary" type="button" data-modal-primary-focus>${s}</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const n = D(this.services.domUtils.getHolder()), s = O(e, "style", "prefix");
      this.modal = I.appendOrSelect(n, `div.${Kt}--${s}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0;
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class Rd extends dt {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = at.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getComponentContainer(), n = O(this.getOptions(), "title"), s = e.selectAll("p.title").data([n]);
    if (s.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(s).html((a) => ue(a)), s.node() && s.node().offsetWidth < s.node().scrollWidth) {
      const a = this;
      s.on("mouseover", function(r) {
        a.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: r,
          hoveredElement: s,
          content: s.text()
        });
      }).on("mousemove", function(r) {
        a.services.events.dispatchEvent(T.Tooltip.MOVE, {
          event: r
        });
      }).on("mouseout", function() {
        a.services.events.dispatchEvent(T.Tooltip.HIDE);
      });
    }
    s.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(t, e) {
    if (e <= 0)
      return;
    const n = t.text();
    if (t.node().getComputedTextLength() > e) {
      t.append("tspan").text("...");
      const s = I.appendOrSelect(t, "tspan").node().getComputedTextLength(), a = t.text(), r = this.getSubstringIndex(
        t.node(),
        0,
        a.length - 1,
        e - s
      );
      t.html(a.substring(0, r - 1)).append("tspan").text("...");
      const o = this;
      t.on("mouseover", function(c) {
        o.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: c,
          hoveredElement: t,
          content: n
        });
      }).on("mousemove", function(c) {
        o.services.events.dispatchEvent(T.Tooltip.MOVE, {
          event: c
        });
      }).on("mouseout", function() {
        o.services.events.dispatchEvent(T.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return I.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(t, e, n, s) {
    const a = Math.floor((n + e) / 2);
    return t.getSubStringLength(0, a) > s ? this.getSubstringIndex(t, e, a, s) : t.getSubStringLength(0, a) < s ? t.getSubStringLength(0, a + 1) > s ? a : this.getSubstringIndex(t, a, n, s) : a;
  }
}
class Dd extends dt {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = at.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = O(e, "legend"), s = O(n, "alignment"), a = O(e, "legend", "orientation");
    let r = this.model.getDataGroups();
    const { DISABLED: o } = Mt.items.status, c = r.some((S) => S.status === o), l = O(n, "order"), h = this.getComponentContainer().classed("center-aligned", s === te.CENTER).classed("right-aligned", s === te.RIGHT).classed(a || "horizontal", !0).classed("has-deactivated-items", c).attr("role", lt.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    l && (r = this.sortDataGroups(r, l));
    const d = h.selectAll("div.legend-item").data(r, (S) => S.name), u = d.enter().append("div").attr("class", "legend-item");
    u.merge(h.selectAll("div.legend-item")).classed("active", function(S) {
      return S.status === Mt.items.status.ACTIVE;
    });
    const p = O(this.getOptions(), "legend", "clickable");
    h.classed("clickable", p && r.length > 1);
    const f = Mt.checkbox.radius, g = u.append("div").classed("checkbox", !0), m = g.merge(d.select("div.checkbox")).attr("role", lt.CHECKBOX).attr("tabindex", p ? 0 : -1).attr(
      "aria-labelledby",
      (S, y) => this.services.domUtils.generateElementIDString(`legend-datagroup-${y}-title`)
    ).attr("aria-checked", ({ status: S }) => S === Mt.items.status.ACTIVE).attr("width", f * 2).attr("height", f * 2).attr(
      "class",
      (S) => this.model.getColorClassName({
        classNameTypes: [nt.BACKGROUND],
        dataGroupName: S.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (S) => S.status === Mt.items.status.ACTIVE ? this.model.getFillColor(S.name) || this.model.getStrokeColor(S.name) : null
    ).classed("active", function(S) {
      return S.status === Mt.items.status.ACTIVE;
    });
    g.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), u.append("p").merge(d.select("p"));
    const v = O(e, "legend", "additionalItems");
    if (v && r.length) {
      const S = this, y = h.selectAll("div.additional-item").data(v);
      y.exit().remove();
      const E = y.enter().append("div").merge(y).classed("legend-item", !0).classed("additional", !0).attr("role", "img").attr(
        "aria-labelledby",
        (k, _) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${m.size() + _}-title`
        )
      );
      E.selectAll("*").remove();
      let x, b = 1;
      E.append("svg").classed("icon", !0).each(function(k) {
        const _ = D(this);
        !x || x != k.type ? (x = k.type, b = 1) : b++, S.addAdditionalItem(_, k, b);
      }), E.append("p").merge(E.select("p")), this.truncateLegendText();
    }
    d.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), p && u.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(t, e) {
    if (t.sort(
      (n, s) => e.indexOf(n.name) - e.indexOf(s.name)
    ), e.length < t.length) {
      const n = t.length - e.length;
      return t.slice(n).concat(t.slice(0, n));
    }
    return t;
  }
  addAdditionalItem(t, e, n) {
    const { width: s, height: a } = Mt.area;
    if (e.type === Me.RADIUS ? t.style("width", `${a}px`).style("height", `${a}px`) : t.style("width", `${s}px`).style("height", `${a}px`), e.type === Me.RADIUS) {
      const { iconData: r, fill: o, stroke: c } = Mt.radius;
      t.attr("fill", "none").selectAll("circle").data(r).enter().append("circle").classed("radius", !0).attr("role", lt.IMG).attr("aria-label", "radius").attr("cx", (h) => h.cx).attr("cy", (h) => h.cy).attr("r", (h) => h.r).style("fill", e.fill ? e.fill : o).style("stroke", e.stroke ? e.stroke : c);
    } else if (e.type === Me.LINE) {
      const r = Mt.line;
      t.select("line.line").empty() && t.append("line").classed(`line-${n}`, !0).attr("role", lt.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", r.yPosition).attr("x2", s).attr("y2", r.yPosition).style("stroke", e.stroke ? e.stroke : r.stroke).style("stroke-width", r.strokeWidth);
    } else if (e.type === Me.AREA)
      t.select("rect.area").empty() && t.append("rect").classed(`area-${n}`, !0).attr("role", lt.IMG).attr("aria-label", "area").attr("width", s).attr("height", a).style(
        "fill",
        n > 3 && !e.fill ? Mt.area.fill : e.fill
      ).style("stroke", e.stroke);
    else if (e.type === Me.SIZE) {
      const { iconData: r, fill: o, stroke: c } = Mt.size;
      t.attr("fill", "none").attr("role", lt.IMG).attr("aria-label", "size").selectAll("rect").data(r).enter().append("rect").classed("size", !0).attr("width", (h) => h.width).attr("height", (h) => h.height).attr("y", () => 0).style("fill", e.fill ? e.fill : o).style("stroke", e.stroke ? e.stroke : c).style("stroke-width", 1);
    } else if (e.type === Me.QUARTILE) {
      const { iconData: r } = Mt.quartile;
      t.selectAll("rect").attr("role", lt.IMG).attr("aria-label", "quartile").data(r).enter().append("rect").attr("class", (c, l) => `quartile-${l === 0 ? "wrapper" : "line"}`).attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height);
    } else if (e.type === Me.ZOOM) {
      const { iconData: r, color: o } = O(Mt, "zoom"), c = t.attr("role", lt.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(r).enter();
      c.append("g").attr("x", (l) => l.x).attr("y", (l) => l.y).attr("width", (l) => l.width).attr("height", (l) => l.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => e.color ? e.color : o), c.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => e.color ? e.color : o);
    }
  }
  truncateLegendText() {
    const t = this.getComponentContainer(), e = O(this.getOptions(), "legend", "truncation"), n = O(e, "type"), s = O(e, "threshold"), a = O(e, "numCharacter"), r = t.selectAll("div.legend-item p");
    r.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), n !== Je.NONE ? r.html(function(o) {
      const c = ue(o.name);
      return c.length > s && c.length !== a ? Cn(c, n, a) : c;
    }) : r.html((o) => ue(o.name));
  }
  addEventListeners() {
    const t = this, e = this.getComponentContainer(), n = this.getOptions(), s = O(n, "legend"), a = O(s, "truncation");
    e.selectAll("div.legend-item").on("mouseover", function(r) {
      t.services.events.dispatchEvent(T.Legend.ITEM_HOVER, {
        hoveredElement: D(this)
      });
      const o = D(this);
      o.select("div.checkbox").classed("hovered", !0);
      const c = o.datum();
      c.name.length > a.threshold && a.numCharacter < c.name.length && a.type !== Je.NONE && t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        content: c.name
      });
    }).on("mousemove", function(r) {
      D(this).datum().name.length > a.threshold && a.type !== Je.NONE && t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function() {
      t.services.events.dispatchEvent(T.Legend.ITEM_CLICK, {
        clickedElement: D(this)
      });
      const o = D(this).datum();
      t.model.toggleDataLabel(o.name);
    }).on("mouseout", function() {
      const r = D(this);
      r.select("div.checkbox").classed("hovered", !1), r.datum().name.length > a.threshold && a.type !== Je.NONE && t.services.events.dispatchEvent(T.Tooltip.HIDE), t.services.events.dispatchEvent(T.Legend.ITEM_MOUSEOUT, {
        hoveredElement: r
      });
    }), e.selectAll("div.legend-item div.checkbox").on("keyup", function(r) {
      r.key && r.key === "Tab" && t.services.events.dispatchEvent(T.Legend.ITEM_HOVER, {
        hoveredElement: D(this)
      });
    }), e.selectAll("div.legend-item div.checkbox").on("keydown", function(r, o) {
      r.key && r.key === " " ? (r.preventDefault(), t.model.toggleDataLabel(o.name)) : r.key && r.key === "Tab" && t.services.events.dispatchEvent(T.Legend.ITEM_MOUSEOUT, {
        hoveredElement: D(this)
      });
    }), e.selectAll("g.additional-item").on("mouseover", function(r) {
      const o = D(this), c = o.datum();
      c.name.length > a.threshold && t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        content: c.name
      });
    });
  }
}
class Nd extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "chart-clip", this.renderType = at.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const t = this.parent, { cartesianScales: e } = this.services;
    if (!e) throw new Error("Service cartesianScales was undefined");
    const n = e.getMainXScale(), s = e.getMainYScale(), [a, r] = n.range(), [o, c] = s.range();
    if (!t)
      throw new Error("svg is undefined");
    this.chartClipPath = I.appendOrSelect(
      t,
      `clipPath.${this.type}`
    ).attr("id", this.chartClipId);
    const l = I.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    r - a > 0 && l.attr("x", a).attr("y", c).attr("width", r - a).attr("height", o - c), this.chartClipPath.merge(l).lower();
  }
}
class cm extends Nd {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const t = this.parent, { width: e, height: n } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = I.appendOrSelect(t, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const s = I.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    s.attr("x", 0).attr("y", 0).attr("width", e).attr("height", n), this.chartClipPath.merge(s).lower();
  }
}
var Ye, Lt;
(function(i) {
  i.LEFT = "left", i.RIGHT = "right", i.TOP = "top", i.BOTTOM = "bottom";
})(Lt || (Lt = {}));
var Or = (Ye = {}, Ye[Lt.LEFT] = function(i, t, e) {
  return {
    top: i.top - Math.round(t.offsetHeight / 2) + Math.round(e.height / 2),
    left: Math.round(i.left - t.offsetWidth)
  };
}, Ye[Lt.RIGHT] = function(i, t, e) {
  return {
    top: i.top - Math.round(t.offsetHeight / 2) + Math.round(e.height / 2),
    left: Math.round(i.left + e.width)
  };
}, Ye[Lt.TOP] = function(i, t, e) {
  return {
    top: Math.round(i.top - t.offsetHeight),
    left: i.left - Math.round(t.offsetWidth / 2) + Math.round(e.width / 2)
  };
}, Ye[Lt.BOTTOM] = function(i, t, e) {
  return {
    top: Math.round(i.top + e.height),
    left: i.left - Math.round(t.offsetWidth / 2) + Math.round(e.width / 2)
  };
}, Ye), Lr = typeof window < "u" ? window : {
  innerHeight: 0,
  innerWidth: 0
}, Cs = (
  /** @class */
  function() {
    function i(t) {
      t === void 0 && (t = {}), this.positions = Or, this.positions = Object.assign({}, Or, t);
    }
    return i.prototype.getRelativeOffset = function(t) {
      for (var e = {
        left: t.offsetLeft,
        top: t.offsetTop
      }; t.offsetParent && getComputedStyle(t.offsetParent).position === "static"; )
        e.left += t.offsetLeft, e.top += t.offsetTop, t = t.offsetParent;
      return e;
    }, i.prototype.getAbsoluteOffset = function(t) {
      for (var e = t, n = {
        top: 0,
        left: 0
      }; e.offsetParent; ) {
        var s = getComputedStyle(e.offsetParent);
        s.position === "static" && s.marginLeft && s.marginTop && (parseInt(s.marginTop, 10) && (n.top += parseInt(s.marginTop, 10)), parseInt(s.marginLeft, 10) && (n.left += parseInt(s.marginLeft, 10))), e = e.offsetParent;
      }
      var a = t.getBoundingClientRect(), r = document.body.getBoundingClientRect();
      return {
        top: a.top - r.top + n.top,
        left: a.left - r.left + n.left
      };
    }, i.prototype.findRelative = function(t, e, n) {
      var s = this.getRelativeOffset(t), a = t.getBoundingClientRect();
      return this.calculatePosition(s, a, e, n);
    }, i.prototype.findAbsolute = function(t, e, n) {
      var s = this.getAbsoluteOffset(t), a = t.getBoundingClientRect();
      return this.calculatePosition(s, a, e, n);
    }, i.prototype.findPosition = function(t, e, n, s) {
      s === void 0 && (s = this.getAbsoluteOffset.bind(this));
      var a = s(t), r = t.getBoundingClientRect();
      return this.calculatePosition(a, r, e, n);
    }, i.prototype.findPositionAt = function(t, e, n) {
      return this.calculatePosition(t, { top: 0, left: 0, height: 0, width: 0 }, e, n);
    }, i.prototype.getPlacementBox = function(t, e) {
      var n = t.offsetHeight + e.top, s = t.offsetWidth + e.left;
      return {
        top: e.top,
        bottom: n,
        left: e.left,
        right: s
      };
    }, i.prototype.addOffset = function(t, e, n) {
      return e === void 0 && (e = 0), n === void 0 && (n = 0), Object.assign({}, t, {
        top: t.top + e,
        left: t.left + n
      });
    }, i.prototype.setElement = function(t, e) {
      t.style.top = e.top + "px", t.style.left = e.left + "px";
    }, i.prototype.findBestPlacement = function(t, e, n, s, a) {
      var r = this;
      s === void 0 && (s = this.defaultContainerFunction.bind(this)), a === void 0 && (a = this.findPosition.bind(this));
      var o = n.map(function(c) {
        var l = a(t, e, c), h = r.getPlacementBox(e, l), d = 0, u = 0, p = s();
        h.top < p.top ? d = p.top - h.top : h.bottom > p.height && (d = h.bottom - p.height), h.left < p.left ? u = p.left - h.left : h.right > p.width && (u = h.right - p.width), d && !u ? u = 1 : u && !d && (d = 1);
        var f = e.offsetHeight * e.offsetWidth, g = d * u, m = f - g, v = m / f;
        return {
          placement: c,
          weight: v
        };
      });
      return o.sort(function(c, l) {
        return l.weight - c.weight;
      }), o[0].placement;
    }, i.prototype.findBestPlacementAt = function(t, e, n, s) {
      var a = this;
      s === void 0 && (s = this.defaultContainerFunction.bind(this));
      var r = function(o, c, l) {
        return a.findPositionAt(t, c, l);
      };
      return this.findBestPlacement(null, e, n, s, r);
    }, i.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: Lr.innerHeight,
        width: Lr.innerWidth
      };
    }, i.prototype.calculatePosition = function(t, e, n, s) {
      return this.positions[s] ? this.positions[s](t, n, e) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, i;
  }()
);
new Cs();
class Pd extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "tooltip", this.renderType = at.HTML, this.isEventListenerAdded = !1, this.lastTriggeredEventType = "", this.positionService = new Cs(), this.handleShowTooltip = (s) => {
      const a = s.detail.data || s.detail.items, r = D(s.detail.event.target).datum();
      let o;
      const c = this.formatItems(this.getItems(s));
      s.detail.content ? o = `<div class="title-tooltip"><p>${ts(s.detail.content)}</p></div>` : o = ts(this.getTooltipHTML(c));
      const l = I.appendOrSelect(this.tooltip, "div.content-box");
      if (O(this.getOptions(), "tooltip", "customHTML"))
        if (s.detail.content) {
          const h = `<div class="title-tooltip"><p>${ts(
            s.detail.content
          )}</p></div>`;
          l.html(h);
        } else
          l.html(
            `<div class="title-tooltip"><p>${ts(
              this.model.getOptions().tooltip.customHTML(a, o, r)
            )}</p></div>`
          );
      else
        l.html(o);
      l.selectAll(".datapoint-tooltip").each(function(h, d) {
        const u = c[d];
        c[d] && c[d].color && D(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", u.color);
      }), this.positionTooltip(s), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1), this.lastTriggeredEventType = s.type;
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(T.Tooltip.MOVE, (t) => {
      this.lastTriggeredEventType !== T.Toolbar.SHOW_TOOLTIP && this.tooltip.classed("hidden") === !1 && this.positionTooltip(t);
    }), this.services.events.addEventListener(T.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(T.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(T.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.addEventListener(T.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.addEventListener(T.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(T.Tooltip.MOVE, null), this.services.events.removeEventListener(T.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(T.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(T.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.removeEventListener(T.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.removeEventListener(T.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  getItems(t) {
    return t.detail.items ? t.detail.items : [];
  }
  formatItems(t) {
    const e = this.getOptions(), n = O(e, "tooltip", "truncation", "type"), s = O(e, "tooltip", "truncation", "threshold"), a = O(e, "tooltip", "truncation", "numCharacter");
    return n !== Je.NONE ? t.map((r) => {
      const o = r.labelIcon ? 12 : 0;
      return r.value = this.valueFormatter(r.value, r.label), r.label && r.label.length + o > s && (r.label = Cn(r.label, n, a)), r.value && r.value.length > s && (r.value = Cn(r.value, n, a)), r;
    }) : t.map((r) => (r.value = this.valueFormatter(r.value, r.label), r));
  }
  getTooltipHTML(t) {
    return '<ul class="multi-tooltip">' + t.map(
      (e) => `<li>
					<div class="datapoint-tooltip${e.bold ? " bold" : ""}">
						${e.class || e.color ? `<div class="tooltip-color ${e.class}"></div>` : ""}
						<div class="label">
						<p>${e.label || ""}</p>
						${e.labelIcon ? `<span class="label-icon"/>${e.labelIcon}</span>` : ""}
						</div>
						${e.value === void 0 || e.value === null ? "" : `<p class="value"/>${e.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  isDate(t) {
    return t instanceof Date;
  }
  valueFormatter(t, e) {
    const n = this.getOptions(), s = O(n, "tooltip", "valueFormatter"), {
      code: a,
      number: r,
      date: o
    } = O(n, "locale");
    if (s)
      return s(t, e);
    if (this.isDate(t))
      return o(t, a, { month: "short", day: "numeric", year: "numeric" });
    try {
      if (typeof t == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(t)) {
        const c = new Date(t);
        return o(c, a, {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
      }
    } catch {
    }
    return r(t, a);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = O(e, "tooltip", "enabled");
    if (n) {
      const s = D(this.services.domUtils.getHolder()), a = O(e, "style", "prefix");
      this.tooltip = I.appendOrSelect(s, `div.${Kt}--${a}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else !n && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  addOffsetByPlacement(t, e, n) {
    const s = Object.assign({}, t);
    return e == Lt.LEFT ? s.left -= n : e == Lt.RIGHT ? s.left += n : e == Lt.TOP ? s.top -= n : e == Lt.BOTTOM && (s.top += n), s;
  }
  positionTooltip(t) {
    const e = this.services.domUtils.getHolder(), n = e.offsetWidth, s = e.offsetHeight, a = this.tooltip.node(), r = this.getOptions(), o = O(r, "zoomBar", "top", "enabled"), c = !!O(t, "detail", "noWrap"), l = Array.isArray(O(t, "detail", "placements")), h = l ? O(t, "detail", "placements") : [Lt.RIGHT, Lt.LEFT, Lt.TOP, Lt.BOTTOM];
    let d, { horizontalOffset: u } = xa;
    const { defaultOffset: p } = xa;
    if (this.tooltip.select("div.title-tooltip").classed("title-tooltip-nowrap", c), l) {
      const m = O(t, "detail", "event", "target"), v = this.services.domUtils.getElementOffset(m, !0);
      d = this.positionService.findBestPlacementAt(
        v,
        a,
        h,
        () => ({
          top: 0,
          left: 0,
          width: n,
          height: s
        })
      );
      let S = this.positionService.findPosition(
        m,
        a,
        d,
        () => this.services.domUtils.getElementOffset(m)
      );
      S = this.addOffsetByPlacement(S, d, p), this.positionService.setElement(a, S);
      return;
    }
    let f = O(t, "detail", "mousePosition");
    if (!f)
      f = sn(O(t, "detail", "event"), e);
    else {
      const m = O(r, "zoomBar", "top", "type"), v = jt.height[m];
      o && (f[1] += v + jt.spacerHeight);
    }
    f[0] / n > 0.9 ? d = Lt.LEFT : f[0] / n < 0.1 ? d = Lt.RIGHT : d = this.positionService.findBestPlacementAt(
      {
        left: f[0],
        top: f[1]
      },
      a,
      h,
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: n,
        height: s
      })
    ), d === Lt.LEFT && (u *= -1);
    const g = this.positionService.findPositionAt(
      {
        left: f[0] + u,
        top: f[1]
      },
      a,
      d
    );
    this.positionService.setElement(a, g);
  }
}
const en = class en extends dt {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = at.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.parent, n = this.getComponentContainer({
      isPresentational: !0
    });
    if (!e) throw new Error("SVG was not defined");
    const s = I.appendOrSelect(
      e,
      "svg.chart-grid-backdrop"
    ), a = I.appendOrSelect(s, `g.${this.type}`), r = I.appendOrSelect(a, this.selectionSelector), { width: o, height: c } = I.getSVGElementSize(s, {
      useAttrs: !0
    }), { cartesianScales: l } = this.services, h = l.getMainXScaleType(), d = l.getMainXScale(), [u] = d.range();
    n.attr("transform", `translate(${u},0)`);
    const p = I.appendOrSelect(n, this.frontSelectionSelector);
    if (d && h === kt.TIME) {
      let f = this.model.get("zoomDomain");
      f === void 0 && (f = this.services.zoom.getDefaultZoomBarDomain(), f && this.model.set({ zoomDomain: f }, { animate: !1 }));
      const g = (x) => {
        const b = x[1] - x[0];
        let k = "0," + b.toString();
        const _ = Math.floor(c / en.DASH_LENGTH), G = _ * en.DASH_LENGTH;
        for (let R = 0; R < _; R++)
          k += "," + en.DASH_LENGTH;
        k += "," + (c - G), _ % 2 === 1 && (k += ",0"), k += "," + b.toString(), k += "," + c.toString(), p.attr("stroke-dasharray", k);
      }, m = (x) => {
        const b = x.selection;
        b === null || b[0] === b[1] || (p.attr("x", parseFloat(r.attr("x")) + parseFloat(s.attr("x"))).attr("y", r.attr("y")).attr("width", r.attr("width")).attr("height", r.attr("height")).style("cursor", "pointer").style("display", null), g(b));
      }, v = (x, b) => {
        const k = Ll().range([0, o]).domain(f);
        let _ = [k.invert(x), k.invert(b)];
        _[0].valueOf() === _[1].valueOf() && (_ = this.services.zoom.getDefaultZoomBarDomain()), (f[0].valueOf() !== _[0].valueOf() || f[1].valueOf() !== _[1].valueOf()) && this.services.zoom.handleDomainChange(_);
      };
      let S;
      const y = (x) => {
        const b = x.selection;
        b !== null && (v(b[0], b[1]), a.call(S.move, null), p.style("display", "none"));
      };
      c != 0 && o != 0 && (S = po().extent([
        [0, 0],
        [o - 1, c]
      ]).on("start brush end", m).on("end.brushed", y), a.call(S));
      const E = this.services.zoom.getZoomRatio();
      s.on("click", function(x) {
        if (x.shiftKey) {
          const b = this.services.domUtils.getHolder(), k = sn(a.node(), b)[0];
          let _ = k - o * E / 2;
          _ < 0 && (_ = 0);
          let G = k + o * E / 2;
          G > o && (G = o), v(_, G);
        }
      });
    }
  }
};
en.DASH_LENGTH = 4;
let Ar = en;
class um extends dt {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = at.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = po(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(T.ZoomBar.UPDATE, this.render.bind(this));
    const t = O(this.getOptions(), "zoomBar", J.TOP, "data");
    this.model.setZoomBarData(t);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "zoom bar"
    }), n = this.services.zoom.isZoomBarLoading(J.TOP), s = this.services.zoom.isZoomBarLocked(J.TOP), a = O(this.getOptions(), "zoomBar", J.TOP, "type"), r = O(this.getOptions(), "axes", J.BOTTOM, "highlights"), o = jt.height[a], { width: c } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (c === 0)
      return;
    let l = 0;
    const h = this.model.get("axesMargins");
    h && h.left && (l = h.left);
    const d = I.appendOrSelect(e, "svg.zoom-container").attr("width", "100%").attr("height", o).attr("opacity", 1);
    if (I.appendOrSelect(e, "rect.zoom-spacer").attr("x", 0).attr("y", o).attr("width", "100%").attr("height", jt.spacerHeight).attr("opacity", 1).attr("fill", "none"), a === Ue.GRAPH_VIEW ? I.appendOrSelect(d, "rect.zoom-bg").attr("x", l).attr("y", 0).attr("width", c - l).attr("height", "100%").classed("zoom-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : a === Ue.SLIDER_VIEW && I.appendOrSelect(d, "rect.zoom-slider-bg").attr("x", l).attr("y", o / 2 - 1).attr("width", c - l).attr("height", 2).classed("zoom-slider-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), n) {
      this.renderSkeleton(d, l, c);
      return;
    }
    const { cartesianScales: u } = this.services, p = u.getMainXScale(), f = u.getMainYScale(), g = u.getMainXScaleType();
    if (p && g === kt.TIME) {
      let m = this.services.zoom.getZoomBarData();
      if (Wr(m) || m.length === 1)
        return;
      this.xScale = p.copy(), this.yScale = f.copy();
      const v = this.services.zoom.getDefaultZoomBarDomain(m);
      m = this.compensateDataForDefaultDomain(m, v);
      const S = this.model.get("initialZoomDomain"), y = O(
        this.getOptions(),
        "zoomBar",
        J.TOP,
        "initialZoomDomain"
      );
      y && y[0] && y[1] && (y[0] = new Date(y[0]), y[1] = new Date(y[1])), y && !(S && S[0].valueOf() === y[0].valueOf() && S[1].valueOf() === y[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: nn([], y),
          zoomDomain: y ? nn([], y) : v
        },
        { skipUpdate: !0 }
      ) : y === null && S !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: nn([], v)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([l, c]).domain(v), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, o - 6]).domain(Os(m, (b) => b.value));
      const E = this.model.get("zoomDomain");
      if (a === Ue.GRAPH_VIEW && (this.renderZoomBarArea(d, "path.zoom-graph-area-unselected", m, null), this.updateClipPath(e, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(d, "path.zoom-graph-area", m, this.clipId), this.renderZoomBarBaseline(d, l, c), r)) {
        const b = r.highlightStartMapsTo, k = r.highlightEndMapsTo, _ = r.color, G = r.labelMapsTo;
        r.data.forEach((R, A) => {
          I.appendOrSelect(d, `rect.highlight-${A}`).attr("height", o - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(R[b])).attr(
            "width",
            this.xScale(R[k]) - this.xScale(R[b])
          ).style(
            "fill",
            _ && _.scale[R[G]] ? _.scale[R[G]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            _ && _.scale[R[G]] ? _.scale[R[G]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(E, l, c);
      const x = I.appendOrSelect(e, this.brushSelector).call(this.brush);
      if (E !== void 0) if (E[0].valueOf() === E[1].valueOf())
        x.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
      else {
        const b = E.map((k) => this.xScale(k));
        b[1] - b[0] < this.MIN_SELECTION_DIFF || (x.call(this.brush.move, b), this.updateBrushHandle(this.getComponentContainer(), b));
      }
      s && (this.brush.filter(() => !1), x.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(t, e, n) {
    const s = (o) => {
      const c = o.selection;
      c === null ? this.handleBrushedEvent(o, t, this.xScale, this.xScale.range()) : c[0] === c[1] || this.handleBrushedEvent(o, t, this.xScale, c);
    }, a = O(this.getOptions(), "zoomBar", J.TOP, "type"), r = jt.height[a];
    this.brush.extent([
      [e, 0],
      [n, r]
    ]).on("start brush end", null).on("start brush end", s);
  }
  // brush event listener
  handleBrushedEvent(t, e, n, s) {
    const a = [n.invert(s[0]), n.invert(s[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), s), t.sourceEvent != null && (t.sourceEvent.type === "mousemove" || t.sourceEvent.type === "mouseup" || t.sourceEvent.type === "mousedown" || t.sourceEvent.type === "touchstart" || t.sourceEvent.type === "touchmove" || t.sourceEvent.type === "touchend")) {
      (e === void 0 || e[0] !== a[0] || e[1] !== a[1]) && this.services.zoom.handleDomainChange(a, {
        dispatchEvent: !1
      });
      let r;
      t.type === "start" ? r = T.ZoomBar.SELECTION_START : t.type === "brush" ? r = T.ZoomBar.SELECTION_IN_PROGRESS : t.type === "end" && (r = T.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(T.ZoomDomain.CHANGE, {
        newDomain: a
      })), this.services.events.dispatchEvent(r, {
        selection: s,
        newDomain: a
      });
    }
  }
  updateBrushHandle(t, e) {
    const n = this, s = jt.handleWidth, a = O(this.getOptions(), "zoomBar", J.TOP, "type"), r = jt.height[a], o = -s / 2, c = jt.handleBarWidth, l = a === Ue.GRAPH_VIEW ? jt.handleBarHeight : 6, h = -c / 2, d = (r - l) / 2;
    t.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(p) {
      if (p.type === "w")
        return Math.max(e[0] + o, n.maxSelectionRange[0]);
      if (p.type === "e")
        return Math.min(e[1] + o, n.maxSelectionRange[1] - s);
    }).attr("y", 0).attr("width", s).attr("height", r).attr("cursor", "ew-resize").style("display", null);
    const u = t.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    u.enter().append("rect").attr("class", function(p) {
      return "handle-bar handle-bar--" + p.type;
    }), u.attr("x", function(p) {
      if (p.type === "w")
        return Math.max(
          e[0] + h,
          n.maxSelectionRange[0] - o + h
        );
      if (p.type === "e")
        return Math.min(
          e[1] + h,
          n.maxSelectionRange[1] + o + h
        );
    }).attr("y", d).attr("width", c).attr("height", l).attr("cursor", "ew-resize"), a === Ue.SLIDER_VIEW && this.updateSliderSelectedArea(e), this.updateClipPath(
      t,
      this.clipId,
      e[0],
      0,
      e[1] - e[0],
      r
    );
  }
  updateSliderSelectedArea(t) {
    const e = O(this.getOptions(), "zoomBar", J.TOP, "type"), n = jt.height[e], a = this.getComponentContainer().select("svg.zoom-container");
    I.appendOrSelect(a, "rect.zoom-slider-selected-area").attr("x", t[0]).attr("y", n / 2 - 1).attr("width", t[1] - t[0]).attr("height", 2);
  }
  renderZoomBarArea(t, e, n, s) {
    const { cartesianScales: a } = this.services, r = a.getMainXAxisPosition(), o = a.getMainYAxisPosition(), c = a.getMainXScaleType(), l = a.getMainYScaleType(), h = (v, S, y) => (E) => a.getValueFromScale(v, S, y, E), d = h(this.xScale, c, r), u = h(this.yScale, l, o), p = O(this.getOptions(), "zoomBar", J.TOP, "type"), f = jt.height[p], g = Ki().x((v) => d(v)).y0(f).y1((v) => f - u(v)), m = I.appendOrSelect(t, e).datum(n).attr("d", g);
    s && m.attr("clip-path", `url(#${s})`);
  }
  updateClipPath(t, e, n, s, a, r) {
    const o = I.appendOrSelect(t, "clipPath").attr("id", e);
    I.appendOrSelect(o, "rect").attr("x", n).attr("y", s).attr("width", a).attr("height", r);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(t, e) {
    if (!t || t.length < 2)
      return;
    const n = dl(t), s = this.services.cartesianScales.getDomainIdentifier(), a = this.services.cartesianScales.getRangeIdentifier();
    if (Number(e[0]) < Number(n[0][s])) {
      const r = {};
      r[s] = e[0], r[a] = 0, n.unshift(r);
    }
    if (Number(e[1]) > Number(n[n.length - 1][s])) {
      const r = {};
      r[s] = e[1], r[a] = 0, n.push(r);
    }
    return n;
  }
  renderZoomBarBaseline(t, e, n, s = !1) {
    const a = O(
      this.model.getOptions(),
      "zoomBar",
      J.TOP,
      "type"
    ), r = jt.height[a], o = Nn()([
      [e, r],
      [n, r]
    ]);
    I.appendOrSelect(t, "path.zoom-bg-baseline").attr("d", o).classed("zoom-bg-baseline-skeleton", s).style(
      "stroke",
      s ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(t, e, n) {
    this.renderZoomBarArea(t, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(t, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), I.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), O(this.getOptions(), "zoomBar", J.TOP, "type") === Ue.GRAPH_VIEW && this.renderZoomBarBaseline(t, e, n, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(T.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class hm extends dt {
  constructor(t, e) {
    super(t, e), this.type = "threshold", this.renderType = at.SVG, this.positionService = new Cs();
  }
  render(t = !1) {
    const e = O(this.getOptions(), "axes"), n = [];
    Object.keys(e).forEach((u) => {
      if (Object.values(J).includes(u)) {
        const p = e[u];
        p.thresholds && p.thresholds.length > 0 && n.push({
          axisPosition: u,
          thresholds: p.thresholds,
          correspondingDatasets: p == null ? void 0 : p.correspondingDatasets,
          mapsTo: p == null ? void 0 : p.mapsTo
        });
      }
    });
    const a = this.getComponentContainer({
      ariaLabel: "threshold lines",
      withinChartClip: !0
    }).selectAll("g.axis-thresholds").data(n, (u) => u.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g").merge(a);
    o.attr("class", (u) => `axis-thresholds ${u.axisPosition}`);
    const c = o.selectAll("g.threshold-group").data(
      (u) => u.thresholds.map((p) => (p.axisPosition = u.axisPosition, p.datum = this.constructDatumObj(u, p), p))
    );
    c.exit().attr("opacity", 0).remove();
    const l = c.enter().append("g");
    l.append("line").attr("class", "threshold-line"), l.append("rect").attr("class", "threshold-hoverable-area"), l.merge(c).attr("class", "threshold-group");
    const d = this;
    o.each(function({ axisPosition: u }) {
      const p = d.services.cartesianScales.getScaleByPosition(
        u
      ), f = d.services.cartesianScales.getScaleTypeByPosition(u);
      let g = null, m = null;
      u === J.LEFT || u === J.RIGHT ? (m = p, g = d.services.cartesianScales.getMainXScale()) : (g = p, m = d.services.cartesianScales.getMainYScale());
      const v = f === kt.LABELS, [S, y] = g.range(), [E, x] = m.range(), { cartesianScales: b } = d.services, k = b.getOrientation(), _ = (N) => b.getDomainValue(N), G = (N) => b.getRangeValue(N), [R, A] = xe(
        _,
        G,
        k
      ), H = D(this);
      u === J.TOP || u === J.BOTTOM ? (H.selectAll("line.threshold-line").transition().call(
        (N) => d.services.transitions.setupTransition({
          transition: N,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("y1", x).attr("y2", E).attr(
        "x1",
        ({ datum: N }) => R(N) + (v ? p.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: N }) => R(N) + (v ? p.step() / 2 : 0)
      ).style("stroke", ({ fillColor: N }) => N), H.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: N }) => -R(N)).attr("width", Math.abs(E - x)).classed("rotate", !0)) : (H.selectAll("line.threshold-line").transition().call(
        (N) => d.services.transitions.setupTransition({
          transition: N,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("x1", S).attr("x2", y).attr(
        "y1",
        ({ datum: N }) => A(N) + (v ? p.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: N }) => A(N) + (v ? p.step() / 2 : 0)
      ).style("stroke", ({ fillColor: N }) => N), H.selectAll("rect.threshold-hoverable-area").attr("x", S).attr("y", ({ datum: N }) => A(N)).attr("width", Math.abs(y - S)).classed("rotate", !1));
    }), this.services.events.addEventListener(T.Threshold.SHOW, (u) => {
      this.setThresholdLabelPosition(u.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(T.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(t) {
    const { value: e, axisPosition: n } = t, s = this.getOptions(), a = this.services.cartesianScales.getScaleTypeByPosition(n), { code: r, number: o } = O(s, "locale");
    if (a === kt.TIME) {
      const c = [J.LEFT, J.RIGHT].includes(n), l = this.services.cartesianScales.getMainXScale(), h = this.services.cartesianScales.getMainYScale(), d = c ? h : l, u = O(s, "timeScale"), p = hi(
        d.ticks(),
        O(u, "timeInterval")
      );
      return di(e, 0, d.ticks(), p, u, s.locale);
    }
    return o(e, r);
  }
  appendThresholdLabel() {
    const t = D(this.services.domUtils.getHolder()), e = O(this.getOptions(), "style", "prefix");
    this.label = I.appendOrSelect(
      t,
      `div.${Kt}--${e}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: t, datum: e }) {
    const n = this.services.domUtils.getHolder(), s = sn(t, n), a = e.valueFormatter ? e.valueFormatter(e.value) : this.getFormattedValue(e);
    this.label.html(ue(`${e.label || "Threshold"}: ${a}`)).style("background-color", e.fillColor);
    const r = this.label.node(), o = this.positionService.findBestPlacementAt(
      {
        left: s[0],
        top: s[1]
      },
      r,
      [Lt.RIGHT, Lt.LEFT, Lt.TOP, Lt.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: n.offsetWidth,
        height: n.offsetHeight
      })
    ), c = this.positionService.findPositionAt(
      {
        left: s[0],
        top: s[1]
      },
      r,
      o
    );
    this.positionService.setElement(r, c);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(t, e) {
    const n = {};
    return t.correspondingDatasets && (n.group = O(t, "correspondingDatasets", 0)), n[t.mapsTo] = e.value, n;
  }
  addEventListeners() {
    const t = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {
      D(this.parentNode).select("line.threshold-line").classed("active", !0), t.services.events.dispatchEvent(T.Threshold.SHOW, {
        event: n,
        hoveredElement: D(this),
        datum: D(this).datum()
      });
    }).on("mouseout", function(n) {
      D(this.parentNode).select("line.threshold-line").classed("active", !1), t.services.events.dispatchEvent(T.Threshold.HIDE, {
        event: n,
        hoveredElement: D(this),
        datum: D(this).datum()
      });
    });
  }
}
class dm extends dt {
  constructor(t, e) {
    super(t, e), this.type = "highlight", this.renderType = at.SVG, this.positionService = new Cs(), this.highlightStrokeWidth = 1;
  }
  render(t = !1) {
    const e = O(this.getOptions(), "axes"), n = [];
    Object.keys(e).forEach((u) => {
      if (Object.values(J).includes(u)) {
        const p = e[u];
        p.highlights && p.highlights.data.length > 0 && n.push({
          axisPosition: u,
          highlightStartMapsTo: p.highlights.highlightStartMapsTo,
          highlightEndMapsTo: p.highlights.highlightEndMapsTo,
          labelMapsTo: p.highlights.labelMapsTo,
          highlight: p.highlights.data,
          color: p.highlights.color
        });
      }
    });
    const a = this.getComponentContainer({
      ariaLabel: "highlight areas",
      withinChartClip: !0
    }).selectAll("g.axis-highlight").data(n, (u) => u.axisPosition);
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g").merge(a);
    o.attr("class", (u) => `axis-highlight ${u.axisPosition}`);
    const c = o.selectAll("g.highlight-group").data(
      (u) => u.highlight.map((p) => (p.axisPosition = u.axisPosition, p.highlightStartMapsTo = u.highlightStartMapsTo, p.labelMapsTo = u.labelMapsTo, p.color = u.color, p.highlightEndMapsTo = u.highlightEndMapsTo, p))
    );
    c.exit().attr("opacity", 0).remove();
    const l = c.enter().append("g");
    l.append("rect").attr("class", "highlight-bar"), l.append("line").attr("class", "highlight-line"), l.merge(c).attr("class", "highlight-group");
    const d = this;
    o.each(function({ axisPosition: u }) {
      const p = d.services.cartesianScales.getMainXScale(), f = d.services.cartesianScales.getMainYScale(), [g, m] = p.range(), [v, S] = f.range(), { cartesianScales: y } = d.services, E = y.getOrientation(), x = (R) => y.getDomainValue(R), b = (R) => y.getRangeValue(R), [k, _] = xe(
        x,
        b,
        E
      ), G = D(this);
      u === J.TOP || u === J.BOTTOM ? G.selectAll("rect.highlight-bar").transition().call(
        (R) => d.services.transitions.setupTransition({
          transition: R,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("y", Math.max(S + d.highlightStrokeWidth, 0)).attr("height", Math.max(v - 2 * d.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: R, ...A }) => k(A[R])).attr(
        "width",
        ({ highlightStartMapsTo: R, highlightEndMapsTo: A, ...H }) => Math.max(k(H[A]) - k(H[R]), 0)
      ).style("stroke", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", d.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null) : G.selectAll("rect.highlight-bar").transition().call(
        (R) => d.services.transitions.setupTransition({
          transition: R,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("x", g).attr("width", Math.max(m - g, 0)).attr("y", ({ highlightEndMapsTo: R, ...A }) => _(A[R])).attr(
        "height",
        ({ highlightStartMapsTo: R, highlightEndMapsTo: A, ...H }) => Math.max(_(H[R]) - _(H[A]), 0)
      ).style("stroke", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", d.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: R, labelMapsTo: A, ...H }) => R && R.scale[H[A]] ? R.scale[H[A]] : null);
    });
  }
}
class pm extends Pd {
  getItems(t) {
    if (t.detail.items)
      return t.detail.items;
    const { data: e } = t.detail;
    if (!e || !e.length || !e[0])
      return [];
    const n = this.getOptions(), { cartesianScales: s } = this.services, a = s.getDomainIdentifier(), r = s.isDualAxes(), { groupMapsTo: o } = n.data, c = s.getDomainLabel();
    let l = s.getRangeLabel();
    const h = e[0][a];
    let d;
    if (e.length === 1) {
      const u = e[0], p = s.getRangeIdentifier(u);
      if (r) {
        const g = s.getRangeAxisPosition({
          datum: u,
          groups: [u[o]]
        });
        l = s.getScaleLabel(g);
      }
      const f = u[p];
      d = [
        {
          label: c,
          value: h
        },
        ...Array.isArray(f) && f.length === 2 ? [
          {
            label: "Start",
            value: f[0]
          },
          {
            label: "End",
            value: f[1]
          }
        ] : [
          {
            label: l,
            value: u[p]
          }
        ]
      ], t.detail.additionalItems && t.detail.additionalItems.forEach(
        (g) => d.push({
          label: g.label,
          value: g.value
        })
      ), d.push({
        label: xt(n, "locale.translations.group") || xt(n, "tooltip.groupLabel"),
        value: u[o],
        color: this.model.getFillColor(u[o]),
        class: this.model.getColorClassName({
          classNameTypes: [nt.TOOLTIP],
          dataGroupName: u[o]
        })
      });
    } else if (e.length > 1 && (d = [
      {
        label: c,
        value: h
      }
    ], d = d.concat(
      e.map((u) => {
        const p = u[s.getRangeIdentifier(u)];
        return {
          label: u[o],
          value: Array.isArray(p) && p.length === 2 ? `${p[0]} - ${p[1]}` : p,
          color: this.model.getFillColor(u[o]),
          class: this.model.getColorClassName({
            classNameTypes: [nt.TOOLTIP],
            dataGroupName: u[o]
          })
        };
      }).sort((u, p) => p.value - u.value)
    ), !r && O(n, "tooltip", "showTotal") === !0)) {
      const u = s.getRangeIdentifier();
      d.push({
        label: xt(n, "locale.translations.total") || xt(n, "tooltip.totalLabel") || "Total",
        value: e.reduce(
          (p, f) => p + f[u],
          0
        ),
        bold: !0
      });
    }
    return d;
  }
}
function Mr(i, t) {
  let e;
  if (t === void 0)
    for (const n of i)
      n != null && (e < n || e === void 0 && n >= n) && (e = n);
  else {
    let n = -1;
    for (let s of i)
      (s = t(s, ++n, i)) != null && (e < s || e === void 0 && s >= s) && (e = s);
  }
  return e;
}
function $d(i, t) {
  let e;
  if (t === void 0)
    for (const n of i)
      n != null && (e > n || e === void 0 && n >= n) && (e = n);
  else {
    let n = -1;
    for (let s of i)
      (s = t(s, ++n, i)) != null && (e > s || e === void 0 && s >= s) && (e = s);
  }
  return e;
}
function li(i, t) {
  let e = 0;
  if (t === void 0)
    for (let n of i)
      (n = +n) && (e += n);
  else {
    let n = -1;
    for (let s of i)
      (s = +t(s, ++n, i)) && (e += s);
  }
  return e;
}
function Vd(i) {
  return i.depth;
}
function Gd(i, t) {
  return t - 1 - i.height;
}
function Yo(i, t) {
  return i.sourceLinks.length ? i.depth : t - 1;
}
function es(i) {
  return function() {
    return i;
  };
}
function wr(i, t) {
  return Ss(i.source, t.source) || i.index - t.index;
}
function Cr(i, t) {
  return Ss(i.target, t.target) || i.index - t.index;
}
function Ss(i, t) {
  return i.y0 - t.y0;
}
function ci(i) {
  return i.value;
}
function Hd(i) {
  return i.index;
}
function Bd(i) {
  return i.nodes;
}
function zd(i) {
  return i.links;
}
function kr(i, t) {
  const e = i.get(t);
  if (!e) throw new Error("missing: " + t);
  return e;
}
function _r({ nodes: i }) {
  for (const t of i) {
    let e = t.y0, n = e;
    for (const s of t.sourceLinks)
      s.y0 = e + s.width / 2, e += s.width;
    for (const s of t.targetLinks)
      s.y1 = n + s.width / 2, n += s.width;
  }
}
function Ud() {
  let i = 0, t = 0, e = 1, n = 1, s = 24, a = 8, r, o = Hd, c = Yo, l, h, d = Bd, u = zd, p = 6;
  function f() {
    const L = { nodes: d.apply(null, arguments), links: u.apply(null, arguments) };
    return g(L), m(L), v(L), S(L), x(L), _r(L), L;
  }
  f.update = function(L) {
    return _r(L), L;
  }, f.nodeId = function(L) {
    return arguments.length ? (o = typeof L == "function" ? L : es(L), f) : o;
  }, f.nodeAlign = function(L) {
    return arguments.length ? (c = typeof L == "function" ? L : es(L), f) : c;
  }, f.nodeSort = function(L) {
    return arguments.length ? (l = L, f) : l;
  }, f.nodeWidth = function(L) {
    return arguments.length ? (s = +L, f) : s;
  }, f.nodePadding = function(L) {
    return arguments.length ? (a = r = +L, f) : a;
  }, f.nodes = function(L) {
    return arguments.length ? (d = typeof L == "function" ? L : es(L), f) : d;
  }, f.links = function(L) {
    return arguments.length ? (u = typeof L == "function" ? L : es(L), f) : u;
  }, f.linkSort = function(L) {
    return arguments.length ? (h = L, f) : h;
  }, f.size = function(L) {
    return arguments.length ? (i = t = 0, e = +L[0], n = +L[1], f) : [e - i, n - t];
  }, f.extent = function(L) {
    return arguments.length ? (i = +L[0][0], e = +L[1][0], t = +L[0][1], n = +L[1][1], f) : [[i, t], [e, n]];
  }, f.iterations = function(L) {
    return arguments.length ? (p = +L, f) : p;
  };
  function g({ nodes: L, links: P }) {
    for (const [C, V] of L.entries())
      V.index = C, V.sourceLinks = [], V.targetLinks = [];
    const $ = new Map(L.map((C, V) => [o(C, V, L), C]));
    for (const [C, V] of P.entries()) {
      V.index = C;
      let { source: q, target: X } = V;
      typeof q != "object" && (q = V.source = kr($, q)), typeof X != "object" && (X = V.target = kr($, X)), q.sourceLinks.push(V), X.targetLinks.push(V);
    }
    if (h != null)
      for (const { sourceLinks: C, targetLinks: V } of L)
        C.sort(h), V.sort(h);
  }
  function m({ nodes: L }) {
    for (const P of L)
      P.value = P.fixedValue === void 0 ? Math.max(li(P.sourceLinks, ci), li(P.targetLinks, ci)) : P.fixedValue;
  }
  function v({ nodes: L }) {
    const P = L.length;
    let $ = new Set(L), C = /* @__PURE__ */ new Set(), V = 0;
    for (; $.size; ) {
      for (const q of $) {
        q.depth = V;
        for (const { target: X } of q.sourceLinks)
          C.add(X);
      }
      if (++V > P) throw new Error("circular link");
      $ = C, C = /* @__PURE__ */ new Set();
    }
  }
  function S({ nodes: L }) {
    const P = L.length;
    let $ = new Set(L), C = /* @__PURE__ */ new Set(), V = 0;
    for (; $.size; ) {
      for (const q of $) {
        q.height = V;
        for (const { source: X } of q.targetLinks)
          C.add(X);
      }
      if (++V > P) throw new Error("circular link");
      $ = C, C = /* @__PURE__ */ new Set();
    }
  }
  function y({ nodes: L }) {
    const P = Mr(L, (V) => V.depth) + 1, $ = (e - i - s) / (P - 1), C = new Array(P);
    for (const V of L) {
      const q = Math.max(0, Math.min(P - 1, Math.floor(c.call(null, V, P))));
      V.layer = q, V.x0 = i + q * $, V.x1 = V.x0 + s, C[q] ? C[q].push(V) : C[q] = [V];
    }
    if (l) for (const V of C)
      V.sort(l);
    return C;
  }
  function E(L) {
    const P = $d(L, ($) => (n - t - ($.length - 1) * r) / li($, ci));
    for (const $ of L) {
      let C = t;
      for (const V of $) {
        V.y0 = C, V.y1 = C + V.value * P, C = V.y1 + r;
        for (const q of V.sourceLinks)
          q.width = q.value * P;
      }
      C = (n - C + r) / ($.length + 1);
      for (let V = 0; V < $.length; ++V) {
        const q = $[V];
        q.y0 += C * (V + 1), q.y1 += C * (V + 1);
      }
      H($);
    }
  }
  function x(L) {
    const P = y(L);
    r = Math.min(a, (n - t) / (Mr(P, ($) => $.length) - 1)), E(P);
    for (let $ = 0; $ < p; ++$) {
      const C = Math.pow(0.99, $), V = Math.max(1 - C, ($ + 1) / p);
      k(P, C, V), b(P, C, V);
    }
  }
  function b(L, P, $) {
    for (let C = 1, V = L.length; C < V; ++C) {
      const q = L[C];
      for (const X of q) {
        let F = 0, Z = 0;
        for (const { source: j, value: Y } of X.targetLinks) {
          let K = Y * (X.layer - j.layer);
          F += N(j, X) * K, Z += K;
        }
        if (!(Z > 0)) continue;
        let rt = (F / Z - X.y0) * P;
        X.y0 += rt, X.y1 += rt, A(X);
      }
      l === void 0 && q.sort(Ss), _(q, $);
    }
  }
  function k(L, P, $) {
    for (let C = L.length, V = C - 2; V >= 0; --V) {
      const q = L[V];
      for (const X of q) {
        let F = 0, Z = 0;
        for (const { target: j, value: Y } of X.sourceLinks) {
          let K = Y * (j.layer - X.layer);
          F += M(X, j) * K, Z += K;
        }
        if (!(Z > 0)) continue;
        let rt = (F / Z - X.y0) * P;
        X.y0 += rt, X.y1 += rt, A(X);
      }
      l === void 0 && q.sort(Ss), _(q, $);
    }
  }
  function _(L, P) {
    const $ = L.length >> 1, C = L[$];
    R(L, C.y0 - r, $ - 1, P), G(L, C.y1 + r, $ + 1, P), R(L, n, L.length - 1, P), G(L, t, 0, P);
  }
  function G(L, P, $, C) {
    for (; $ < L.length; ++$) {
      const V = L[$], q = (P - V.y0) * C;
      q > 1e-6 && (V.y0 += q, V.y1 += q), P = V.y1 + r;
    }
  }
  function R(L, P, $, C) {
    for (; $ >= 0; --$) {
      const V = L[$], q = (V.y1 - P) * C;
      q > 1e-6 && (V.y0 -= q, V.y1 -= q), P = V.y0 - r;
    }
  }
  function A({ sourceLinks: L, targetLinks: P }) {
    if (h === void 0) {
      for (const { source: { sourceLinks: $ } } of P)
        $.sort(Cr);
      for (const { target: { targetLinks: $ } } of L)
        $.sort(wr);
    }
  }
  function H(L) {
    if (h === void 0)
      for (const { sourceLinks: P, targetLinks: $ } of L)
        P.sort(Cr), $.sort(wr);
  }
  function N(L, P) {
    let $ = L.y0 - (L.sourceLinks.length - 1) * r / 2;
    for (const { target: C, width: V } of L.sourceLinks) {
      if (C === P) break;
      $ += V + r;
    }
    for (const { source: C, width: V } of P.targetLinks) {
      if (C === L) break;
      $ -= V;
    }
    return $;
  }
  function M(L, P) {
    let $ = P.y0 - (P.targetLinks.length - 1) * r / 2;
    for (const { source: C, width: V } of P.targetLinks) {
      if (C === L) break;
      $ += V + r;
    }
    for (const { target: C, width: V } of L.sourceLinks) {
      if (C === P) break;
      $ -= V;
    }
    return $;
  }
  return f;
}
var Vi = Math.PI, Gi = 2 * Vi, _e = 1e-6, Fd = Gi - _e;
function Hi() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function Zo() {
  return new Hi();
}
Hi.prototype = Zo.prototype = {
  constructor: Hi,
  moveTo: function(i, t) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(i, t) {
    this._ += "L" + (this._x1 = +i) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(i, t, e, n) {
    this._ += "Q" + +i + "," + +t + "," + (this._x1 = +e) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(i, t, e, n, s, a) {
    this._ += "C" + +i + "," + +t + "," + +e + "," + +n + "," + (this._x1 = +s) + "," + (this._y1 = +a);
  },
  arcTo: function(i, t, e, n, s) {
    i = +i, t = +t, e = +e, n = +n, s = +s;
    var a = this._x1, r = this._y1, o = e - i, c = n - t, l = a - i, h = r - t, d = l * l + h * h;
    if (s < 0) throw new Error("negative radius: " + s);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = i) + "," + (this._y1 = t);
    else if (d > _e) if (!(Math.abs(h * o - c * l) > _e) || !s)
      this._ += "L" + (this._x1 = i) + "," + (this._y1 = t);
    else {
      var u = e - a, p = n - r, f = o * o + c * c, g = u * u + p * p, m = Math.sqrt(f), v = Math.sqrt(d), S = s * Math.tan((Vi - Math.acos((f + d - g) / (2 * m * v))) / 2), y = S / v, E = S / m;
      Math.abs(y - 1) > _e && (this._ += "L" + (i + y * l) + "," + (t + y * h)), this._ += "A" + s + "," + s + ",0,0," + +(h * u > l * p) + "," + (this._x1 = i + E * o) + "," + (this._y1 = t + E * c);
    }
  },
  arc: function(i, t, e, n, s, a) {
    i = +i, t = +t, e = +e, a = !!a;
    var r = e * Math.cos(n), o = e * Math.sin(n), c = i + r, l = t + o, h = 1 ^ a, d = a ? n - s : s - n;
    if (e < 0) throw new Error("negative radius: " + e);
    this._x1 === null ? this._ += "M" + c + "," + l : (Math.abs(this._x1 - c) > _e || Math.abs(this._y1 - l) > _e) && (this._ += "L" + c + "," + l), e && (d < 0 && (d = d % Gi + Gi), d > Fd ? this._ += "A" + e + "," + e + ",0,1," + h + "," + (i - r) + "," + (t - o) + "A" + e + "," + e + ",0,1," + h + "," + (this._x1 = c) + "," + (this._y1 = l) : d > _e && (this._ += "A" + e + "," + e + ",0," + +(d >= Vi) + "," + h + "," + (this._x1 = i + e * Math.cos(s)) + "," + (this._y1 = t + e * Math.sin(s))));
  },
  rect: function(i, t, e, n) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +t) + "h" + +e + "v" + +n + "h" + -e + "Z";
  },
  toString: function() {
    return this._;
  }
};
function Ir(i) {
  return function() {
    return i;
  };
}
function Wd(i) {
  return i[0];
}
function Xd(i) {
  return i[1];
}
var Yd = Array.prototype.slice;
function Zd(i) {
  return i.source;
}
function qd(i) {
  return i.target;
}
function jd(i) {
  var t = Zd, e = qd, n = Wd, s = Xd, a = null;
  function r() {
    var o, c = Yd.call(arguments), l = t.apply(this, c), h = e.apply(this, c);
    if (a || (a = o = Zo()), i(a, +n.apply(this, (c[0] = l, c)), +s.apply(this, c), +n.apply(this, (c[0] = h, c)), +s.apply(this, c)), o) return a = null, o + "" || null;
  }
  return r.source = function(o) {
    return arguments.length ? (t = o, r) : t;
  }, r.target = function(o) {
    return arguments.length ? (e = o, r) : e;
  }, r.x = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : Ir(+o), r) : n;
  }, r.y = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : Ir(+o), r) : s;
  }, r.context = function(o) {
    return arguments.length ? (a = o ?? null, r) : a;
  }, r;
}
function Kd(i, t, e, n, s) {
  i.moveTo(t, e), i.bezierCurveTo(t = (t + n) / 2, e, t, s, n, s);
}
function Jd() {
  return jd(Kd);
}
function Qd(i) {
  return [i.source.x1, i.y0];
}
function tp(i) {
  return [i.target.x0, i.y1];
}
function ep() {
  return Jd().source(Qd).target(tp);
}
class fm extends dt {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = at.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({ ariaLabel: "alluvial graphs", withinChartClip: !0 });
    e.html("");
    const { width: n, height: s } = I.getSVGElementSize(e, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    const a = this.model.getOptions(), r = this.model.getDisplayData(), o = O(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let c = se.minNodePadding;
    a.alluvial.nodePadding > se.minNodePadding && (c = a.alluvial.nodePadding);
    const l = O(a, "alluvial", "nodeAlignment");
    let h = Yo;
    l === te.LEFT ? h = Vd : l === te.RIGHT && (h = Gd);
    const d = Ud().nodeId((y) => y.name).nodeWidth(se.nodeWidth).nodePadding(c).nodeAlign(h).extent([
      [2, 30],
      [n - 2, s]
    ]);
    this.graph = d({
      nodes: a.alluvial.nodes.map((y) => Object.assign({}, y)),
      links: r.map((y) => Object.assign({}, y))
    }), this.graph.nodes = this.graph.nodes.filter((y) => y.value !== 0);
    const u = {};
    this.graph.nodes.forEach((y) => {
      const E = y.x0;
      y.category && (u[E] = y == null ? void 0 : y.category);
    }), e.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(u)).join("g").attr("transform", (y) => `translate(${y}, 0)`).append("text").attr(
      "id",
      (y, E) => this.services.domUtils.generateElementIDString(`alluvial-category-${E}`)
    ).style("font-size", "14px").text((y) => u[y] ? u[y] : "").attr("y", 20).attr("x", (y, E) => {
      const x = this.services.domUtils.generateElementIDString(
        `alluvial-category-${E}`
      ), { width: b } = I.getSVGElementSize(D(`text#${x}`), {
        useBBox: !0
      });
      let k = 0;
      return y + k >= b && (k = -b + 4), k;
    });
    const f = e.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (f.exit().remove(), o) {
      const y = O(this.getOptions(), "color", "scale");
      y && f.enter().append("linearGradient").attr("id", (E) => `${this.gradient_id}-link-${E.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (E) => E.append("stop").attr("offset", "0%").attr("stop-color", (x) => y[x.source.name])
      ).call(
        (E) => E.append("stop").attr("offset", "100%").attr("stop-color", (x) => y[x.target.name])
      ), f.exit().remove();
    }
    f.enter().append("path").classed("link", !0).attr("d", ep()).attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-line-${y.index}`)
    ).attr("class", (y) => a.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [nt.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [nt.STROKE],
      dataGroupName: y.source.index,
      originalClassName: "link"
    })).style("stroke", (y) => o ? `url(#${this.gradient_id}-link-${y.index})` : this.model.getFillColor(y.source.name, null, {
      ...y,
      source: y.source.name,
      target: y.target.name
    })).attr("stroke-width", (y) => Math.max(1, y.width)).style("stroke-opacity", se.opacity.default).attr(
      "aria-label",
      (y) => `${y.source.name} → ${y.target.name} (${y.value}${a.alluvial.units ? " " + a.alluvial.units : ""})`
    );
    const g = e.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-${y.index}`)
    ).classed("node-group", !0).attr("transform", (y) => `translate(${y.x0}, ${y.y0})`);
    g.append("rect").classed("node", !0).attr("height", (y) => y.y1 - y.y0).attr("width", (y) => y.x1 - y.x0).attr("fill", "black");
    const m = g.append("g").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${y.index}`)
    ), { code: v, number: S } = O(a, "locale");
    m.append("text").attr(
      "id",
      (y) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${y.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((y) => `${y.name} (${S(y.value, v)})`).attr("aria-label", (y) => `${y.name} (${y.value})`), m.append("rect").classed("node-text-bg", !0).attr("width", (y, E) => {
      const x = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${E}`
      ), { width: b } = I.getSVGElementSize(D(`text#${x}`), {
        useBBox: !0
      });
      return b + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), m.attr("transform", (y, E) => {
      const x = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${E}`
      ), { width: b } = I.getSVGElementSize(D(`text#${x}`), {
        useBBox: !0
      }), k = (y.y1 - y.y0) / 2 - 9;
      let _ = y.x1 - y.x0;
      return y.x1 >= b ? _ = _ - (b + 16) : _ += 4, `translate(${_}, ${k})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const t = this.getOptions(), e = this, { number: n, code: s } = O(this.getOptions(), "locale"), a = fi((r, o = "mouseover") => {
      const c = e.parent.selectAll("path.link").transition().call(
        (l) => e.services.transitions.setupTransition({
          transition: l,
          name: "alluvial-links-mouse-highlight"
        })
      );
      o === "mouseout" ? (D(r).lower(), c.style("stroke-opacity", se.opacity.default)) : c.style("stroke-opacity", function() {
        return r === this ? (D(this).raise(), se.opacity.selected) : se.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(r, o) {
      const c = D(this);
      a(this, "mouseover"), c.classed("link-hovered", !0);
      const l = getComputedStyle(this).getPropertyValue("stroke");
      e.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEOVER, {
        event: r,
        element: c,
        datum: o
      }), e.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: r,
        hoveredElement: c,
        items: [
          {
            label: o.target.name,
            value: (n(o.value, s) ? `${n(o.value, s)}` : "-") + (t.alluvial.units ? ` ${t.alluvial.units}` : ""),
            color: l,
            labelIcon: e.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(r, o) {
      e.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEMOVE, {
        event: r,
        element: D(this),
        datum: o
      }), e.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, o) {
      e.services.events.dispatchEvent(T.Alluvial.LINE_CLICK, {
        event: r,
        element: D(this),
        datum: o
      });
    }).on("mouseout", function(r, o) {
      const c = D(this);
      a(this, "mouseout"), c.classed("link-hovered", !1), e.services.events.dispatchEvent(T.Alluvial.LINE_MOUSEOUT, {
        event: r,
        element: c,
        datum: o
      }), e.services.events.dispatchEvent(T.Tooltip.HIDE, {
        event: r,
        hoveredElement: c
      });
    });
  }
  addNodeEventListener() {
    const t = this, e = fi((n = [], s = "mouseover") => {
      if (s === "mouseout" || n.length === 0) {
        t.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (r) => r.index).order().style("stroke-opacity", se.opacity.default);
        return;
      }
      t.parent.selectAll("path.link").transition().call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(r) {
        return n.some((o) => o === r.index) ? (D(this).classed("link-hovered", !0).raise(), se.opacity.selected) : se.opacity.unfocus;
      });
    }, 66);
    t.parent.selectAll(".node-group").on("mouseover", function(n, s) {
      const a = D(this), r = [];
      if (t.traverse({ link: "sourceLinks", node: "target" }, s, r), t.traverse({ link: "targetLinks", node: "source" }, s, r), r.length) {
        const o = yn(a.attr("transform"));
        if (a.attr("transform", `translate(${o.x - 2}, ${o.y})`), a.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), s.x0 - 2 === 0) {
          const l = t.services.domUtils.generateElementIDString(
            `alluvial-node-title-${s.index}`
          ), h = t.parent.select(`g#${l}`), d = yn(h.attr("transform"));
          h.attr("transform", `translate(${d.x + 4},${d.y})`);
        }
        const c = t.services.domUtils.generateElementIDString(
          `alluvial-node-text-${s.index}`
        );
        t.parent.select(`text#${c}`).style("font-weight", "bold"), e(r, "mouseover"), t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEOVER, {
          event: n,
          element: a,
          datum: s
        });
      }
    }).on("mousemove", function(n, s) {
      t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEMOVE, {
        event: n,
        element: D(this),
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      t.services.events.dispatchEvent(T.Alluvial.NODE_CLICK, {
        event: n,
        element: D(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      const a = D(this), r = yn(a.attr("transform"));
      if (a.classed("node-hovered", !1).attr("transform", `translate(${r.x + 2}, ${r.y})`).select("rect.node").attr("width", se.nodeWidth), s.x0 - 2 === 0) {
        const c = t.services.domUtils.generateElementIDString(
          `alluvial-node-title-${s.index}`
        ), l = t.parent.select(`g#${c}`), h = yn(l.attr("transform"));
        l.attr("transform", `translate(${h.x - 4},${h.y})`);
      }
      const o = t.services.domUtils.generateElementIDString(
        `alluvial-node-text-${s.index}`
      );
      t.parent.select(`text#${o}`).style("font-weight", "normal"), e([], "mouseout"), t.services.events.dispatchEvent(T.Alluvial.NODE_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(t, e, n = []) {
    e[t.link].map((a) => (n.push(a.index), a[t.node])).forEach((a) => this.traverse(t, a, n));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class gm extends dt {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = at.SVG;
  }
  render(t = !0) {
    const e = O(this.getOptions(), "grid", "x", "enabled"), n = O(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(e, n), !(!e && !n) && (e && (I.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(t)), n && (I.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(t)));
  }
  drawXGrid(t) {
    const e = this.parent, n = this.backdrop.attr("height"), s = this.services.cartesianScales.getMainXScale(), a = Fi(s).tickSizeInner(-n).tickSizeOuter(0);
    if (O(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const c = this.services.cartesianScales.getDomainAxisPosition(), l = O(this.getOptions(), "axes", c, "ticks", "values");
      l && a.tickValues(l);
    } else {
      const c = O(this.getOptions(), "grid", "x", "numberOfTicks");
      a.ticks(c);
    }
    const o = e.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${n})`);
    t ? o.transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "grid-update",
        animate: t
      })
    ).call(a) : o.call(a), this.cleanGrid(o);
  }
  drawYGrid(t) {
    const e = this.parent, n = this.backdrop.attr("width"), s = this.services.cartesianScales.getMainYScale(), a = ho(s).tickSizeInner(-n).tickSizeOuter(0);
    if (O(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const c = this.services.cartesianScales.getRangeAxisPosition(), l = O(this.getOptions(), "axes", c, "ticks", "values");
      l && a.tickValues(l);
    } else {
      const c = O(this.getOptions(), "grid", "y", "numberOfTicks");
      a.ticks(c);
    }
    const o = e.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    t ? o.transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "grid-update",
        animate: t
      })
    ).call(a) : o.call(a), this.cleanGrid(o);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(t) {
    const e = this.parent, n = e.selectAll(".x.grid .tick").nodes().sort((h, d) => Number(ge(h).tx) - Number(ge(d).tx));
    let s = -1;
    if (!n.length)
      return;
    n.forEach((h) => {
      t[0] >= +ge(h).tx && s++;
    });
    const a = s + 1 < n.length ? s + 1 : n.length, r = n[s], o = n[a];
    let c;
    if (!r)
      c = +ge(o).tx;
    else if (o)
      c = +ge(o).tx - +ge(r).tx;
    else {
      const h = e.select("rect.chart-grid-backdrop").node();
      c = I.getSVGElementSize(h).width - +ge(r).tx;
    }
    const { threshold: l } = this.getOptions().tooltip.gridline;
    return c * l;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(t) {
    const e = O(this.getOptions, "tooltip", "gridline", "threshold"), n = e || this.getGridlineThreshold(t);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const r = ge(this), o = {
        min: Number(r.tx) - n,
        max: Number(r.tx) + n
      };
      return o.min <= t[0] && t[0] <= o.max;
    });
  }
  drawBackdrop(t, e) {
    const n = this.parent, s = this.services.cartesianScales.getMainXScale(), a = this.services.cartesianScales.getMainYScale(), [r, o] = s.range(), [c, l] = a.range();
    this.backdrop = I.appendOrSelect(n, "svg.chart-grid-backdrop").attr(
      "role",
      "presentation"
    );
    const h = I.appendOrSelect(
      this.backdrop,
      t || e ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(h).attr("x", r).attr("y", l).attr("width", Math.abs(o - r)).attr("height", Math.abs(c - l)).lower(), h.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(t) {
    t.selectAll("text").remove(), t.select(".domain").remove();
  }
}
class mm extends dt {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = at.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-area"
        })
      ).attr("opacity", (n) => n.name !== e.datum().name ? ye.opacity.unselected : ye.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", ye.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({ ariaLabel: "area graphs", withinChartClip: !0 }), n = this.getOptions();
    let s = [0, 0];
    const { cartesianScales: a } = this.services, r = a.getOrientation(), o = Ki().curve(this.services.curves.getD3Curve()).defined((x) => {
      const b = a.getRangeIdentifier(), k = x[b];
      return k != null;
    }), c = this.model.getGroupedData(this.configs.groups), l = O(n, "bounds"), h = l && c && c.length === 1;
    !h && l && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${c.length}`
    );
    let d = 0;
    const u = (x, b) => {
      O(n, "axes", x, "includeZero") === !1 && b[0] > 0 && b[1] > 0 && (d = b[0]);
    }, p = (x) => h ? a.getBoundedScaledValues(x)[0] : a.getRangeValue(d), f = (x) => h ? a.getBoundedScaledValues(x)[1] : a.getRangeValue(x);
    r === Xt.VERTICAL ? (s = a.getMainYScale().domain(), u(a.getMainYAxisPosition(), s), o.x((x) => a.getDomainValue(x)).y0((x) => p(x)).y1((x) => f(x))) : (s = a.getMainXScale().domain(), u(a.getMainXAxisPosition(), s), o.x0((x) => p(x)).x1((x) => f(x)).y((x) => a.getDomainValue(x)));
    const g = O(n, "color", "gradient", "enabled"), m = c && c.length === 1 && g;
    c.length > 1 && g && console.error("Gradients can only be enabled when having 1 single dataset");
    const v = e.selectAll("path.area").data(c, (x) => x.name), S = D(this.services.domUtils.getMainContainer());
    if (v.exit().attr("opacity", 0).remove(), !c.length)
      return;
    if (m) {
      const x = S.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [nt.STROKE],
          dataGroupName: c[0].name
        })}`
      ).node();
      let b;
      if (x)
        b = getComputedStyle(x, null).getPropertyValue(
          "stroke"
        );
      else {
        const k = O(this.model.getOptions(), "color", "scale");
        if (k !== null) {
          const _ = Object.keys(k);
          b = k[_[0]];
        }
      }
      Ca.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${c[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: Ca.getStops(s, b)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const y = this, E = v.enter().append("path");
    m ? E.merge(v).style(
      "fill",
      (x) => `url(#${this.services.domUtils.generateElementIDString(
        `${x.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: x.name,
        originalClassName: "area"
      })
    ).attr("d", (x) => {
      const { data: b } = x;
      return o(b);
    }) : (E.attr("opacity", 0).merge(v).attr("class", "area").attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        dataGroupName: x.name,
        originalClassName: "area"
      })
    ).style("fill", (x) => y.model.getFillColor(x.name, null, x.data)).transition().call(
      (x) => this.services.transitions.setupTransition({
        transition: x,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", h ? 1 : ye.opacity.selected).attr("d", (x) => {
      const { data: b } = x;
      return o(b);
    }), h && E.attr("fill-opacity", ye.opacity.selected).style("stroke", (x) => y.model.getStrokeColor(x.name, null, x.data)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class vm extends dt {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-line"
        })
      ).attr("opacity", (n) => n.name !== e.datum().name ? ve.opacity.unselected : ve.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ve.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = navigator.userAgent.toLowerCase().indexOf("firefox") > -1, n = this.model.get("zoomDomain") !== void 0, s = e && n ? this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !1 }) : this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), { cartesianScales: a, curves: r } = this.services, o = (v) => a.getDomainValue(v), c = (v) => a.getRangeValue(v), [l, h] = xe(
      o,
      c,
      a.getOrientation()
    ), d = this.getOptions(), u = Nn().x(l).y(h).curve(r.getD3Curve()).defined((v) => {
      const S = a.getRangeIdentifier(v), y = v[S];
      return y != null;
    });
    let p = [];
    if (this.configs.stacked) {
      const v = Object.keys(d.axes).some((E) => d.axes[E].percentage), { groupMapsTo: S } = d.data;
      p = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: v
      }).map((E) => {
        const x = this.services.cartesianScales.getDomainIdentifier(E), b = this.services.cartesianScales.getRangeIdentifier(E);
        return {
          name: O(E, 0, S),
          data: E.map((k) => ({
            [x]: k.data.sharedStackKey,
            [S]: k[S],
            [b]: k[1]
          })),
          hidden: !wc(E, (k) => k[0] !== k[1])
        };
      });
    } else
      p = this.model.getGroupedData(this.configs.groups);
    const f = s.selectAll("path.line").data(p, (v) => v.name);
    f.exit().attr("opacity", 0).remove();
    const m = f.enter().append("path").classed("line", !0).attr("opacity", 0).merge(f).data(p, (v) => v.name).attr(
      "class",
      (v) => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        dataGroupName: v.name,
        originalClassName: "line"
      })
    ).style("stroke", (v) => this.model.getStrokeColor(v.name, null, v.data)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (v) => {
      const { data: S } = v;
      return S.map((y) => {
        const E = this.services.cartesianScales.getRangeIdentifier(y);
        return y[E];
      }).join(",");
    });
    if (e && n) {
      const v = a.getMainXScale(), S = a.getMainYScale();
      if (v && S) {
        const [y, E] = v.range(), [x, b] = S.range();
        s.style("overflow", "hidden").style("clip", `rect(${b}px, ${E}px, ${x}px, ${y}px)`);
      }
    }
    m.transition().call(
      (v) => this.services.transitions.setupTransition({
        transition: v,
        name: "line-update-enter",
        animate: t
      })
    ).attr("opacity", (v) => v.hidden ? 0 : 1).attr("d", (v) => {
      const { data: S } = v;
      return u(S);
    });
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const Rr = 5;
function np(i, t) {
  return i > t - Rr && i < t + Rr;
}
class qo extends dt {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = at.SVG, this.isXGridEnabled = O(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = O(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = O(this.getOptions(), "ruler", "enabled");
    this.drawBackdrop(), e && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !e && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(t) {
    return t;
  }
  showRuler(t, [e, n]) {
    const s = this.parent, a = this.services.cartesianScales.getOrientation(), r = this.model.getDisplayData(), o = this.services.cartesianScales.getRangeScale(), [c, l] = o.range(), h = a === Xt.HORIZONTAL ? n : e, d = I.appendOrSelect(s, "g.ruler").attr("aria-label", "ruler"), u = I.appendOrSelect(d, "line.ruler-line"), p = s.selectAll("[role=graphics-symbol]"), f = r.map((m) => ({
      domainValue: this.services.cartesianScales.getDomainValue(m),
      originalData: m
    })).filter((m) => np(m.domainValue, h));
    if (this.pointsWithinLine && f.length === this.pointsWithinLine.length && f.map((m) => m.domainValue).join() === this.pointsWithinLine.map((m) => m.domainValue).join())
      return this.pointsWithinLine = f, this.services.events.dispatchEvent(T.Tooltip.MOVE, {
        mousePosition: [e, n]
      });
    this.pointsWithinLine = f;
    const g = this.pointsWithinLine.reduce((m, v) => {
      if (m.length === 0)
        return m.push(v), m;
      const S = m[0].domainValue, y = Math.abs(h - v.domainValue), E = Math.abs(h - S);
      return y > E || (y < E ? m = [v] : m.push(v)), m;
    }, []);
    if (g.length > 0) {
      const m = g.map((E) => E.originalData).filter((E) => {
        const x = this.services.cartesianScales.getRangeIdentifier(E), b = E[x];
        return b != null;
      }), v = g.map(
        (E) => E.domainValue
      ), S = p.filter((E) => {
        const x = this.services.cartesianScales.getDomainValue(E);
        return v.includes(x);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !co(this.elementsToHighlight, S) && this.hideRuler(), S.dispatch("mouseover"), this.elementsToHighlight = S, this.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: t,
        mousePosition: [e, n],
        hoveredElement: u,
        data: this.formatTooltipData(m)
      }), d.attr("opacity", 1);
      const y = g[0];
      a === "horizontal" ? u.attr("x1", l).attr("x2", c).attr("y1", y.domainValue).attr("y2", y.domainValue) : u.attr("y1", l).attr("y2", c).attr("x1", y.domainValue).attr("x2", y.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const t = this.parent, e = I.appendOrSelect(t, "g.ruler");
    t.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(T.Tooltip.HIDE), e.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const t = this, e = this.services.domUtils.getHolder(), n = this.model.getDisplayData();
    let s = function(a) {
      const r = sn(a, t.parent.node());
      t.showRuler(a, r);
    };
    if (n.length > 100) {
      const a = n.length % 50 * 12.5;
      s = pl(
        function(r) {
          const { mousePosition: o } = this;
          t.showRuler(r, o);
        },
        a,
        e
      );
    }
    this.backdrop.on("mousemove mouseover", s).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const t = this.parent;
    this.backdrop = I.appendOrSelect(t, "svg.chart-grid-backdrop");
  }
}
class Qi extends dt {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = at.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (t) => {
          var e;
          return (e = this.services.transitions) == null ? void 0 : e.setupTransition({
            transition: t,
            name: "chart-holder-hover-scatter"
          });
        }
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (t) => {
          var e;
          return (e = this.services.transitions) == null ? void 0 : e.setupTransition({
            transition: t,
            name: "chart-holder-mouseout-scatter"
          });
        }
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (s) => {
          var a;
          return (a = this.services.transitions) == null ? void 0 : a.setupTransition({
            transition: s,
            name: "legend-hover-scatter"
          });
        }
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (t) => {
          var e;
          return (e = this.services.transitions) == null ? void 0 : e.setupTransition({
            transition: t,
            name: "legend-mouseout-scatter"
          });
        }
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    if (!t) throw new Error("Services events are undefined.");
    t.addEventListener(
      T.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: e } = this.configs;
    e && (t.addEventListener(T.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.addEventListener(T.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(t) {
    const { cartesianScales: e } = this.services;
    if (!e) throw new Error("Services cartesianScales are undefined.");
    const n = e.getDomainIdentifier(t), s = this.model.get("zoomDomain");
    return s !== void 0 ? t.filter(
      (a) => a[n].getTime() >= s[0].getTime() && a[n].getTime() <= s[1].getTime()
    ) : t;
  }
  getScatterData() {
    const t = this.getOptions(), { stacked: e } = this.configs;
    let n;
    if (e) {
      const s = Object.keys(t.axes).some((a) => t.axes[a].percentage);
      n = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: s
      });
    } else {
      const { cartesianScales: s } = this.services;
      if (!s) throw new Error("Services cartesianScales are undefined.");
      n = this.model.getDisplayData(this.configs.groups).filter((a) => {
        const r = s.getRangeIdentifier(a);
        return a[r] !== void 0 && a[r] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(n);
  }
  render(t) {
    if (!(O(this.getOptions(), "points", "enabled") || O(this.getOptions(), "bubble", "enabled")))
      return;
    const n = this.getComponentContainer({ ariaLabel: "scatter points", withinChartClip: !0 }), s = this.getOptions(), { groupMapsTo: a } = s.data, { cartesianScales: r } = this.services;
    if (!r) throw new Error("Services cartesianScales are undefined.");
    const o = r.getDomainIdentifier(), c = n.selectAll("circle.dot").data(
      this.getScatterData(),
      (d) => `${d[a]}-${d[o]}`
    );
    c.exit().attr("opacity", 0).remove();
    const h = c.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(c);
    this.styleCircles(h, t), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(t) {
    const { handleThresholds: e } = this.configs;
    if (!e)
      return !1;
    const { cartesianScales: n } = this.services;
    if (!n) throw new Error("Cartesian scales service is undefined");
    const s = n.getOrientation(), [a, r] = xe(
      n.getHighestDomainThreshold(),
      n.getHighestRangeThreshold(),
      s
    ), [o, c] = xe(
      (d) => n.getDomainValue(d),
      (d) => n.getRangeValue(d),
      s
    ), l = o(t), h = c(t);
    return r && a ? h <= r.scaleValue && l >= a.scaleValue : r ? h <= r.scaleValue : a ? l >= a.scaleValue : !1;
  }
  styleCircles(t, e) {
    const n = this.getOptions(), { filled: s, fillOpacity: a } = n.points, { cartesianScales: r } = this.services;
    if (!r) throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: o } = n.data, c = (p) => r.getDomainValue(p), l = (p) => r.getRangeValue(p), [h, d] = xe(
      c,
      l,
      r.getOrientation()
    ), { fadeInOnChartHolderMouseover: u } = this.configs;
    t.raise().classed("dot", !0).attr("class", (p) => {
      const f = r.getDomainIdentifier(p), m = this.model.getIsFilled(p[o], p[f], p, s) ? [nt.FILL, nt.STROKE] : [nt.STROKE];
      return this.model.getColorClassName({
        classNameTypes: m,
        dataGroupName: p[o],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (p) => this.isDatapointThresholdAnomaly(p)).classed("filled", (p) => {
      const f = r.getDomainIdentifier(p);
      return this.model.getIsFilled(p[o], p[f], p, s);
    }).classed("unfilled", (p) => {
      const f = r.getDomainIdentifier(p);
      return !this.model.getIsFilled(p[o], p[f], p, s);
    }).transition().call(
      (p) => {
        var f;
        return (f = this.services.transitions) == null ? void 0 : f.setupTransition({
          transition: p,
          name: "scatter-update-enter",
          animate: e
        });
      }
    ).attr("cx", h).attr("cy", d).attr("r", n.points.radius).style("fill", (p) => {
      const f = r.getDomainIdentifier(p);
      if (this.model.getIsFilled(p[o], p[f], p, s))
        return this.model.getFillColor(p[o], p[f], p);
    }).style("stroke", (p) => {
      const f = r.getDomainIdentifier(p);
      return this.model.getStrokeColor(p[o], p[f], p);
    }).attr("fill-opacity", s ? a : 1).attr("opacity", u ? 0 : 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (p) => {
      const f = r.getRangeIdentifier(p);
      return p[f];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(t) {
    return null;
  }
  addEventListeners() {
    const t = this, { groupMapsTo: e } = t.getOptions().data;
    if (!this.parent) throw new Error("Parent not defined");
    this.parent.selectAll("circle").on("mouseover", function(n, s) {
      var r, o;
      const a = D(this);
      a.classed("hovered", !0).attr(
        "class",
        (c) => t.model.getColorClassName({
          classNameTypes: [nt.FILL],
          dataGroupName: c[e],
          originalClassName: a.attr("class")
        })
      ).style("fill", (c) => {
        var h;
        const l = (h = t.services.cartesianScales) == null ? void 0 : h.getDomainIdentifier(c);
        return t.model.getFillColor(c[e], c[l], c);
      }).classed("unfilled", !1), (r = t.services.events) == null || r.dispatchEvent(T.Tooltip.SHOW, {
        event: n,
        hoveredElement: a,
        data: [s],
        additionalItems: t.getTooltipAdditionalItems(s)
      }), (o = t.services.events) == null || o.dispatchEvent(T.Scatter.SCATTER_MOUSEOVER, {
        event: n,
        element: a,
        datum: s
      });
    }).on("mousemove", function(n, s) {
      var r, o;
      const a = D(this);
      (r = t.services.events) == null || r.dispatchEvent(T.Scatter.SCATTER_MOUSEMOVE, {
        event: n,
        element: a,
        datum: s
      }), (o = t.services.events) == null || o.dispatchEvent(T.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      var a;
      (a = t.services.events) == null || a.dispatchEvent(T.Scatter.SCATTER_CLICK, {
        event: n,
        element: D(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      var r, o, c;
      const a = D(this);
      if (a.classed("hovered", !1), !t.configs.filled) {
        const { filled: l } = t.getOptions().points, h = (r = t.services.cartesianScales) == null ? void 0 : r.getDomainIdentifier(s), d = t.model.getIsFilled(
          s[e],
          s[h],
          s,
          l
        );
        a.classed("unfilled", !d).style("fill", (u) => d || l ? t.model.getFillColor(u[e], u[h], u) : null);
      }
      (o = t.services.events) == null || o.dispatchEvent(T.Scatter.SCATTER_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), (c = t.services.events) == null || c.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  destroy() {
    var e;
    (e = this.parent) == null || e.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: t } = this.services;
    if (!t) throw new Error("Services events undefined");
    t.removeEventListener(
      T.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(T.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.removeEventListener(T.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
}
class jo extends dt {
  constructor(t, e, n) {
    super(t, e, n), this.type = "axes", this.renderType = at.SVG, this.truncation = {
      [J.LEFT]: !1,
      [J.RIGHT]: !1,
      [J.TOP]: !1,
      [J.BOTTOM]: !1
    }, n && (this.configs = n), this.margins = this.configs.margins;
  }
  render(t = !0) {
    const { position: e } = this.configs, n = this.getOptions(), s = O(n, "axes", e, "visible"), a = this.getComponentContainer({
      ariaLabel: "axes"
    }), { width: r, height: o } = I.getSVGElementSize(a, {
      useAttrs: !0
    }), c = I.appendOrSelect(a, `g.axis.${e}`);
    let l, h;
    if (e === J.BOTTOM || e === J.TOP ? (l = this.configs.axes[J.LEFT] ? this.margins.left : 0, h = this.configs.axes[J.RIGHT] ? r - this.margins.right : r) : (l = o - this.margins.bottom, h = this.margins.top), !this.services.cartesianScales) throw new Error("Services cartesianScales undefined");
    const d = this.services.cartesianScales.getScaleByPosition(e);
    this.scaleType === kt.LABELS || this.scaleType === kt.LABELS_RATIO ? d.rangeRound([l, h]) : d.range([l, h]);
    let u;
    switch (e) {
      case J.LEFT:
        u = ho;
        break;
      case J.BOTTOM:
        u = Fi;
        break;
      case J.RIGHT:
        u = $c;
        break;
      case J.TOP:
        u = Pc;
        break;
    }
    c.attr("aria-label", `${e} axis`);
    const p = !c.select("g.ticks").empty();
    let f = I.appendOrSelect(c, "g.ticks");
    p || (f.attr("role", `${lt.GRAPHICS_OBJECT} ${lt.GROUP}`), f.attr("aria-label", `${e} ticks`));
    const g = I.appendOrSelect(c, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${e} ticks`), m = O(n, "axes", e), v = this.scaleType === kt.TIME || m.scaleType === kt.TIME, S = e === J.LEFT || e === J.RIGHT, y = this.model.get("zoomDomain");
    if (y && v && !S && d.domain(y), !s) {
      f.attr("aria-hidden", !0);
      return;
    }
    const E = O(m, "scaleType"), x = O(n, "data", "loading"), b = O(m, "ticks", "number"), k = O(m, "ticks", "values"), _ = O(m, "truncation", "type"), G = O(m, "truncation", "threshold"), R = O(m, "truncation", "numCharacter"), A = b !== null, H = O(n, "timeScale"), N = I.appendOrSelect(g, "g.tick"), M = I.appendOrSelect(N, "text").text("0"), L = I.getSVGElementSize(M.node(), {
      useBBox: !0
    }).height;
    N.remove();
    const P = this.scaleType || m.scaleType || kt.LINEAR, $ = u(d).tickSizeOuter(0);
    if (d.ticks) {
      let Y;
      if (A ? Y = b : (Y = Ke.ticks.number, S && (Y = this.getNumberOfFittingTicks(
        o,
        L,
        Ke.ticks.verticalSpaceRatio
      ))), d.ticks().length === 1 && d.ticks()[0] === 0 && (Y = 0), $.ticks(Y), v)
        if (!d.ticks(Y).length)
          $.tickValues([]);
        else {
          const K = O(n, "timeScale", "addSpaceOnEdges"), ot = O(n, "axes", e, "domain"), ct = d.copy();
          K && !ot && ct.nice(Y);
          const st = ct.ticks(Y);
          K && st.length > 2 && !ot && (st.splice(st.length - 1, 1), st.splice(0, 1)), $.tickValues(st);
        }
    }
    let C;
    const V = O(m, "ticks", "formatter"), { code: q, number: X } = O(n, "locale");
    if (v) {
      const Y = hi(
        $.tickValues(),
        O(n, "timeScale", "timeInterval")
      );
      V === null ? C = (K, ot) => di(K, ot, $.tickValues(), Y, H, n.locale) : C = (K, ot) => {
        const ct = di(
          K,
          ot,
          $.tickValues(),
          Y,
          H,
          n.locale
        );
        return V(K, ot, ct);
      };
    } else
      V === null ? P === kt.LINEAR && (C = (Y) => X(Y, q)) : C = V;
    $.tickFormat(C);
    const [F, Z] = this.services.cartesianScales.getScaleByPosition(e).domain();
    let rt;
    if (k) {
      if (v)
        k.forEach((Y, K) => {
          Y.getTime === void 0 && (k[K] = new Date(Y));
        }), rt = k.filter((Y) => {
          const K = Y.getTime();
          return K >= new Date(F).getTime() && K <= new Date(Z).getTime();
        });
      else if (E === kt.LABELS) {
        const Y = this.services.cartesianScales.getScaleByPosition(e).domain();
        rt = k.filter((K) => Y.includes(K));
      } else
        rt = k.filter(
          (Y) => Y >= F && Y <= Z
        );
      $.tickValues(rt);
    }
    switch (e) {
      case J.LEFT:
        f.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case J.BOTTOM:
        f.attr("transform", `translate(0, ${o - this.margins.bottom})`);
        break;
      case J.RIGHT:
        f.attr("transform", `translate(${r - this.margins.right}, 0)`);
        break;
      case J.TOP:
        f.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const j = this.model.isDataEmpty();
    if (m.title) {
      const Y = I.appendOrSelect(c, "text.axis-title").html(
        j || x ? "" : ue(m.title)
      ), K = O(m, "titleOrientation");
      let ot;
      switch (e) {
        case J.LEFT:
          K === Ta.RIGHT ? Y.attr("transform", "rotate(90)").attr("y", 0).attr("x", d.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : Y.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(d.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case J.BOTTOM:
          Y.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${o + 4})`
          ).style("text-anchor", "middle");
          break;
        case J.RIGHT:
          K === Ta.LEFT ? Y.attr("transform", "rotate(-90)").attr("y", r).attr("x", -(d.range()[0] / 2)).style("text-anchor", "middle") : Y.attr("transform", "rotate(90)").attr("y", -r).attr("x", d.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case J.TOP:
          ot = I.getSVGElementSize(Y, {
            useBBox: !0
          }).height, Y.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${ot / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (v) {
      const Y = hi(
        $.tickValues(),
        O(n, "timeScale", "timeInterval")
      ), K = H.showDayName, ot = f;
      t && (f = f.transition().call(
        (st) => this.services.transitions.setupTransition({
          transition: st,
          name: "axis-update",
          animate: t
        })
      )), f = f.call($), ot.selectAll(".tick").data($.tickValues(), d).order().select("text").attr(
        "class",
        (st, it) => fl(st, it, $.tickValues(), Y, K) ? "tick-label--primary" : "tick-label"
      );
    } else
      !t || !p ? f = f.call($) : f = f.transition().call(
        (Y) => this.services.transitions.setupTransition({
          transition: Y,
          name: "axis-update",
          animate: t
        })
      ).call($);
    if (g.call($), e === J.BOTTOM || e === J.TOP) {
      let Y = !1;
      const K = O(m, "ticks", "rotation");
      if (K === $s.ALWAYS)
        Y = !0;
      else if (K === $s.NEVER)
        Y = !1;
      else if (!K || K === $s.AUTO)
        if (d.step)
          Y = g.selectAll("g.tick text").nodes().some(
            (ct) => I.getSVGElementSize(ct, {
              useBBox: !0
            }).width >= d.step()
          );
        else {
          Y = !1;
          const ot = g.append("text").text("A"), ct = I.getSVGElementSize(ot.node(), {
            useBBox: !0
          }).width;
          let st;
          g.selectAll("g.tick").each(function() {
            const it = D(this), z = parseFloat(O(ge(this), "tx"));
            z !== null && st + it.text().length * ct * 0.8 >= z && (Y = !0), st = z;
          }), ot.remove();
        }
      Y ? (A || ($.ticks(
        this.getNumberOfFittingTicks(r, L, Ke.ticks.horizontalSpaceRatio)
      ), g.call($), f.call($)), c.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", e === J.TOP ? "start" : "end")) : c.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (x ? c.attr("opacity", 0) : c.attr("opacity", 1), f.selectAll("g.tick").attr("aria-label", (Y) => Y), g.selectAll("g.tick").attr("aria-label", (Y) => Y), _ !== Je.NONE && E === kt.LABELS && !k) {
      const Y = this.services.cartesianScales.getScaleDomain(e);
      if (Y.length > 0) {
        const K = a.select(`g.axis.${e} g.ticks g.tick`).html();
        c.selectAll("g.ticks g.tick").html(K);
        const ot = this;
        c.selectAll("g.tick text").data(Y).text(function(ct) {
          return ct.length > G ? (ot.truncation[e] = !0, Cn(ct, _, R)) : ct;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(Y).text(function(ct) {
          return ct.length > G ? Cn(ct, _, R) : ct;
        }), c.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), c.selectAll("g.tick text").data(Y);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: e } = this.configs, n = I.appendOrSelect(t, `g.axis.${e}`), s = this.getOptions(), a = O(s, "axes", e), r = O(a, "scaleType"), o = O(a, "truncation", "threshold"), c = this;
    n.selectAll("g.tick text").on("mouseover", function(l, h) {
      c.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOVER, {
        event: l,
        element: D(this),
        datum: h
      }), r === kt.LABELS && h.length > o && c.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: l,
        hoveredElement: D(this),
        content: h
      });
    }).on("mousemove", function(l, h) {
      c.services.events.dispatchEvent(T.Axis.LABEL_MOUSEMOVE, {
        event: l,
        element: D(this),
        datum: h
      }), r === kt.LABELS && h.length > o && c.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l, h) {
      c.services.events.dispatchEvent(T.Axis.LABEL_CLICK, {
        event: l,
        element: D(this),
        datum: h
      });
    }).on("mouseout", function(l, h) {
      c.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOUT, {
        event: l,
        element: D(this),
        datum: h
      }), r === kt.LABELS && c.services.events.dispatchEvent(T.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} text.axis-title`);
  }
  getNumberOfFittingTicks(t, e, n) {
    const s = Math.floor(t / (e * n));
    return lo(s, 2, Ke.ticks.number);
  }
  destroy() {
    const t = this.getComponentContainer(), { position: e } = this.configs;
    I.appendOrSelect(t, `g.axis.${e}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class sp extends jo {
  constructor(t, e, n) {
    super(t, e, n);
  }
  render(t = !0) {
    super.render(t), super.destroy();
    const e = this.configs.position, n = this.getComponentContainer({
      ariaLabel: "axes"
    }), s = I.appendOrSelect(n, `g.axis.${e}`), a = this;
    s.selectAll("g.tick").each(function(r, o) {
      const c = D(this);
      c.classed("tick-hover", !0).attr("tabindex", o === 0 ? 0 : -1);
      const l = c.select("text"), { width: h, height: d } = I.getSVGElementSize(l, {
        useBBox: !0
      }), u = I.appendOrSelect(c, "rect.axis-holder");
      let p = 0, f = 0;
      switch (e) {
        case J.LEFT:
          p = -h + Number(l.attr("x")), f = -(d / 2);
          break;
        case J.RIGHT:
          p = Math.abs(Number(l.attr("x"))), f = -(d / 2);
          break;
        case J.TOP:
          p = -(h / 2), f = -d + Number(l.attr("y")) / 2, a.truncation[e] && (p = 0, u.attr("transform", "rotate(-45)"));
          break;
        case J.BOTTOM:
          p = -(h / 2), f = d / 2 - 2, a.truncation[e] && (p = -h, u.attr("transform", "rotate(-45)"));
          break;
      }
      u.attr("x", p - Ke.hover.rectanglePadding).attr("y", f).attr("width", h + Ke.hover.rectanglePadding * 2).attr("height", d).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: e } = this.configs, n = I.appendOrSelect(t, `g.axis.${e}`), s = this.getOptions(), a = O(s, "axes", e), r = O(a, "scaleType"), o = O(a, "truncation", "threshold"), c = this;
    n.selectAll("g.tick.tick-hover").on("mouseover", function(l) {
      const h = D(this).select("text"), d = h.datum();
      c.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOVER, {
        event: l,
        element: h,
        datum: d
      }), r === kt.LABELS && d.length > o && c.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: l,
        element: h,
        datum: d
      });
    }).on("mousemove", function(l) {
      const h = D(this).select("text"), d = h.datum();
      c.services.events.dispatchEvent(T.Axis.LABEL_MOUSEMOVE, {
        event: l,
        element: h,
        datum: d
      }), c.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l) {
      c.services.events.dispatchEvent(T.Axis.LABEL_CLICK, {
        event: l,
        element: D(this).select("text"),
        datum: D(this).select("text").datum()
      });
    }).on("mouseout", function(l) {
      c.services.events.dispatchEvent(T.Axis.LABEL_MOUSEOUT, {
        event: l,
        element: D(this).select("text"),
        datum: D(this).select("text").datum()
      }), r === kt.LABELS && c.services.events.dispatchEvent(T.Tooltip.HIDE);
    }).on("focus", function(l) {
      const h = { clientX: 0, clientY: 0 };
      if (l.target) {
        l.target.focus();
        const d = l.target.getBoundingClientRect();
        h.clientX = d.x, h.clientY = d.y;
      }
      c.services.events.dispatchEvent(T.Axis.LABEL_FOCUS, {
        event: { ...l, ...h },
        element: D(this),
        datum: D(this).select("text").datum()
      });
    }).on("blur", function(l) {
      c.services.events.dispatchEvent(T.Axis.LABEL_BLUR, {
        event: l,
        element: D(this),
        datum: D(this).select("text").datum()
      });
    }).on("keydown", function(l) {
      l.key && l.key === "Escape" && (c.services.events.dispatchEvent(T.Tooltip.HIDE), c.services.events.dispatchEvent(T.Axis.LABEL_BLUR, {
        event: l,
        element: D(this),
        datum: D(this).select("text").datum()
      })), e === J.LEFT || e === J.RIGHT ? l.key && l.key === "ArrowUp" ? c.goNext(this, l) : l.key && l.key === "ArrowDown" && c.goPrevious(this, l) : l.key && l.key === "ArrowLeft" ? c.goPrevious(this, l) : l.key && l.key === "ArrowRight" && c.goNext(this, l);
    });
  }
  // Focus on the next HTML element sibling
  goNext(t, e) {
    t.nextElementSibling && t.nextElementSibling.tagName !== "path" && t.nextElementSibling.dispatchEvent(new Event("focus")), e.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(t, e) {
    t.previousElementSibling && t.previousElementSibling.tagName !== "path" && t.previousElementSibling.dispatchEvent(new Event("focus")), e.preventDefault();
  }
  destroy() {
    const t = this.getComponentContainer(), { position: e } = this.configs;
    I.appendOrSelect(t, `g.axis.${e}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class ym extends dt {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = at.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(t = !1) {
    const e = {}, n = Object.keys(J), s = O(this.getOptions(), "axes");
    n.forEach((o) => {
      s[J[o]] && (e[J[o]] = !0);
    }), this.configs.axes = e, n.forEach((o) => {
      const c = J[o];
      if (this.configs.axes[c] && !this.children[c]) {
        const l = {
          position: c,
          axes: this.configs.axes,
          margins: this.margins
        }, h = this.model.axisFlavor === Sl.DEFAULT ? new jo(this.model, this.services, l) : new sp(this.model, this.services, l);
        h.setModel(this.model), h.setServices(this.services), h.setParent(this.parent), this.children[c] = h;
      }
    }), Object.keys(this.children).forEach((o) => {
      this.children[o].render(t);
    });
    const a = {};
    Object.keys(this.children).forEach((o) => {
      const c = this.children[o], l = c.configs.position, h = c.getInvisibleAxisRef(), { width: d, height: u } = I.getSVGElementSize(h, { useBBox: !0 });
      let p;
      switch (c.getTitleRef().empty() ? p = 0 : (p = I.getSVGElementSize(c.getTitleRef(), {
        useBBox: !0
      }).height, (l === J.LEFT || l === J.RIGHT) && (p += 5)), l) {
        case J.TOP:
          a.top = u + p;
          break;
        case J.BOTTOM:
          a.bottom = u + p;
          break;
        case J.LEFT:
          a.left = d + p;
          break;
        case J.RIGHT:
          a.right = d + p;
          break;
      }
    }), this.services.events.dispatchEvent(T.Axis.RENDER_COMPLETE), Object.keys(a).some(
      (o) => this.margins[o] !== a[o]
    ) && (this.margins = Object.assign(this.margins, a), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(T.ZoomBar.UPDATE), Object.keys(this.children).forEach((o) => {
      const c = this.children[o];
      c.margins = this.margins;
    }), this.render(!0));
  }
}
class ip extends dt {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = O(this.getOptions(), "data", "loading");
    e ? this.renderSkeleton(e) : this.removeSkeleton();
  }
  renderSkeleton(t) {
    if (this.configs.skeleton === Bn.GRID)
      this.renderGridSkeleton(t);
    else if (this.configs.skeleton === Bn.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(t);
    else if (this.configs.skeleton === Bn.PIE)
      this.renderPieSkeleton(t);
    else if (this.configs.skeleton === Bn.DONUT)
      this.renderDonutSkeleton(t);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawXGrid(t), this.drawYGrid(t), t && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(t) {
    const e = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(t), e === Xt.VERTICAL && this.drawYGrid(t), e === Xt.HORIZONTAL && this.drawXGrid(t), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(t) {
    const e = this.computeOuterRadius();
    this.drawRing(e, 0, t), t && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(t) {
    const e = this.computeOuterRadius(), n = this.computeInnerRadius();
    this.drawRing(e, n, t), t && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const t = this.services.cartesianScales.getMainXScale().range(), e = this.services.cartesianScales.getMainYScale().range();
    this.xScale = Re().domain([0, 1]).range(t), this.yScale = Re().domain([0, 1]).range(e);
  }
  drawBackdrop(t) {
    const e = this.parent, { width: n, height: s } = I.getSVGElementSize(e, {
      useAttrs: !0
    });
    this.backdrop = I.appendOrSelect(e, "svg.chart-skeleton.DAII").attr("role", "presentation").attr("width", n).attr("height", s);
    const a = I.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    a.attr("width", "100%").attr("height", "100%");
    const [r] = this.xScale.range(), [, o] = this.yScale.range();
    this.backdrop.merge(a).attr("x", r).attr("y", o), a.classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(t) {
    const e = +this.backdrop.attr("width"), n = O(this.getOptions(), "grid", "x", "numberOfTicks"), s = this.xScale.ticks(n).map((o) => o * e), a = I.appendOrSelect(this.backdrop, "g.x.skeleton"), r = a.selectAll("line").data(s);
    r.enter().append("line").merge(r).attr("x1", (o) => o).attr("x2", (o) => o).attr("y1", 0).attr("y2", "100%"), a.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(t) {
    const e = +this.backdrop.attr("height"), n = this.backdrop.attr("width"), s = O(this.getOptions(), "grid", "y", "numberOfTicks"), a = this.xScale.ticks(s).map((c) => c * e), r = I.appendOrSelect(this.backdrop, "g.y.skeleton"), o = r.selectAll("line").data(a);
    o.enter().append("line").merge(o).attr("x1", 0).attr("x2", n).attr("y1", (c) => c).attr("y2", (c) => c), r.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(t, e, n = !0) {
    const s = this.parent, { width: a, height: r } = I.getSVGElementSize(s, {
      useAttrs: !0
    }), o = I.appendOrSelect(s, "svg.chart-skeleton").attr("width", a).attr("height", r).attr("role", "presentation"), c = e === 0 ? "pie" : "donut", l = O(this.getOptions(), c, "alignment");
    I.appendOrSelect(o, "rect.chart-skeleton-area-container").attr("width", a).attr("height", r).attr("fill", "none");
    const h = Rn().innerRadius(e).outerRadius(t).startAngle(0).endAngle(Math.PI * 2), d = t + Math.abs(Et.radiusOffset), u = t + (Math.min(a, r) - t * 2) / 2, p = I.appendOrSelect(o, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${d}, ${u})`).attr("d", h).classed("shimmer-effect-areas", n).classed("empty-state-areas", !n).style(
      "fill",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let f = t + Et.xOffset;
    l === te.CENTER ? f = a / 2 : l === te.RIGHT && (f = a - t - Et.xOffset);
    const g = t + Et.yOffset;
    p.attr("transform", `translate(${f}, ${g})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: t, height: e } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(t, e) / 2 + Et.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(t) {
    const a = "stop-bg-shimmer", r = "stop-shimmer", o = this.parent.select(".chart-skeleton"), { width: c } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), l = 0, h = c, d = I.appendOrSelect(o, "defs").lower(), u = I.appendOrSelect(d, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(t)).attr("class", t).attr("x1", l - 3 * 0.2 * c).attr("x2", h).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), p = `
			<stop class="${a}" offset="${l}"></stop>
			<stop class="${r}" offset="${l + 0.2}"></stop>
			<stop class="${a}" offset="${l + 2 * 0.2}"></stop>
		`;
    u.html(p), f();
    function f() {
      u.attr("gradientTransform", `translate(${l - 3 * 0.2 * c}, 0)`).transition().duration(2e3).delay(1e3).ease(Bc).attr("gradientTransform", `translate(${h + 3 * 0.2 * c}, 0)`).on("end", f);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class Em extends dt {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = at.SVG;
  }
  render(t) {
    const e = this.getComponentContainer({ ariaLabel: "box plots", withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: s } = n.data, a = this.model.getDataGroupNames(), r = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), [c, l] = r.range(), [h, d] = o.range(), u = l - c, p = h - d;
    if (u === 0)
      return;
    const { cartesianScales: f } = this.services, g = f.getOrientation(), m = g === Xt.VERTICAL, [v, S] = xe(
      (A) => this.services.cartesianScales.getDomainValue(A),
      (A) => this.services.cartesianScales.getRangeValue(A),
      g
    ), y = Math.floor((m ? u : p) / a.length), E = Math.min(y / 2, 16), x = this.model.getBoxplotData(), b = e.selectAll(".box-group").data(x);
    b.exit().remove();
    const k = b.enter().append("g").attr("class", "box-group"), _ = b.merge(k);
    k.append("path").merge(b.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", qt.strokeWidth.default).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-verticalstartline",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]), N = H, M = f.getRangeValue(A.whiskers.min), L = f.getRangeValue(A.quartiles.q_25);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, g);
    }), k.append("path").merge(b.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", qt.strokeWidth.default).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-verticalendline",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]), N = H, M = f.getRangeValue(A.whiskers.max), L = f.getRangeValue(A.quartiles.q_75);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, g);
    }), k.append("path").merge(b.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", qt.box.opacity.default).attr("stroke-width", qt.strokeWidth.default).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (A) => A[s]).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-quartiles",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 2, N = H + E, M = f.getRangeValue(
        Math[m ? "max" : "min"](A.quartiles.q_75, A.quartiles.q_25)
      ), L = M + Math.abs(
        f.getRangeValue(A.quartiles.q_75) - f.getRangeValue(A.quartiles.q_25)
      );
      return Gt({ x0: H, x1: N, y0: M, y1: L }, g);
    }), k.append("path").merge(b.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 2, N = H + E, M = f.getRangeValue(A.whiskers.min), L = f.getRangeValue(A.whiskers.max);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, g);
    }), k.append("path").merge(b.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", qt.strokeWidth.thicker).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-startingwhisker",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 4, N = H + E / 2, M = f.getRangeValue(A.whiskers.min), L = f.getRangeValue(A.whiskers.min);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, g);
    }), k.append("path").merge(b.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-median",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 2, N = H + E, M = f.getRangeValue(A.quartiles.q_50);
      return Gt({ x0: H, x1: N, y0: M, y1: M }, g);
    }), k.append("path").merge(b.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", qt.strokeWidth.thicker).attr("fill", "none").transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-endingwhisker",
        animate: t
      })
    ).attr("d", (A) => {
      const H = f.getDomainValue(A[s]) - E / 4, N = H + E / 2, M = f.getRangeValue(A.whiskers.max), L = f.getRangeValue(A.whiskers.max);
      return Gt({ x0: H, x1: N, y0: M, y1: L }, g);
    });
    const G = _.selectAll("circle.outlier").data(
      (A) => A.outliers.map((H) => ({
        min: A.whiskers.min,
        max: A.whiskers.max,
        [s]: A[s],
        value: H
      }))
    );
    G.exit().remove();
    const R = G.enter().append("circle");
    G.merge(R).attr("r", qt.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", qt.circle.opacity.default).attr("cx", v).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "boxplot-update-circles",
        animate: t
      })
    ).attr("cy", S), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(s, a) {
      const r = D(this);
      D(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", qt.box.opacity.hovered), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: s,
        hoveredElement: r,
        items: [
          {
            label: O(e, "locale", "translations", "group") || O(e, "tooltip", "groupLabel") || "Group",
            value: a[n],
            class: t.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: a.whiskers.min
          },
          {
            label: "Q1",
            value: a.quartiles.q_25
          },
          {
            label: "Median",
            value: a.quartiles.q_50
          },
          {
            label: "Q3",
            value: a.quartiles.q_75
          },
          {
            label: "Maximum",
            value: a.whiskers.max
          },
          {
            label: "IQR",
            value: a.quartiles.q_75 - a.quartiles.q_25
          }
        ]
      }), t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEOVER, {
        event: s,
        element: r,
        datum: a
      });
    }).on("mousemove", function(s, a) {
      const r = D(this);
      t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEMOVE, {
        event: s,
        element: r,
        datum: a
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(T.Boxplot.BOX_CLICK, {
        event: s,
        element: D(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const r = D(this);
      D(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", qt.box.opacity.default), t.services.events.dispatchEvent(T.Boxplot.BOX_MOUSEOUT, {
        event: s,
        element: r,
        datum: a
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  addCircleEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(a, r) {
      const o = D(this);
      o.classed("hovered", !0).attr("fill-opacity", qt.circle.opacity.hovered).classed("unfilled", !1), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        items: [
          {
            label: O(e, "locale", "translations", "group") || O(e, "tooltip", "groupLabel") || "Group",
            value: r[n],
            class: t.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: r[s]
          }
        ]
      }), t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEOVER, {
        event: a,
        element: o,
        datum: r
      });
    }).on("mousemove", function(a, r) {
      const o = D(this);
      t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEMOVE, {
        event: a,
        element: o,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, r) {
      t.services.events.dispatchEvent(T.Boxplot.OUTLIER_CLICK, {
        event: a,
        element: D(this),
        datum: r
      });
    }).on("mouseout", function(a, r) {
      const o = D(this);
      o.classed("hovered", !1).attr("fill-opacity", qt.circle.opacity.default), t.services.events.dispatchEvent(T.Boxplot.OUTLIER_MOUSEOUT, {
        event: a,
        element: o,
        datum: r
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class xm extends dt {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = at.SVG;
  }
  render(t) {
    const e = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), n = this.services.cartesianScales.getScaleByPosition(e), [s, a] = n.domain(), r = s > 0 && a < 0 || s < 0 && a > 0, o = this.getComponentContainer({
      isPresentational: !0
    });
    if (!r) {
      o.selectAll("line.domain").remove();
      return;
    }
    const [c, l] = this.services.cartesianScales.getDomainScale().range();
    let h = +n(0) + 0.5;
    h || (h = n.range()[0]);
    const d = gl(
      {
        x0: c,
        x1: l,
        y0: h,
        y1: h
      },
      this.services.cartesianScales.getOrientation()
    );
    I.appendOrSelect(o, "line.domain").transition().call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "zero-line-update",
        animate: t
      })
    ).attr("y1", d.y0).attr("y2", d.y1).attr("x1", d.x0).attr("x2", d.x1);
  }
}
class Sm extends Qi {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = at.SVG;
  }
  getRadiusScale(t) {
    const e = this.getOptions(), { radiusMapsTo: n } = e.bubble, s = t.data(), a = s.map((l) => l[n]).filter((l) => l), r = I.getHTMLElementSize(this.services.domUtils.getMainContainer()), o = a.length > 0, c = o ? Os(a) : [1, 1];
    return Re().domain(c).range(o ? e.bubble.radiusRange(r, s) : [4, 4]);
  }
  styleCircles(t, e) {
    const n = this.getOptions(), { radiusMapsTo: s } = n.bubble, a = this.getRadiusScale(t), { groupMapsTo: r } = n.data, { cartesianScales: o } = this.services, c = (u) => o.getDomainValue(u), l = (u) => o.getRangeValue(u), [h, d] = xe(
      c,
      l,
      o.getOrientation()
    );
    t.raise().classed("dot", !0).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-label", (u) => {
      const p = o.getRangeIdentifier(u);
      return u[p];
    }).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bubble-update-enter",
        animate: e
      })
    ).attr("cx", h).attr("cy", d).attr("r", (u) => a(u[s] || 1)).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        dataGroupName: u[r],
        originalClassName: "dot"
      })
    ).style("fill", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[r], u[p], u);
    }).style("stroke", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getStrokeColor(u[r], u[p], u);
    }).attr("fill-opacity", n.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(t) {
    const e = O(this.getOptions(), "bubble");
    return [
      {
        label: O(e, "radiusLabel"),
        value: t[O(e, "radiusMapsTo")]
      }
    ];
  }
}
class bm extends dt {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.getComponentContainer({ ariaLabel: "bullet graphs", withinChartClip: !0 }), a = this.model.getDisplayData(this.configs.groups), r = this.services.cartesianScales.getRangeScale(), o = this.services.cartesianScales.getRangeIdentifier(), [c, l] = r.range(), [, h] = r.domain(), d = () => {
      const g = [];
      a.forEach((S) => {
        S.ranges ? S.ranges.forEach((y, E) => {
          y != null && y < h && g.push({
            datum: S,
            value: y,
            order: E + 1
          });
        }) : g.push({
          datum: S,
          order: 1
        });
      });
      const m = I.appendOrSelect(s, "g.range-boxes").selectAll("path.range-box").data(g, (S) => `${S[n]}-${S.order}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (S) => `range-box order-${S.order}`).transition().call(
        (S) => this.services.transitions.setupTransition({
          transition: S,
          name: "bullet-range-box-update-enter",
          animate: t
        })
      ).attr("d", (S) => {
        let E, x, b, k;
        return S.order === 1 ? (E = this.services.cartesianScales.getDomainValue(S.datum) - 16 / 2, x = E + 16, b = l - 2, k = c + 1) : (E = this.services.cartesianScales.getDomainValue(S.datum) - 16 / 2, x = E + 16, b = this.services.cartesianScales.getRangeValue(S.value), k = l), Gt(
          { x0: E, x1: x, y0: b, y1: k },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, u = () => {
      const g = I.appendOrSelect(s, "g.bars").selectAll("path.bar").data(a, (v) => v[n]);
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("bar", !0).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-bar-update-enter",
          animate: t
        })
      ).attr(
        "class",
        (v) => this.model.getColorClassName({
          classNameTypes: [nt.FILL],
          dataGroupName: v[n],
          originalClassName: "bar"
        })
      ).style("fill", (v) => {
        const S = this.services.cartesianScales.getDomainIdentifier(v);
        return this.model.getFillColor(v[n], v[S], v);
      }).attr("d", (v) => {
        const y = this.services.cartesianScales.getDomainValue(v) - 4, E = y + 8, x = this.services.cartesianScales.getRangeValue(0) + 1, b = this.services.cartesianScales.getRangeValue(v);
        return Gt(
          { x0: y, x1: E, y0: x, y1: b },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (v) => v.value);
    }, p = () => {
      const g = I.appendOrSelect(s, "g.markers").selectAll("path.marker").data(
        a.filter((v) => O(v, "marker") !== null),
        (v) => v[n]
      );
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("marker", !0).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-marker-update-enter",
          animate: t
        })
      ).attr("d", (v) => {
        const y = this.services.cartesianScales.getDomainValue(v) - 12, E = y + 24, x = this.services.cartesianScales.getRangeValue(v.marker);
        return Gt(
          { x0: y, x1: E, y0: x, y1: x },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, f = () => {
      let g = [];
      a.filter((S) => O(S, "marker") !== null).forEach((S) => {
        const y = S.marker, E = S[o];
        g = g.concat([
          { datum: S, value: y * 0.25, barValue: E },
          { datum: S, value: y * 0.5, barValue: E },
          { datum: S, value: y * 0.75, barValue: E }
        ]);
      });
      const m = I.appendOrSelect(s, "g.quartiles").selectAll("path.quartile").data(g, (S) => S[n]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (S) => `quartile ${S.value <= S.barValue ? "over-bar" : ""}`).transition().call(
        (S) => this.services.transitions.setupTransition({
          transition: S,
          name: "bullet-quartile-update-enter",
          animate: t
        })
      ).attr("d", ({ datum: S, value: y }) => {
        let E = 4;
        S.ranges && S.ranges.indexOf(y) !== -1 && (E = 8);
        const x = this.services.cartesianScales.getDomainValue(S) - E / 2, b = x + E, k = this.services.cartesianScales.getRangeValue(y);
        return Gt(
          { x0: x, x1: b, y0: k, y1: k },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    d(), u(), p(), f(), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.services.cartesianScales.getRangeIdentifier(), { code: a, number: r } = O(e, "locale");
    this.parent.selectAll("path.bar").on("mouseover", function(o, c) {
      const l = D(this);
      l.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: o,
        element: l,
        datum: c
      });
      const h = O(e, "bullet", "performanceAreaTitles"), d = t.model.getMatchingRangeIndexForDatapoint(c);
      t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: o,
        hoveredElement: l,
        items: [
          {
            label: O(e, "locale", "translations", "group") || O(e, "tooltip", "groupLabel") || "Group",
            value: c[n],
            class: t.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP],
              dataGroupName: c[n]
            })
          },
          {
            label: "Value",
            value: c[s]
          },
          {
            label: "Target",
            value: c.marker
          },
          {
            label: "Percentage",
            value: `${r(Math.floor(c[s] / c.marker * 100), a)}%`
          },
          {
            label: "Performance",
            value: h[d]
          }
        ]
      });
    }).on("mousemove", function(o, c) {
      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: o,
        element: D(this),
        datum: c
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: o
      });
    }).on("click", function(o, c) {
      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: o,
        element: D(this),
        datum: c
      });
    }).on("mouseout", function(o, c) {
      const l = D(this);
      l.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: o,
        element: l,
        datum: c
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: l
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function ap(i) {
  return i;
}
function rp(i) {
  if (i == null) return ap;
  var t, e, n = i.scale[0], s = i.scale[1], a = i.translate[0], r = i.translate[1];
  return function(o, c) {
    c || (t = e = 0);
    var l = 2, h = o.length, d = new Array(h);
    for (d[0] = (t += o[0]) * n + a, d[1] = (e += o[1]) * s + r; l < h; ) d[l] = o[l], ++l;
    return d;
  };
}
function op(i, t) {
  for (var e, n = i.length, s = n - t; s < --n; ) e = i[s], i[s++] = i[n], i[n] = e;
}
function lp(i, t) {
  return typeof t == "string" && (t = i.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(e) {
    return Dr(i, e);
  }) } : Dr(i, t);
}
function Dr(i, t) {
  var e = t.id, n = t.bbox, s = t.properties == null ? {} : t.properties, a = ta(i, t);
  return e == null && n == null ? { type: "Feature", properties: s, geometry: a } : n == null ? { type: "Feature", id: e, properties: s, geometry: a } : { type: "Feature", id: e, bbox: n, properties: s, geometry: a };
}
function ta(i, t) {
  var e = rp(i.transform), n = i.arcs;
  function s(h, d) {
    d.length && d.pop();
    for (var u = n[h < 0 ? ~h : h], p = 0, f = u.length; p < f; ++p)
      d.push(e(u[p], p));
    h < 0 && op(d, f);
  }
  function a(h) {
    return e(h);
  }
  function r(h) {
    for (var d = [], u = 0, p = h.length; u < p; ++u) s(h[u], d);
    return d.length < 2 && d.push(d[0]), d;
  }
  function o(h) {
    for (var d = r(h); d.length < 4; ) d.push(d[0]);
    return d;
  }
  function c(h) {
    return h.map(o);
  }
  function l(h) {
    var d = h.type, u;
    switch (d) {
      case "GeometryCollection":
        return { type: d, geometries: h.geometries.map(l) };
      case "Point":
        u = a(h.coordinates);
        break;
      case "MultiPoint":
        u = h.coordinates.map(a);
        break;
      case "LineString":
        u = r(h.arcs);
        break;
      case "MultiLineString":
        u = h.arcs.map(r);
        break;
      case "Polygon":
        u = c(h.arcs);
        break;
      case "MultiPolygon":
        u = h.arcs.map(c);
        break;
      default:
        return null;
    }
    return { type: d, coordinates: u };
  }
  return l(t);
}
function cp(i, t) {
  var e = {}, n = {}, s = {}, a = [], r = -1;
  t.forEach(function(l, h) {
    var d = i.arcs[l < 0 ? ~l : l], u;
    d.length < 3 && !d[1][0] && !d[1][1] && (u = t[++r], t[r] = l, t[h] = u);
  }), t.forEach(function(l) {
    var h = o(l), d = h[0], u = h[1], p, f;
    if (p = s[d])
      if (delete s[p.end], p.push(l), p.end = u, f = n[u]) {
        delete n[f.start];
        var g = f === p ? p : p.concat(f);
        n[g.start = p.start] = s[g.end = f.end] = g;
      } else
        n[p.start] = s[p.end] = p;
    else if (p = n[u])
      if (delete n[p.start], p.unshift(l), p.start = d, f = s[d]) {
        delete s[f.end];
        var m = f === p ? p : f.concat(p);
        n[m.start = f.start] = s[m.end = p.end] = m;
      } else
        n[p.start] = s[p.end] = p;
    else
      p = [l], n[p.start = d] = s[p.end = u] = p;
  });
  function o(l) {
    var h = i.arcs[l < 0 ? ~l : l], d = h[0], u;
    return i.transform ? (u = [0, 0], h.forEach(function(p) {
      u[0] += p[0], u[1] += p[1];
    })) : u = h[h.length - 1], l < 0 ? [u, d] : [d, u];
  }
  function c(l, h) {
    for (var d in l) {
      var u = l[d];
      delete h[u.start], delete u.start, delete u.end, u.forEach(function(p) {
        e[p < 0 ? ~p : p] = 1;
      }), a.push(u);
    }
  }
  return c(s, n), c(n, s), t.forEach(function(l) {
    e[l < 0 ? ~l : l] || a.push([l]);
  }), a;
}
function up(i) {
  for (var t = -1, e = i.length, n, s = i[e - 1], a = 0; ++t < e; ) n = s, s = i[t], a += n[0] * s[1] - n[1] * s[0];
  return Math.abs(a);
}
function hp(i) {
  return ta(i, dp.apply(this, arguments));
}
function dp(i, t) {
  var e = {}, n = [], s = [];
  t.forEach(a);
  function a(c) {
    switch (c.type) {
      case "GeometryCollection":
        c.geometries.forEach(a);
        break;
      case "Polygon":
        r(c.arcs);
        break;
      case "MultiPolygon":
        c.arcs.forEach(r);
        break;
    }
  }
  function r(c) {
    c.forEach(function(l) {
      l.forEach(function(h) {
        (e[h = h < 0 ? ~h : h] || (e[h] = [])).push(c);
      });
    }), n.push(c);
  }
  function o(c) {
    return up(ta(i, { type: "Polygon", arcs: [c] }).coordinates[0]);
  }
  return n.forEach(function(c) {
    if (!c._) {
      var l = [], h = [c];
      for (c._ = 1, s.push(l); c = h.pop(); )
        l.push(c), c.forEach(function(d) {
          d.forEach(function(u) {
            e[u < 0 ? ~u : u].forEach(function(p) {
              p._ || (p._ = 1, h.push(p));
            });
          });
        });
    }
  }), n.forEach(function(c) {
    delete c._;
  }), {
    type: "MultiPolygon",
    arcs: s.map(function(c) {
      var l = [], h;
      if (c.forEach(function(g) {
        g.forEach(function(m) {
          m.forEach(function(v) {
            e[v < 0 ? ~v : v].length < 2 && l.push(v);
          });
        });
      }), l = cp(i, l), (h = l.length) > 1)
        for (var d = 1, u = o(l[0]), p, f; d < h; ++d)
          (p = o(l[d])) > u && (f = l[0], l[0] = l[d], l[d] = f, u = p);
      return l;
    }).filter(function(c) {
      return c.length > 0;
    })
  };
}
class Tm extends qo {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = at.SVG;
  }
  showRuler(t, [e, n]) {
    const s = this.parent, a = this.model.getOptions(), { cartesianScales: r } = this.services, o = r.getOrientation(), c = r.getRangeScale(), [l, h] = c.range(), d = r.getDomainScale(), u = d.invert(
      o === Xt.VERTICAL ? e : n
    ), p = I.appendOrSelect(s, "g.ruler").attr("aria-label", "ruler"), f = I.appendOrSelect(p, "line.ruler-line"), m = s.selectAll("[role=graphics-symbol]").filter((v) => {
      if (parseFloat(xt(v, "data.x0")) <= u && parseFloat(xt(v, "data.x1")) >= u)
        return !0;
    });
    if (m.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !co(this.elementsToHighlight, m) && this.hideRuler(), m.dispatch("mouseover"), this.elementsToHighlight = m;
      const v = D(m.nodes()[0]).datum(), S = parseFloat(xt(v, "data.x0")), y = parseFloat(xt(v, "data.x1")), E = this.model.getActiveDataGroupNames(), x = E.reverse().map((k) => ({
        label: k,
        value: xt(v, `data.${k}`),
        class: this.model.getColorClassName({
          classNameTypes: [nt.TOOLTIP],
          dataGroupName: k
        })
      })).filter((k) => k.value !== 0);
      if (x.length > 0) {
        this.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: t,
          mousePosition: [e, n],
          hoveredElement: f,
          items: [
            {
              label: xt(a, "bins.rangeLabel") || "Range",
              value: `${S} – ${y}`
            },
            ...x,
            ...O(a, "tooltip", "showTotal") === !0 ? [
              {
                label: xt(a, "locale.translations.total") || xt(a, "tooltip.totalLabel") || "Total",
                value: E.reduce(
                  (_, G) => _ + parseFloat(xt(v, `data.${G}`)),
                  0
                )
              }
            ] : []
          ]
        }), p.attr("opacity", 1);
        const k = d((S + y) / 2);
        o === "horizontal" ? f.attr("x1", h).attr("x2", l).attr("y1", k).attr("y2", k) : f.attr("y1", h).attr("y2", l).attr("x1", k).attr("x2", k);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class Om extends qo {
  formatTooltipData(t) {
    return t.reverse();
  }
}
const Lm = (i, t) => {
  const e = i.x, n = i.y, s = t.x, a = t.y, r = As();
  return r.moveTo(e, n), r.lineTo(s, a), r.toString();
}, Am = (i, t, e = 0.5) => {
  const n = i.x, s = i.y, a = t.x, r = t.y, o = As();
  return o.moveTo(n, s), o.lineTo(n + (a - n) * e, s), o.lineTo(n + (a - n) * e, r), o.lineTo(a, r), o.toString();
}, Mm = (i, t, e, n, s, a) => {
  const r = i.x, o = i.y, c = t.x, l = t.y, h = As();
  return h.moveTo(r, o), h.bezierCurveTo(e, n, s, a, c, l), h.toString();
}, wm = {
  d: "M7 0v8L0 4z",
  height: 8,
  width: 7.5,
  id: "arrowLeft"
}, Cm = {
  d: "M0 0v8l7-4z",
  height: 8,
  width: 7.5,
  id: "arrowRight"
}, km = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z",
  height: 10,
  width: 10,
  id: "circle"
}, _m = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z",
  height: 10,
  width: 10,
  id: "diamond"
}, Im = {
  d: "M0 .44974747h8v8H0v-3.6830331z",
  height: 9,
  width: 8,
  id: "square"
}, Rm = {
  d: "M0 0h1.5v8H0z",
  height: 8,
  width: 2,
  id: "tee"
};
class Dm extends Dd {
  constructor(t, e, n) {
    super(t, e, n), this.type = "color-legend", this.renderType = at.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const s = this.getComponentContainer(), { width: a } = I.getSVGElementSize(s, {
        useAttrs: !0
      }), r = O(this.getOptions(), "data", "loading");
      if (a > Mt.color.barWidth && !r) {
        const o = O(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: c } = this.services, h = c.getMainXScale().range();
        if (h[0] > 1 && (s.select("g.legend").attr("transform", `translate(${h[0]}, 0)`), o)) {
          const { width: d } = I.getSVGElementSize(
            s.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), u = h[0] - d - 9;
          u > 1 ? s.select("g.legend-title").attr("transform", `translate(${u}, 0)`) : (s.select("g.legend").attr("transform", `translate(${h[0]}, 16)`), s.select("g.legend-title").attr("transform", `translate(${h[0]}, 0)`));
        }
      } else
        s.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = n.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(T.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = this.getComponentContainer({
      ariaLabel: "legend"
    }), { width: s } = I.getSVGElementSize(n, {
      useAttrs: !0
    }), a = O(e, "color", "gradient", "colors"), r = O(e, this.chartType, "colorLegend", "type");
    let o = O(e, "color", "pairing", "option");
    const c = O(e, "heatmap", "colorLegend", "title");
    if (O(this.getOptions(), "data", "loading")) {
      n.html("");
      return;
    }
    const h = !Wr(a), d = ml(this.model.getDisplayData()), u = !(s <= Mt.color.barWidth), p = u ? Mt.color.barWidth : s, f = I.appendOrSelect(n, "g.legend"), g = I.appendOrSelect(f, "g.legend-axis");
    if (c) {
      const R = I.appendOrSelect(n, "g.legend-title");
      I.appendOrSelect(R, "text").text(c).attr("dy", "0.7em"), f.attr("transform", "translate(0, 16)");
    }
    const m = d[0] < 0 && d[1] > 0 ? "diverge" : "mono";
    (o < 1 && o > 4 && m === "mono" || o < 1 && o > 2 && m === "diverge") && (o = 1);
    let v = [];
    const S = m === "diverge" ? 17 : 11;
    if (h)
      v = a;
    else
      for (let R = 1; R < S + 1; R++)
        v.push(
          r === Vs.LINEAR ? `stop-color-${m}-${o}-${R}` : `fill-${m}-${o}-${R}`
        );
    const y = Xr(d[0], d[1]), E = Hc(y, 3), x = Re().domain(d).range([0, p]), b = Fi(x).tickSize(0).tickValues(E), { code: k, number: _ } = O(e, "locale");
    b.tickFormat((R) => _(R, k));
    let G;
    switch (r) {
      case Vs.LINEAR:
        this.drawLinear(v, f, p);
        break;
      case Vs.QUANTIZE:
        G = this.drawQuantize(
          v,
          m,
          h,
          f,
          p
        ), x.range([G, p]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    g.attr("transform", `translate(0,${Mt.color.axisYTranslation})`).call(b), g.select(".domain").remove(), g.select("g.tick:last-of-type text").style("text-anchor", u ? "middle" : "end"), g.select("g.tick:first-of-type text").style(
      "text-anchor",
      u && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(t, e, n) {
    const s = 100 / (t.length - 1);
    I.appendOrSelect(e, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(t).enter().append("stop").attr("offset", (o, c) => `${c * s}%`).attr("class", (o, c) => t[c]).attr("stop-color", (o) => o), I.appendOrSelect(e, "rect").attr("width", n).attr("height", Mt.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(t, e, n, s, a) {
    !n && e === "diverge" && t.splice(t.length / 2, 1);
    const r = zi().domain(t).range([0, a]);
    return I.appendOrSelect(s, "g.quantized-rect").selectAll("rect").data(r.domain()).join("rect").attr("x", (c) => r(c)).attr("y", 0).attr("width", Math.max(0, r.bandwidth() - 1)).attr("height", Mt.color.barHeight).attr("class", (c) => c).attr("fill", (c) => c), (!n && e) === "mono" ? r.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(T.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
}
class Nm extends Rd {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = at.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = O(this.model.getDisplayData(), 0), n = this.getOptions(), s = this.getComponentContainer({
      ariaLabel: "meter title"
    }), { groupMapsTo: a } = n.data, r = n.locale.translations.meter.title;
    if (O(n, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const h = s.selectAll("text.meter-title").data(r ? [r] : [e[a]]);
      h.enter().append("text").classed("meter-title", !0).merge(h).attr("x", 0).attr("y", "1em").text((d) => d), h.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const c = this.getMaxTitleWidth(), l = I.appendOrSelect(s, "text.meter-title");
    c > 0 && l.node().getComputedTextLength() > c && this.truncateTitle(l, c);
  }
  displayBreakdownTitle() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = this.model.getMaximumDomain(
      this.model.getDisplayData()
    ), s = O(e, "meter", "proportional", "total"), a = O(e, "meter", "proportional", "unit") ? O(e, "meter", "proportional", "unit") : "";
    let r;
    if (n === s)
      r = null;
    else {
      const h = s !== null ? s - n : n, d = O(e, "meter", "proportional", "breakdownFormatter"), { code: u, number: p } = O(e, "locale");
      r = d !== null ? d({
        datasetsTotal: n,
        total: s
      }) : `${p(n, u)} ${a} used (${p(h, u)} ${a} available)`;
    }
    const o = t.selectAll("text.proportional-meter-title").data([r]);
    o.enter().append("text").classed("proportional-meter-title", !0).merge(o).attr("x", 0).attr("y", "1em").text((h) => h), o.exit().remove();
    const c = this.getMaxTitleWidth(), l = I.appendOrSelect(t, "text.proportional-meter-title");
    c > 0 && l.node().getComputedTextLength() > c && this.truncateTitle(l, c);
  }
  // show the total for prop meter
  displayTotal() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = O(e, "meter", "proportional", "total"), s = n ? O(e, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), a = O(e, "meter", "proportional", "unit") ? O(e, "meter", "proportional", "unit") : "", r = O(e, "meter", "proportional", "totalFormatter"), { code: o, number: c } = O(e, "locale"), l = r !== null ? r(s) : `${c(n, o)} ${a} total`, h = I.getHTMLElementSize(this.parent.node()).width, d = t.selectAll("text.proportional-meter-total").data([l]);
    d.enter().append("text").classed("proportional-meter-total", !0).merge(d).attr(
      "x",
      this.model.getStatus() && typeof h != "string" ? h - _t.total.paddingRight : h
    ).attr("y", "1em").attr("text-anchor", "end").text((u) => u), d.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const t = this, e = this.getComponentContainer(), n = I.getHTMLElementSize(this.parent.node()).width || 0, s = this.model.getStatus(), a = _t.status.indicatorSize / 2, r = I.appendOrSelect(e, "g.status-indicator").attr("class", s !== null ? `status-indicator status--${s}` : "").attr("transform", `translate(${n - a}, 0)`), o = s ? [s] : [], c = r.selectAll("circle.status").data(o);
    c.enter().append("circle").merge(c).attr("class", "status").attr("r", a).attr("cx", 0).attr("cy", 8);
    const l = r.selectAll("path.innerFill").data(o);
    l.enter().append("path").merge(l).attr("d", t.getStatusIconPathString(s)).attr("transform", `translate(-${a}, 0)`).attr("class", "innerFill"), l.exit().remove(), c.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const t = O(this.model.getDisplayData(), 0, "value"), { code: e, number: n } = O(this.getOptions(), "locale"), s = this.getComponentContainer(), a = I.appendOrSelect(s, "text.meter-title"), r = O(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [t] : [], o = s.selectAll("text.percent-value").data(r), c = _t.statusBar.paddingRight;
    o.enter().append("text").classed("percent-value", !0).merge(o).text((l) => `${l != null ? n(l, e) : 0}%`).attr("x", +a.attr("x") + a.node().getComputedTextLength() + c).attr("y", a.attr("y")), o.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param maxWidth the max width the title can take
   */
  truncateTitle(t, e) {
    super.truncateTitle(t, e);
    const n = I.appendOrSelect(this.parent, "tspan"), s = _t.statusBar.paddingRight, a = Math.ceil(n.node().getComputedTextLength());
    I.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +t.attr("x") + t.node().getComputedTextLength() + a + s
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const t = O(this.getOptions(), "meter", "proportional"), e = I.getHTMLElementSize(this.parent.node()).width;
    if (t !== null) {
      const n = I.appendOrSelect(this.parent, "text.proportional-meter-total").node(), s = I.getSVGElementSize(n, {
        useBBox: !0
      }).width;
      return e - s - _t.total.paddingLeft;
    } else {
      const n = I.appendOrSelect(this.parent, "text.percent-value"), s = _t.statusBar.paddingRight, a = n.node().getComputedTextLength(), r = I.appendOrSelect(this.parent, "g.status-indicator").node(), o = I.getSVGElementSize(r, { useBBox: !0 }).width + _t.status.paddingLeft;
      return e - a - s - o;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(t) {
    switch (t) {
      case Gs.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case Gs.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case Gs.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class ea extends dt {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions();
    if (t.bars.width)
      return t.bars.width;
    const e = this.model.getDisplayData().length, n = this.services.cartesianScales.getMainXScale(), s = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!n.step) {
      const a = O(t, "bars", "spacingFactor");
      return Math.min(t.bars.maxWidth, s * a / e);
    }
    return Math.min(t.bars.maxWidth, n.step() / 2);
  }
  isOutsideZoomedDomain(t, e) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const s = this.model.get("zoomDomain");
    if (s !== void 0) {
      const a = this.services.cartesianScales.getDomainScale();
      return t < a(s[0]) || e > a(s[1]);
    }
    return !1;
  }
}
class Pm extends dt {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (n) => n.data.dataGroupName === e.datum().name ? 1 : hn.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "circle packs",
      withinChartClip: !0
    }), { width: n, height: s } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    let a = this.model.getDisplayData();
    const r = this.model.hasParentNode(), o = this.model.getHierarchyLevel(), c = this.getOptions(), l = O(c, "canvasZoom", "enabled");
    r && O(a, 0, "children") && (a = O(a, 0, "children"));
    const h = Dn({ children: a }).sum((g) => g.value).sort((g, m) => m.value - g.value), u = Rh().size([n, s]).padding((g) => g.depth >= 1 ? hn.padding.children + 3 : hn.padding.mainGroup + 3)(h).descendants().splice(1).filter((g) => g.depth <= o), p = e.selectAll("circle.node").data(u);
    p.exit().attr("width", 0).attr("height", 0).remove();
    const f = p.enter().append("circle").classed("node", !0);
    f.merge(p).attr("class", (g) => {
      const m = l && o === 3 ? this.getZoomClass(g) : "";
      return this.model.getColorClassName({
        classNameTypes: [nt.FILL, nt.STROKE],
        dataGroupName: g.data.dataGroupName,
        originalClassName: g.children ? `node ${m}` : `node node-leaf ${m}`
      });
    }).style("fill", (g) => this.model.getFillColor(g.data.dataGroupName, null, g.data)).style("stroke", (g) => this.model.getFillColor(g.data.dataGroupName, null, g.data)).attr("cx", (g) => g.x).attr("cy", (g) => g.y).transition("circlepack-leaf-update-enter").call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (g) => g.r).attr("opacity", 1).attr("fill-opacity", hn.circles.fillOpacity), l === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, f, Hn), this.setBackgroundListeners()), r || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(t) {
    const e = t.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => e.some((s) => s === n.data) && n.depth > 1).style("stroke", (n) => this.model.getFillColor(n.data.dataGroupName, null, n.data));
  }
  // highlight the children circles with a stroke
  highlightChildren(t) {
    const e = t.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => e.some((s) => s === n.data) && n.depth > 1).style("stroke", hn.circles.hover.stroke);
  }
  getZoomClass(t) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (t.data === this.focal.data || this.focal.children.some((e) => e.data === t.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    D(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const t = D(this.services.domUtils.getMainContainer()), e = this, n = this.parent.selectAll("circle.node");
    t.on("click", () => {
      e.focal = null, e.model.updateHierarchyLevel(2), t.classed("zoomed-in", !1), e.services.canvasZoom.zoomOut(n, Hn);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const t = this;
    this.parent.selectAll("circle.node").on("mouseover", function(e, n) {
      const s = D(this);
      s.classed("hovered", !0);
      const a = t.model.getHierarchyLevel(), r = a > 2 && !s.classed("focal"), o = O(t.model.getOptions(), "canvasZoom", "enabled");
      let c = !1;
      if (!r) {
        let l = [], h = [], d = null;
        if (n.children) {
          n.depth > 1 && o && (c = !0, s.classed("clickable", !0)), l = n.children.map((f) => {
            if (f !== null)
              return typeof f.data.value == "number" ? {
                label: f.data.name,
                value: f.data.value
              } : {
                label: f.data.name,
                labelIcon: o && a <= 2 ? t.getZoomIcon() : null,
                value: f.value
              };
          });
          const p = t.model.getOptions();
          h = [
            {
              label: xt(p, "locale.translations.total") || xt(p, "tooltip.totalLabel") || "Total",
              value: n.value,
              bold: !0
            }
          ], t.highlightChildren(n.children);
        } else
          d = n.value;
        const u = getComputedStyle(this, null).getPropertyValue("fill");
        t.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: e,
          hoveredElement: s,
          items: [
            {
              color: u,
              label: n.data.name,
              labelIcon: c && o && a <= 2 ? t.getZoomIcon() : null,
              value: d
            },
            ...l,
            ...h
          ]
        });
      }
      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEOVER, {
        event: e,
        element: s,
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: e
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      s.classed("hovered", !1), n.children && t.unhighlightChildren(n.children), t.services.events.dispatchEvent(T.CirclePack.CIRCLE_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: s
      });
    }).on("click", function(e, n) {
      const s = D(this), a = s.classed("non-focal"), r = O(t.model.getOptions(), "canvasZoom", "enabled");
      if (r && t.model.getHierarchyLevel() > 2) {
        const o = t.parent.selectAll("circle.node");
        D(t.services.domUtils.getMainContainer()).classed("zoomed-in", !1), t.focal = null, t.model.updateHierarchyLevel(2), t.services.canvasZoom.zoomOut(o, Hn);
      } else if (n.depth === 2 && n.children && !a && r) {
        const o = t.parent.selectAll("circle.node");
        D(t.services.domUtils.getMainContainer()).classed("zoomed-in", !0), t.focal = n, t.model.updateHierarchyLevel(3), t.services.canvasZoom.zoomIn(n, o, Hn), e.stopPropagation();
      }
      t.services.events.dispatchEvent(T.CirclePack.CIRCLE_CLICK, {
        event: e,
        element: s,
        datum: n
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function pp(i, t) {
  const e = Fr(this._current, i);
  return (n) => (this._current = e(n), t(this._current));
}
class fp extends dt {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = at.SVG, this.isRendering = !1, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (s) => s.data[n] !== e.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return Et.innerRadius;
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer({
      ariaLabel: "pie graph"
    }), s = this.getOptions(), { groupMapsTo: a } = s.data, { valueMapsTo: r } = s.pie;
    this.isRendering = !0;
    const o = this.model.getDisplayData().filter((M) => M[r] > 0), c = this.computeRadius();
    this.arc = Rn().innerRadius(this.getInnerRadius()).outerRadius(c), this.hoverArc = Rn().innerRadius(this.getInnerRadius()).outerRadius(c + Et.hoverArc.outerRadiusOffset);
    const h = ed().value((M) => M[r]).sort(O(s, "pie", "sortFunction")).padAngle(Et.padAngle)(o), u = I.appendOrSelect(n, "g.slices").attr("role", lt.GROUP).attr("data-name", "slices").selectAll("path.slice").data(h, (M) => M.data[a]);
    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(u).attr(
      "class",
      (M) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: M.data[a],
        originalClassName: "slice"
      })
    ).style("fill", (M) => e.model.getFillColor(M.data[a], null, M.data)).attr("d", this.arc).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "pie_slice_enter_update",
        animate: t
      })
    ).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr("aria-label", (M) => [
      M[r],
      Ps(M.data[r], o, r) + "%",
      M.data[a]
    ].filter(Boolean).join(", ")).attrTween("d", function(M) {
      return pp.bind(this)(M, e.arc);
    }).on("end", () => {
      e.isRendering = !1;
    });
    const { code: g, number: m } = O(s, "locale"), v = s.pie.labels.enabled, S = v ? h.filter((M) => M.data[r] > 0) : [], E = I.appendOrSelect(n, "g.labels").attr("role", lt.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(S, (M) => M.data[a]);
    E.exit().attr("opacity", 0).remove();
    const x = E.enter().append("text").classed("pie-label", !0), b = [];
    x.merge(E).style("text-anchor", "middle").text((M) => s.pie.labels.formatter ? s.pie.labels.formatter({
      ...M,
      percentageValue: Ps(
        M.data[r],
        o,
        r,
        !0
      )
    }) : m(
      Ps(M.data[r], o, r),
      g
    ) + "%").datum(function(M) {
      const L = c + 7, P = (M.endAngle - M.startAngle) / 2 + M.startAngle, $ = P / Math.PI * 180, C = this.getComputedTextLength();
      return M.textOffsetX = C / 2, M.textOffsetY = $ > 90 && $ < 270 ? 10 : 0, M.xPosition = (M.textOffsetX + L) * Math.sin(P), M.yPosition = (M.textOffsetY + L) * -Math.cos(P), M;
    }).attr("transform", function(M, L) {
      const P = S.length, $ = (M.endAngle - M.startAngle) * (180 / Math.PI);
      if (L >= P - 2 && $ < Et.callout.minSliceDegree) {
        let C, V;
        return M.index === P - 1 ? (C = M.xPosition + Et.callout.offsetX + Et.callout.textMargin + M.textOffsetX, V = M.yPosition - Et.callout.offsetY, M.direction = Hs.RIGHT, b.push(M)) : (C = M.xPosition - Et.callout.offsetX - M.textOffsetX - Et.callout.textMargin, V = M.yPosition - Et.callout.offsetY, M.direction = Hs.LEFT, b.push(M)), `translate(${C}, ${V})`;
      }
      return `translate(${M.xPosition}, ${M.yPosition})`;
    }), this.renderCallouts(b);
    const k = O(s, "donut") ? "donut" : "pie", _ = O(s, k, "alignment"), { width: G } = I.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), R = v ? Et.xOffset : 0, A = v ? Et.yOffset : 0;
    let H = c + R;
    _ === te.CENTER ? H = G / 2 : _ === te.RIGHT && (H = G - c - Et.xOffset);
    let N = c + A;
    b.length > 0 && (N += Et.yOffsetCallout), n.attr("x", H + 7).attr("y", N), this.addEventListeners();
  }
  renderCallouts(t) {
    const e = I.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", lt.GROUP).attr("data-name", "callouts"), n = e.selectAll("g.callout").data(t);
    n.exit().remove();
    const s = n.enter().append("g").classed("callout", !0).attr("role", lt.GROUP).attr("aria-roledescription", "label callout");
    s.merge(n).datum(function(o) {
      const { xPosition: c, yPosition: l, direction: h } = o;
      return h === Hs.RIGHT ? (o.startPos = {
        x: c,
        y: l + o.textOffsetY
      }, o.endPos = {
        x: c + Et.callout.offsetX,
        y: l - Et.callout.offsetY + o.textOffsetY
      }, o.intersectPointX = o.endPos.x - Et.callout.horizontalLineLength) : (o.startPos = {
        x: c,
        y: l + o.textOffsetY
      }, o.endPos = {
        x: c - Et.callout.offsetX,
        y: l - Et.callout.offsetY + o.textOffsetY
      }, o.intersectPointX = o.endPos.x + Et.callout.horizontalLineLength), o;
    }), s.append("line").classed("vertical-line", !0).merge(e.selectAll("line.vertical-line")).datum(function() {
      return D(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (o) => o.startPos.x).attr("y1", (o) => o.startPos.y).attr("x2", (o) => o.intersectPointX).attr("y2", (o) => o.endPos.y), s.append("line").classed("horizontal-line", !0).merge(e.selectAll("line.horizontal-line")).datum(function() {
      return D(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (o) => o.intersectPointX).attr("y1", (o) => o.endPos.y).attr("x2", (o) => o.endPos.x).attr("y2", (o) => o.endPos.y);
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.slice").on("mouseover", function(e, n) {
      const s = D(this);
      t.isRendering || s.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "pie_slice_mouseover"
        })
      ).attr("d", t.hoverArc), t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEOVER, {
        event: e,
        element: D(this),
        datum: n
      });
      const { groupMapsTo: a } = t.getOptions().data, { valueMapsTo: r } = t.getOptions().pie;
      t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: e,
        hoveredElement: s,
        items: [
          {
            label: n.data[a],
            value: n.data[r]
          }
        ]
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(T.Pie.SLICE_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      bc(() => {
        t.isRendering || s.classed("hovered", !1).transition("pie_slice_mouseout").call(
          (a) => t.services.transitions.setupTransition({
            transition: a,
            name: "pie_slice_mouseout"
          })
        ).attr("d", t.arc);
      }, 100), t.services.events.dispatchEvent(T.Pie.SLICE_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: t, height: e } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), n = this.getOptions(), s = Math.min(t, e) / 2;
    return n.pie.labels.enabled ? s + Et.radiusOffset : s;
  }
}
class $m extends fp {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = at.SVG;
  }
  render(t = !0) {
    super.render(t);
    const e = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer({
        ariaLabel: "donut graph"
      }).select("g.center").remove();
      return;
    }
    const n = I.appendOrSelect(
      this.getComponentContainer({
        ariaLabel: "donut graph"
      }),
      "g.center"
    ), s = this.getOptions(), a = this.computeRadius(), r = O(s, "donut", "center", "label");
    I.appendOrSelect(n, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => r === null || r === "" ? "central" : "initial").style("font-size", () => s.donut.center.numberFontSize(a)).transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "donut-figure-enter-update",
        animate: t
      })
    ).tween("text", function() {
      return e.centerNumberTween(D(this));
    }), r !== null && r !== "" && I.appendOrSelect(n, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => s.donut.center.titleFontSize(a)).attr("y", s.donut.center.titleYPosition(a)).text(r);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(t) {
    const e = this.getOptions();
    let n = O(e, "donut", "center", "number");
    n === null && (n = this.model.getDisplayData().reduce((o, c) => o + c[e.pie.valueMapsTo], 0));
    const s = parseInt(t.text().replace(/[, ]+/g, ""), 10) || 0;
    let a;
    s % 1 === 0 && n % 1 === 0 ? a = vl : a = Xr;
    const r = a(s, n);
    return (o) => {
      const { numberFormatter: c } = e.donut.center;
      if (c)
        t.text(c(r(o)));
      else {
        const { code: l, number: h } = O(e, "locale");
        t.text(h(Math.floor(r(o)), l));
      }
    };
  }
}
const Nr = "4,10 8,6 12,10", Pr = "12,6 8,10 4,6";
class Vm extends dt {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = at.SVG;
  }
  getValue() {
    var n;
    return ((n = this.model.getData().find((s) => s.group === "value")) == null ? void 0 : n.value) ?? null;
  }
  getValueRatio() {
    return lo(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    var n;
    return ((n = this.model.getData().find((s) => s.group === "delta")) == null ? void 0 : n.value) ?? null;
  }
  getArcRatio() {
    const t = this.getOptions();
    return O(t, "gauge", "type") === zn.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const t = this.getArcSize();
    return t === 2 * Math.PI ? 0 : -t / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(t) {
    const e = this.getOptions();
    switch (O(e, "gauge", "deltaArrow", "direction")) {
      case Oa.UP:
        return Nr;
      case Oa.DOWN:
        return Pr;
      default:
        return t > 0 ? Nr : Pr;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "gauge graph"
    }).attr("width", "100%").attr("height", "100%"), n = this.getOptions(), s = this.getValue(), a = this.getValueRatio(), r = this.getArcSize(), o = this.getStartAngle(), c = a * r, l = o + c, h = o + r, d = this.computeRadius(), u = this.getInnerRadius();
    this.backgroundArc = Rn().innerRadius(u).outerRadius(d).startAngle(l).endAngle(h), this.arc = Rn().innerRadius(u).outerRadius(d).startAngle(o).endAngle(l), I.appendOrSelect(e, "path.arc-background").attr("d", this.backgroundArc);
    const p = e.selectAll("path.arc-foreground").data([s]);
    p.enter().append("path").merge(p).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => O(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (S) => S), this.drawValueNumber(), this.drawDelta(), p.exit().remove();
    const g = O(n, "gauge", "alignment"), { width: m } = I.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let v = d;
    g === te.CENTER ? v = m / 2 : g === te.RIGHT && (v = m - d), e.attr("x", v).attr("y", d), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = O(e, "gauge", "type"), s = this.getValue(), a = this.getDelta(), r = this.computeRadius(), o = O(e, "gauge", "valueFontSize"), c = O(e, "gauge", "deltaFontSize"), l = O(e, "gauge", "numberSpacing"), h = O(e, "gauge", "showPercentageSymbol");
    let d = 0;
    n === zn.FULL && !a ? d = c(r) : n === zn.SEMI && a && (d = -(c(r) + l));
    const u = I.appendOrSelect(t, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${d})`
    ), p = o(r), f = I.appendOrSelect(u, "g.gauge-value-number"), { code: g, number: m } = O(e, "locale"), v = O(e, "gauge", "numberFormatter"), S = f.selectAll("text.gauge-value-number").data([s]);
    S.enter().append("text").attr("class", "gauge-value-number").merge(S).style("font-size", `${p}px`).attr("text-anchor", "middle").text((G) => {
      let R;
      return G != null ? R = Number(G.toFixed(2)) % 1 !== 0 ? G.toFixed(2) : G.toFixed() : R = 0, v ? v(R) : m(Number(R), g);
    });
    const { width: y } = I.getSVGElementSize(
      I.appendOrSelect(t, "text.gauge-value-number"),
      { useBBox: !0 }
    ), E = p / 2, x = h ? "%" : "", b = I.appendOrSelect(f, "text.gauge-value-symbol").style("font-size", `${E}px`).attr("x", y / 2).text(x), { width: k, height: _ } = I.getSVGElementSize(b, {
      useBBox: !0
    });
    b.attr("y", `-${_ / 2}px`), f.attr("transform", `translate(-${k / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const t = this, e = this.getComponentContainer(), n = this.getOptions(), s = this.getDelta(), { code: a, number: r } = O(n, "locale");
    if (s) {
      const o = this.computeRadius(), c = s ? O(n, "gauge", "deltaFontSize") : () => 0, l = s ? O(n, "gauge", "numberFormatter") : () => null, h = O(n, "gauge", "deltaArrow", "size"), d = O(n, "gauge", "numberSpacing"), u = O(n, "gauge", "showPercentageSymbol"), p = I.appendOrSelect(e, "g.gauge-numbers"), f = I.appendOrSelect(p, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${c(o) + d})`
      ), g = I.appendOrSelect(f, "text.gauge-delta-number"), m = u ? "%" : "";
      g.data(s === null ? [] : [s]), g.enter().append("text").classed("gauge-delta-number", !0).merge(g).attr("text-anchor", "middle").style("font-size", `${c(o)}px`).text((E) => {
        let x;
        return E != null ? x = Number(E.toFixed(2)) % 1 !== 0 ? E.toFixed(2) : E.toFixed() : x = 0, l ? `${l(x)}${m}` : `${r(Number(x), a)}${m}`;
      });
      const { width: v } = I.getSVGElementSize(
        I.appendOrSelect(e, ".gauge-delta-number"),
        { useBBox: !0 }
      ), S = O(n, "gauge", "deltaArrow", "enabled"), y = f.selectAll("svg.gauge-delta-arrow").data(s !== null && S ? [s] : []);
      y.enter().append("svg").merge(y).attr("class", "gauge-delta-arrow").attr("x", -h(o) - v / 2).attr("y", -h(o) / 2 - c(o) * 0.35).attr("width", h(o)).attr("height", h(o)).attr("viewBox", "0 0 16 16").each(function() {
        const E = D(this);
        I.appendOrSelect(E, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const x = O(n, "gauge", "status");
        I.appendOrSelect(E, "polygon.gauge-delta-arrow").attr("class", x !== null ? `gauge-delta-arrow status--${x}` : "").attr("points", t.getArrow(s));
      }), y.exit().remove(), g.exit().remove();
    } else {
      const o = e.select("g.gauge-delta");
      o.empty() || o.remove();
    }
  }
  getInnerRadius() {
    const t = this.computeRadius(), e = O(this.getOptions(), "gauge", "arcWidth");
    return t - e;
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(e, n) {
      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEOVER, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(T.Gauge.ARC_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(T.Gauge.ARC_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      });
    });
  }
  // Helper functions
  computeRadius() {
    const t = this.getOptions(), e = O(t, "gauge", "type"), { width: n, height: s } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return e === zn.SEMI ? Math.min(n / 2, s) : Math.min(n / 2, s / 2);
  }
}
class Gm extends ea {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = at.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.model.getDisplayData(this.configs.groups), n = this.getOptions(), { groupMapsTo: s } = n.data;
    this.setGroupScale();
    const a = this.getComponentContainer({ ariaLabel: "grouped bar graphs", withinChartClip: !0 }), r = yl(
      e.map((u) => {
        const p = this.services.cartesianScales.getDomainIdentifier(u);
        return u[p] && typeof u[p].toString == "function" ? u[p].toString() : u[p];
      })
    ), o = a.selectAll("g.bars").data(r, (u) => u);
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("bars", !0).attr("role", lt.GROUP).attr("data-name", "bars").merge(o);
    l.transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-group-update-enter",
        animate: t
      })
    ).attr("transform", (u) => {
      const f = this.services.cartesianScales.getDomainValue(u) - this.getGroupWidth() / 2;
      return this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? `translate(${f}, 0)` : `translate(0, ${f})`;
    });
    const h = l.selectAll("path.bar").data(
      (u) => this.getDataCorrespondingToLabel(u),
      (u) => u[s]
    );
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).classed("bar", !0).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: u[s],
        originalClassName: "bar"
      })
    ).style("fill", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[s], u[p], u);
    }).attr("d", (u) => {
      const p = this.groupScale(u[s]), f = this.getBarWidth(), g = p, m = p + f, v = this.services.cartesianScales.getRangeAxisPosition({ datum: u }), S = this.services.cartesianScales.getDomainLowerBound(v), y = this.services.cartesianScales.getValueThroughAxisPosition(v, S), E = this.services.cartesianScales.getRangeValue(u), x = this.services.cartesianScales.getDomainValue(u) - f / 2, b = x + f;
      if (!this.isOutsideZoomedDomain(x, b))
        return Gt(
          { x0: g, x1: m, y0: y, y1: E },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => u.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(e, n) {
      const s = D(this);
      s.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: e,
        hoveredElement: s,
        data: [n]
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      s.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(t) {
    return this.model.getDisplayData(this.configs.groups).filter((n) => {
      const s = this.services.cartesianScales.getDomainIdentifier(n);
      return n[s].toString() === t;
    });
  }
  getGroupWidth() {
    const t = this.model.getGroupedData(this.configs.groups), e = this.getTotalGroupPadding();
    return this.getBarWidth() * t.length + e;
  }
  getDomainScaleStep() {
    const t = this.services.cartesianScales.getDomainScale(), e = this.model.getGroupedData(this.configs.groups);
    let n = this.defaultStepFactor;
    if (typeof t.step == "function")
      n = t.step();
    else if (e.length > 0) {
      const s = e.find((a) => {
        var r;
        return ((r = a.data) == null ? void 0 : r.length) > 1;
      });
      if (s) {
        const a = this.services.cartesianScales.getDomainIdentifier(s.data[0]);
        n = Math.abs(
          t(s.data[1][a]) - t(s.data[0][a])
        );
      }
    }
    return n;
  }
  getTotalGroupPadding() {
    const t = this.model.getGroupedData(this.configs.groups);
    return t.length === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (t.length - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions(), e = O(t, "bars", "width"), n = O(t, "bars", "maxWidth");
    if (e !== null && (n === null || e <= n))
      return e;
    const a = this.model.getGroupedData(this.configs.groups).length, r = this.getTotalGroupPadding();
    return Math.min(
      n,
      (this.getDomainScaleStep() - r) / a
    );
  }
  setGroupScale() {
    const t = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = zi().domain(t).rangeRound([0, this.getGroupWidth()]);
  }
}
class Hm extends dt {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = at.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (t) => {
      const { detail: e } = t, { datum: n } = e, s = this.model.getUniqueRanges(), a = this.model.getUniqueDomain(), r = this.services.cartesianScales.getDomainLabel(), o = this.services.cartesianScales.getRangeLabel(), c = this.services.cartesianScales.getMainXScale(), l = this.services.cartesianScales.getMainYScale();
      let h = "", d = null, u = null, p = null;
      this.matrix[n] !== void 0 ? (h = r, s.forEach((f) => {
        if (typeof this.matrix[n][f].value == "number") {
          const g = this.matrix[n][f].value;
          if (d === null) {
            d = g, u = g, p = g;
            return;
          }
          d += g, u = g < u ? g : u, p = g > p ? g : p;
        }
      })) : (h = o, a.forEach((f) => {
        if (typeof this.matrix[f][n].value == "number") {
          const g = this.matrix[f][n].value;
          if (d === null) {
            d = g, u = g, p = g;
            return;
          }
          d += g, u = g < u ? g : u, p = g > p ? g : p;
        }
      })), c(n) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${c(n)}, ${pi(l.range())})`) : l(n) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${pi(c.range())},${l(n)})`), this.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: e.event,
        hoveredElement: D(t.detail.element),
        items: [
          {
            label: h,
            value: n,
            bold: !0
          },
          {
            label: "Min",
            value: u !== null ? u : "-"
          },
          {
            label: "Max",
            value: p !== null ? p : "-"
          },
          {
            label: "Average",
            value: d !== null ? d / a.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (t) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(T.Tooltip.HIDE, {
        event: t
      });
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), t.addEventListener(T.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), t.addEventListener(T.Axis.LABEL_FOCUS, this.handleAxisOnHover), t.addEventListener(T.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({ ariaLabel: "heatmap", withinChartClip: !0 });
    e.lower();
    const { cartesianScales: n } = this.services;
    if (this.matrix = this.model.getMatrix(), e.html(""), O(this.getOptions(), "data", "loading"))
      return;
    const s = n.getMainXScale(), a = n.getMainYScale(), r = n.getDomainIdentifier(), o = n.getRangeIdentifier(), c = this.model.getUniqueDomain(), l = this.model.getUniqueRanges(), h = this.model.getMatrixAsArray(), d = s.range(), u = a.range();
    this.xBandwidth = Math.abs((d[1] - d[0]) / c.length), this.yBandwidth = Math.abs((u[1] - u[0]) / l.length);
    const p = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    e.append("defs").append("pattern").attr("id", p).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const f = e.selectAll().data(h).enter().append("g").attr("class", (g) => `heat-${g.index}`).classed("cell", !0).attr(
      "transform",
      (g) => `translate(${s(g[r])}, ${a(g[o])})`
    ).append("rect").attr(
      "class",
      (g) => this.model.getColorClassName({
        value: g.value,
        originalClassName: `heat-${g.index}`
      })
    ).classed("heat", !0).classed("null-state", (g) => g.index === -1 || g.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (g) => {
      const m = this.services.cartesianScales.getDomainIdentifier(g);
      return g.index === -1 || g.value === null ? `url(#${p})` : this.model.getFillColor(Number(g.value), g[m], g);
    }).attr("aria-label", (g) => g.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(u[1] - u[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(d[1] - d[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (f.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(t, e, n) {
    const s = I.appendOrSelect(this.parent, t).classed("shadows", !0).classed("highlighter-hidden", !0);
    I.appendOrSelect(s, "line.top").attr("x1", -1).attr("x2", e + 1), I.appendOrSelect(s, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", n + 1), I.appendOrSelect(s, "line.down").attr("x1", -1).attr("x2", e + 1).attr("y1", n).attr("y2", n), I.appendOrSelect(s, "line.right").attr("x1", e).attr("x2", e).attr("y1", -1).attr("y2", n + 1);
  }
  determineDividerStatus() {
    const t = O(this.getOptions(), "heatmap", "divider", "state");
    return t !== Bs.OFF && (t === Bs.AUTO && Sa.minCellDividerDimension <= this.xBandwidth && Sa.minCellDividerDimension <= this.yBandwidth || t === Bs.ON);
  }
  addEventListener() {
    const t = this, { cartesianScales: e } = this.services, n = this.getOptions(), s = xt(n, "locale.translations.total") || xt(n, "tooltip.totalLabel") || "Total", a = e.getDomainIdentifier(), r = e.getRangeIdentifier(), o = e.getDomainLabel(), c = e.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(l, h) {
      const d = D(this), u = d.select("rect.heat");
      if (!u.classed("null-state")) {
        const f = yn(d.attr("transform"));
        t.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${f.x + t.translationUnits.x}, ${f.y + t.translationUnits.y})`
        ).classed("highlighter-hidden", !1), t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEOVER, {
          event: l,
          element: u,
          datum: h
        }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
          event: l,
          items: [
            {
              label: o,
              value: h[a]
            },
            {
              label: c,
              value: h[r]
            },
            {
              label: s,
              value: h.value,
              color: u.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(l, h) {
      t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEMOVE, {
        event: l,
        element: D(this),
        datum: h
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l, h) {
      t.services.events.dispatchEvent(T.Heatmap.HEATMAP_CLICK, {
        event: l,
        element: D(this),
        datum: h
      });
    }).on("mouseout", function(l, h) {
      const u = D(this).select("rect.heat"), p = u.classed("null-state");
      t.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), p || (t.services.events.dispatchEvent(T.Heatmap.HEATMAP_MOUSEOUT, {
        event: l,
        element: u,
        datum: h
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        event: l,
        hoveredElement: u
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleAxisOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class Bm extends dt {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (a) => a[s] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({
      ariaLabel: "histogram bars"
    }), n = this.model.getOptions(), { groupIdentifier: s } = n, { groupMapsTo: a } = n.data, r = this.model.getBinnedStackedData(), o = this.services.cartesianScales.getMainXScale(), c = e.selectAll("g.bars").data(r, (h) => xt(h, `0.${a}`));
    c.exit().attr("opacity", 0).remove(), c.enter().append("g").classed("bars", !0).attr("role", lt.GROUP);
    const l = e.selectAll("g.bars").selectAll("path.bar").data((h) => h);
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).attr(s, (h, d) => d).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "histogram-bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: h[a],
        originalClassName: "bar"
      })
    ).style("fill", (h) => this.model.getFillColor(h[a], null, h)).attr("d", (h) => {
      const d = xt(h, "data");
      if (!d)
        return;
      const u = o(d.x1) - o(d.x0) - 1, p = this.services.cartesianScales.getDomainValue(d.x0), f = p + u, g = this.services.cartesianScales.getRangeValue(h[0]);
      let m = this.services.cartesianScales.getRangeValue(h[1]);
      return Math.abs(m - g) > 0 && Math.abs(m - g) > n.bars.dividerSize && (this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? m += 1 : m -= 1), Gt(
        { x0: p, x1: f, y0: g, y1: m },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (h) => O(h, "data", h[a])), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.model.getOptions(), { groupMapsTo: e } = t.data, { code: n, number: s } = O(t, "locale"), a = this;
    this.parent.selectAll("path.bar").on("mouseover", function(r, o) {
      const c = D(this);
      c.classed("hovered", !0);
      const l = s(parseFloat(xt(o, "data.x0")), n), h = s(parseFloat(xt(o, "data.x1")), n), d = a.services.cartesianScales.getRangeAxisPosition(), u = a.services.cartesianScales.getScaleLabel(d);
      a.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: r,
        hoveredElement: c,
        items: [
          {
            label: xt(t, "bins.rangeLabel") || "Range",
            value: `${l} – ${h}`
          },
          {
            label: t.tooltip.groupLabel || "Group",
            value: o[e],
            class: a.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP],
              dataGroupName: o[e]
            })
          },
          {
            label: u,
            value: xt(o, `data.${o[e]}`)
          }
        ]
      });
    }).on("mousemove", function(r) {
      a.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: r
      });
    }).on("mouseout", function() {
      D(this).classed("hovered", !1), a.services.events.dispatchEvent(T.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class zm extends Qi {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = at.SVG, this.handleScatterOnHover = (t) => {
      const e = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("line.line").attr("stroke-width", (a) => a[s] !== e.datum[s] ? ve.weight.unselected : ve.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", ve.weight.unselected);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-line"
        })
      ).attr("opacity", (a) => a[s] !== e.datum().name ? ve.opacity.unselected : ve.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ve.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({ ariaLabel: "lines", withinChartClip: !0 }), n = this.model.getOptions(), { groupMapsTo: s } = n.data, { cartesianScales: a } = this.services, r = a.getMainXScale(), o = a.getMainYScale(), c = a.getDomainIdentifier(), l = (v) => a.getDomainValue(v), h = (v) => a.getRangeValue(v), d = a.getOrientation(), [u, p] = xe(
      l,
      h,
      d
    ), f = e.selectAll("line.line").data(
      this.getScatterData(),
      (v) => `${v[s]}-${v[c]}`
    );
    f.exit().attr("opacity", 0).remove();
    const m = f.enter().append("line").attr("opacity", 0).merge(f).classed("line", !0).attr(
      "class",
      (v) => this.model.getColorClassName({
        classNameTypes: [nt.STROKE],
        dataGroupName: v[s],
        originalClassName: "line"
      })
    ).transition().call(
      (v) => this.services.transitions.setupTransition({
        transition: v,
        name: "lollipop-line-update-enter",
        animate: t
      })
    ).style("stroke", (v) => this.model.getFillColor(v[s], v[c], v)).attr("opacity", 1);
    d === Xt.HORIZONTAL ? m.attr("y1", p).attr("y2", p).attr("x1", r.range()[0]).attr("x2", (v) => u(v) - n.points.radius) : m.attr("x1", u).attr("x2", u).attr("y1", o.range()[0]).attr("y2", (v) => p(v) + n.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      T.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      T.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(T.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), t.removeEventListener(
      T.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class Um extends dt {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = at.SVG;
  }
  getStackedBounds(t, e) {
    let n = 0;
    return t.map((a, r) => r !== 0 ? (n += e(a.value), {
      ...a,
      width: Math.abs(e(a.value) - _t.dividerWidth),
      x: n - e(a.value)
    }) : (n = e(a.value), {
      ...a,
      width: Math.abs(e(a.value) - _t.dividerWidth),
      x: 0
    }));
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer({
      ariaLabel: "meter lines"
    }), s = this.getOptions(), a = O(s, "meter", "proportional"), r = this.model.getDisplayData(), o = this.model.getStatus(), { width: c } = I.getSVGElementSize(n, {
      useAttrs: !0
    }), { groupMapsTo: l } = s.data;
    let h;
    if (O(s, "meter", "proportional") === null)
      h = 100;
    else {
      const y = O(s, "meter", "proportional", "total");
      h = y || this.model.getMaximumDomain(this.model.getDisplayData());
    }
    const d = Re().domain([0, h]).range([0, c]), u = this.getStackedBounds(r, d), p = O(s, "meter", "height");
    I.appendOrSelect(n, "rect.container").attr("x", 0).attr("y", 0).attr("width", c).attr(
      "height",
      p || (a ? _t.height.proportional : _t.height.default)
    ), I.appendOrSelect(n, "line.rangeIndicator").attr("x1", c).attr("x2", c).attr("y1", 0).attr(
      "y2",
      p || (a ? _t.height.proportional : _t.height.default)
    );
    const f = n.selectAll("rect.value").data(u), g = o != null && !e.model.isUserProvidedColorScaleValid() && !a ? `value status--${o}` : "value";
    f.enter().append("rect").classed("value", !0).merge(f).attr("x", (y) => y.x).attr("y", 0).attr("height", () => p || (a ? _t.height.proportional : _t.height.default)).attr(
      "class",
      (y) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: y[l],
        originalClassName: g
      })
    ).transition().call(
      (y) => this.services.transitions.setupTransition({
        transition: y,
        name: "meter-bar-update",
        animate: t
      })
    ).attr("width", (y) => y.value > h ? d(h) : Math.max(y.width, 2)).style("fill", (y) => e.model.getFillColor(y[l], null, y)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (y) => y.value), f.exit().remove();
    const m = O(s, "meter", "peak");
    let v = m;
    m !== null && (m > h ? v = h : m < 0 && (v = 0));
    const S = n.selectAll("line.peak").data(v == null ? [] : [v]);
    S.enter().append("line").classed("peak", !0).merge(S).attr("y1", 0).attr("y2", () => p || (a ? _t.height.proportional : _t.height.default)).transition().call(
      (y) => this.services.transitions.setupTransition({
        transition: y,
        name: "peak-line-update",
        animate: t
      })
    ).attr("x1", (y) => d(y)).attr("x2", (y) => d(y)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (y) => y), S.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this, s = O(t, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(T.Meter.METER_MOUSEOVER, {
        event: a,
        element: o,
        datum: r
      }), s && (o.classed("hovered", !0), n.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        items: [
          {
            label: r[e],
            value: r.value
          }
        ]
      }));
    }).on("mousemove", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(T.Meter.METER_MOUSEMOVE, {
        event: a,
        element: o,
        datum: r
      }), s && n.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, r) {
      n.services.events.dispatchEvent(T.Meter.METER_CLICK, {
        event: a,
        element: D(this),
        datum: r
      });
    }).on("mouseout", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(T.Meter.METER_MOUSEOUT, {
        event: a,
        element: o,
        datum: r
      }), s && (o.classed("hovered", !1), n.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: o
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class Fm extends dt {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = at.SVG, this.getLabelDimensions = (t) => {
      const e = I.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), n = I.appendOrSelect(e, "text").text(t), { width: s, height: a } = I.getSVGElementSize(n.node(), { useBBox: !0 });
      return e.remove(), { width: s, height: a };
    }, this.normalizeFlatData = (t) => {
      const e = this.getOptions(), { angle: n, value: s } = O(e, "radar", "axes"), a = O(e, "data", "groupMapsTo"), r = Ac(
        this.uniqueKeys.map((o) => this.uniqueGroups.map((c) => ({
          [n]: o,
          [a]: c,
          [s]: null
        })))
      );
      return nn(r, t);
    }, this.normalizeGroupedData = (t) => {
      const e = this.getOptions(), { angle: n, value: s } = O(e, "radar", "axes"), a = O(e, "data", "groupMapsTo");
      return t.map(({ name: r, data: o }) => {
        const c = this.uniqueKeys.map((l) => ({
          [a]: r,
          [n]: l,
          [s]: null
        }));
        return { name: r, data: nn(c, o) };
      });
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (n) => n.name !== e.datum().name ? Ae.opacity.unselected : Ae.opacity.selected).style("stroke-opacity", (n) => n.name !== e.datum().name ? Ae.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", Ae.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "radar graph"
    }), { width: n, height: s } = I.getSVGElementSize(e, {
      useAttrs: !0
    }), a = this.model.getData(), r = this.model.getGroupedData(), o = this.getOptions(), c = O(o, "data", "groupMapsTo"), l = O(o, "radar", "axes", "value"), { angle: h, value: d } = O(o, "radar", "axes"), { xLabelPadding: u, yLabelPadding: p, yTicksNumber: f, minRange: g, xAxisRectHeight: m } = Ae;
    this.uniqueKeys = Array.from(new Set(a.map((z) => z[h]))), this.uniqueGroups = Array.from(new Set(a.map((z) => z[c]))), this.fullDataNormalized = this.normalizeFlatData(a), this.groupedDataNormalized = this.normalizeGroupedData(r);
    const S = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + p), x = (Math.min(n, s) - S) / 2;
    if (x <= 0)
      return;
    const b = zi().domain(this.fullDataNormalized.map((z) => z[h])).range([0, 2 * Math.PI].map((z) => z - Math.PI / 2)), k = pi(this.fullDataNormalized.map((z) => z[d])), _ = Re().domain([
      k >= 0 ? 0 : k,
      ba(this.fullDataNormalized.map((z) => z[d]))
    ]).range([g, x]).nice(f), G = _.ticks(f), R = (z, B, U) => this.model.getFillColor(z, B, U), A = id().angle((z) => b(z[h]) + Math.PI / 2).radius((z) => _(z[d])).curve(Al), H = this.uniqueKeys.map((z) => {
      const B = this.getLabelDimensions(z).width, U = Ml(
        b(z),
        x
      );
      return B + U;
    }), M = {
      x: ba(H) + u,
      y: s / 2
    }, P = I.appendOrSelect(e, "g.y-axes").attr("role", lt.GROUP).selectAll("path").data(G, (z) => z), $ = (z) => this.uniqueKeys.map((B) => ({ [h]: B, [d]: z }));
    P.join(
      (z) => z.append("path").attr("opacity", 0).attr("transform", `translate(${M.x}, ${M.y})`).attr("fill", "none").call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("d", (U) => A($(U)))
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${M.x}, ${M.y})`).attr("d", (U) => A($(U)))
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_axes_exit",
            animate: t
          })
        ).attr("d", (U) => A($(U))).attr("opacity", 0).remove()
      )
    ), I.appendOrSelect(e, "g.x-axes").attr("role", lt.GROUP).selectAll("line").data(this.uniqueKeys, (z) => z).join(
      (z) => z.append("line").attr("opacity", 0).attr("class", (B) => `x-axis-${Fe(B)}`).attr("stroke-dasharray", "0").attr("x1", (B) => Tt(b(B), 0, M).x).attr("y1", (B) => Tt(b(B), 0, M).y).attr("x2", (B) => Tt(b(B), 0, M).x).attr("y2", (B) => Tt(b(B), 0, M).y).call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (U) => Tt(b(U), _.range()[0], M).x).attr("y1", (U) => Tt(b(U), _.range()[0], M).y).attr("x2", (U) => Tt(b(U), _.range()[1], M).x).attr("y2", (U) => Tt(b(U), _.range()[1], M).y)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (U) => Tt(b(U), _.range()[0], M).x).attr("y1", (U) => Tt(b(U), _.range()[0], M).y).attr("x2", (U) => Tt(b(U), _.range()[1], M).x).attr("y2", (U) => Tt(b(U), _.range()[1], M).y)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_axes_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), I.appendOrSelect(e, "g.x-labels").attr("role", lt.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (z) => z.append("text").text((B) => B).attr("opacity", 0).attr(
        "x",
        (B) => Tt(b(B), _.range()[1] + u, M).x
      ).attr(
        "y",
        (B) => Tt(b(B), _.range()[1] + u, M).y
      ).style("text-anchor", (B) => ka(b(B)).textAnchor).style(
        "dominant-baseline",
        (B) => ka(b(B)).dominantBaseline
      ).call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_labels_update",
            animate: t
          })
        ).attr("opacity", 1).attr(
          "x",
          (U) => Tt(b(U), _.range()[1] + u, M).x
        ).attr(
          "y",
          (U) => Tt(b(U), _.range()[1] + u, M).y
        ).end().finally(() => {
          const U = O(o, "radar", "alignment"), wt = this.getAlignmentXOffset(U, e, this.getParent());
          e.attr("x", wt);
        })
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_x_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), I.appendOrSelect(e, "g.blobs").attr("role", lt.GROUP).selectAll("path").data(this.groupedDataNormalized, (z) => z.name).join(
      (z) => z.append("path").attr(
        "class",
        (B) => this.model.getColorClassName({
          classNameTypes: [nt.FILL, nt.STROKE],
          dataGroupName: B.name,
          originalClassName: "blob"
        })
      ).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-label", (B) => B.name).attr("opacity", 0).attr(
        "transform",
        t ? () => `translate(${M.x}, ${M.y}) scale(${1 + Math.random() * 0.35})` : `translate(${M.x}, ${M.y})`
      ).style("fill", (B) => R(B.name, null, B.data)).style("fill-opacity", Ae.opacity.selected).style("stroke", (B) => R(B.name, null, B.data)).call((B) => {
        const U = B.transition().call(
          (wt) => this.services.transitions.setupTransition({
            transition: wt,
            name: "radar_blobs_enter",
            animate: t
          })
        );
        t && U.delay(() => Math.random() * 30).attr("transform", `translate(${M.x}, ${M.y})`), U.attr("opacity", 1).attr("d", (wt) => A(wt.data));
      }),
      (z) => (z.attr(
        "class",
        (B) => this.model.getColorClassName({
          classNameTypes: [nt.FILL, nt.STROKE],
          dataGroupName: B.name,
          originalClassName: "blob"
        })
      ).style("fill", (B) => R(B.name, null, B.data)).style("stroke", (B) => R(B.name, null, B.data)), z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_blobs_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${M.x}, ${M.y})`).attr("d", (U) => A(U.data))
      ), z),
      (z) => z.call((B) => {
        const U = B.transition().call(
          (wt) => this.services.transitions.setupTransition({
            transition: wt,
            name: "radar_blobs_exit",
            animate: t
          })
        );
        t && U.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${M.x}, ${M.y}) scale(${1 + Math.random() * 0.35})`
        ), U.attr("opacity", 0).remove();
      })
    ), I.appendOrSelect(e, "g.dots").attr("role", lt.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((z) => O(z, d) !== null)).join(
      (z) => z.append("circle").attr("role", lt.GRAPHICS_SYMBOL).attr("aria-label", (B) => B[l]),
      (z) => z,
      (z) => z.remove()
    ).attr(
      "class",
      (z) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: z[c],
        originalClassName: Fe(z[h])
      })
    ).attr("cx", (z) => Tt(b(z[h]), _(z[d]), M).x).attr("cy", (z) => Tt(b(z[h]), _(z[d]), M).y).attr("r", 0).attr("opacity", 0).style("fill", (z) => R(z[c])), I.appendOrSelect(e, "g.x-axes-rect").attr("role", lt.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (z) => z.append("rect"),
      (z) => z,
      (z) => z.remove()
    ).attr("x", M.x).attr("y", M.y - m / 2).attr("width", _.range()[1]).attr("height", m).style("fill", "red").style("fill-opacity", 0).attr("transform", (z) => `rotate(${wl(b(z))}, ${M.x}, ${M.y})`);
    const { code: ot, number: ct } = O(o, "locale");
    I.appendOrSelect(e, "g.y-labels").attr("role", lt.GROUP).selectAll("text").data(Os(G)).join(
      (z) => z.append("text").attr("opacity", 0).text((B) => ct(B, ot)).attr(
        "x",
        (B) => Tt(-Math.PI / 2, _(B), M).x + p
      ).attr("y", (B) => Tt(-Math.PI / 2, _(B), M).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_labels_update",
            animate: t
          })
        ).text((U) => U).attr("opacity", 1).attr(
          "x",
          (U) => Tt(-Math.PI / 2, _(U), M).x + p
        ).attr("y", (U) => Tt(-Math.PI / 2, _(U), M).y)
      ),
      (z) => z.call(
        (B) => B.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_y_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(t, e, n) {
    const s = I.getSVGElementSize(e, {
      useBBox: !0
    }), { width: a } = I.getSVGElementSize(n, {
      useAttrs: !0
    });
    let r = 0;
    return t === te.CENTER ? r = Math.floor((a - s.width) / 2) : t === te.RIGHT && (r = a - s.width), r;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const t = this, {
      axes: { angle: e }
    } = O(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEOVER, {
        event: n,
        element: a,
        datum: s
      });
      const r = t.parent.select(`.x-axes .x-axis-${Fe(s)}`), o = t.parent.selectAll(`.dots circle.${Fe(s)}`), c = t.model.getActiveDataGroupNames(), l = t.getOptions(), { groupMapsTo: h } = l.data, d = O(l, "radar", "axes", "value");
      r.classed("hovered", !0).attr("stroke-dasharray", "4 4"), o.classed("hovered", !0).attr(
        "opacity",
        (p) => c.indexOf(p[h]) !== -1 ? 1 : 0
      ).attr("r", Ae.dotsRadius);
      const u = t.fullDataNormalized.filter(
        (p) => p[e] === s && c.indexOf(p[h]) !== -1
      );
      t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: n,
        hoveredElement: a,
        items: u.filter((p) => typeof p[d] == "number").map((p) => ({
          label: p[h],
          value: p[d],
          color: t.model.getFillColor(p[h], null, p),
          class: t.model.getColorClassName({
            classNameTypes: [nt.TOOLTIP],
            dataGroupName: p[h]
          })
        }))
      });
    }).on("mousemove", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEMOVE, {
        event: n,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      t.services.events.dispatchEvent(T.Radar.X_AXIS_CLICK, {
        event: n,
        element: D(this),
        datum: s
      });
    }).on("mouseout", function(n, s) {
      const a = D(this), r = t.parent.select(`.x-axes .x-axis-${Fe(s)}`), o = t.parent.selectAll(`.dots circle.${Fe(s)}`);
      r.classed("hovered", !1).attr("stroke-dasharray", "0"), o.classed("hovered", !1).attr("opacity", 0).attr("r", 0), t.services.events.dispatchEvent(T.Radar.X_AXIS_MOUSEOUT, {
        event: n,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE);
    });
  }
}
class Wm extends ea {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getOptions(), { groupMapsTo: n } = e.data, s = this.getComponentContainer({
      ariaLabel: "bar graphs",
      withinChartClip: !0
    }), a = this.model.getDisplayData(this.configs.groups), r = this.services.cartesianScales.getOrientation(), o = s.selectAll("path.bar").data(a, (l) => l[n]);
    o.exit().attr("opacity", 0).remove(), o.enter().append("path").attr("opacity", 0).merge(o).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: l[n],
        originalClassName: "bar"
      })
    ).style("fill", (l) => {
      const h = this.services.cartesianScales.getDomainIdentifier(l);
      return this.model.getFillColor(l[n], l[h], l);
    }).attr("d", (l) => {
      const h = this.services.cartesianScales.getRangeIdentifier(), d = this.getBarWidth(), u = l[h], p = this.services.cartesianScales.getDomainValue(l) - d / 2, f = p + d;
      let g, m;
      if (Array.isArray(u) && u.length === 2)
        g = this.services.cartesianScales.getRangeValue(u[0]), m = this.services.cartesianScales.getRangeValue(u[1]);
      else {
        const y = this.services.cartesianScales.getRangeScale().domain()[0];
        g = this.services.cartesianScales.getRangeValue(Math.max(0, y)), m = this.services.cartesianScales.getRangeValue(l);
      }
      const v = Math.abs(m - g);
      if (v !== 0 && v < 2 && (u > 0 && r === Xt.VERTICAL || u < 0 && r === Xt.HORIZONTAL ? m = g - 2 : m = g + 2), !this.isOutsideZoomedDomain(p, f))
        return Gt({ x0: p, x1: f, y0: g, y1: m }, r);
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(e, n) {
      const s = D(this);
      s.classed("hovered", !0), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: e,
        hoveredElement: s,
        data: [n]
      });
    }).on("mousemove", function(e, n) {
      t.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: e,
        element: D(this),
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      s.classed("hovered", !1), t.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Xm extends ip {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = O(this.getOptions(), "data", "loading"), n = !O(this.getOptions(), "grid", "x", "enabled") && !O(this.getOptions(), "grid", "y", "enabled") && !O(this.getOptions(), "axes", "bottom", "visible") && !O(this.getOptions(), "axes", "left", "visible");
    e && !n ? super.renderGridSkeleton(e) : e && n ? this.renderSparklineSkeleton(e) : this.removeSkeleton();
  }
  renderSparklineSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawSparkline(t), this.updateBackdropStyle(), t && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(t) {
    const e = this.backdrop.attr("width"), n = [100], s = I.appendOrSelect(this.backdrop, "g.y.skeleton"), a = s.selectAll("line").data(n);
    a.enter().append("line").merge(a).attr("x1", 0).attr("x2", e).attr("y1", (r) => r).attr("y2", (r) => r), s.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const t = this.parent;
    this.backdrop = I.appendOrSelect(t, "svg.chart-skeleton.DAII").attr(
      "role",
      "presentation"
    ), I.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class Ym extends dt {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: s } = n.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "legend-hover-area"
        })
      ).attr("opacity", (a) => O(a, 0, s) !== e.datum().name ? ye.opacity.unselected : ye.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", ye.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "stacked area graphs",
      withinChartClip: !0
    }), n = this, s = this.getOptions(), { groupMapsTo: a } = s.data, r = Object.keys(s.axes).some((f) => s.axes[f].percentage), o = this.model.getStackedData({
      percentage: r,
      groups: this.configs.groups
    }), c = O(o, 0, 0), l = this.services.cartesianScales.getDomainAxisPosition({ datum: c }), h = this.services.cartesianScales.getRangeAxisPosition({ datum: c }), d = this.services.cartesianScales.getScaleByPosition(h), u = e.selectAll("path.area").data(o, (f) => O(f, 0, a));
    this.areaGenerator = Ki().x(
      (f) => this.services.cartesianScales.getValueThroughAxisPosition(
        l,
        f.data.sharedStackKey
      )
    ).y0((f) => d(f[0])).y1((f) => d(f[1])).curve(this.services.curves.getD3Curve()), u.exit().attr("opacity", 0).remove(), u.enter().append("path").attr("opacity", 0).merge(u).data(o, (f) => O(f, 0, a)).attr("class", "area").attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: O(f, 0, a),
        originalClassName: "area"
      })
    ).style("fill", (f) => n.model.getFillColor(O(f, 0, a), null, f)).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (f) => O(f, 0, a)).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", ye.opacity.selected).attr("d", this.areaGenerator);
  }
}
class Zm extends ea {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({ ariaLabel: "stacked bar graphs", withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: s } = n.data, a = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), r = this.model.getActiveDataGroupNames(), o = e.selectAll("g.bars").data(a, (l) => O(l, 0, s));
    o.exit().attr("opacity", 0).remove(), o.enter().append("g").classed("bars", !0).attr("role", lt.GROUP).attr("data-name", "bars");
    const c = e.selectAll("g.bars").selectAll("path.bar").data(
      (l) => l,
      (l) => l.data.sharedStackKey
    );
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: l[s],
        originalClassName: "bar"
      })
    ).style(
      "fill",
      (l) => this.model.getFillColor(l[s], l.data.sharedStackKey, l.data)
    ).attr("d", (l) => {
      const h = l.data.sharedStackKey, d = this.getBarWidth(), u = this.services.cartesianScales.getDomainValue(h) - d / 2, p = u + d, f = this.services.cartesianScales.getRangeValue(l[0]);
      let g = this.services.cartesianScales.getRangeValue(l[1]);
      if (!this.isOutsideZoomedDomain(u, p)) {
        if (Math.abs(g - f) > 0 && Math.abs(g - f) > n.bars.dividerSize) {
          const m = l[0] < 0 && l[1] <= 0;
          m && r.length > 1 ? this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? g += l[1] === 0 ? 2 : 1 : g -= 1 : m || (this.services.cartesianScales.getOrientation() === Xt.VERTICAL ? g += 1 : g -= 1);
        }
        return Gt(
          { x0: u, x1: p, y0: f, y1: g },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", lt.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l[1] - l[0]), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this;
    this.parent.selectAll("path.bar").on("mouseover", function(s, a) {
      const r = D(this);
      r.classed("hovered", !0), n.services.events.dispatchEvent(T.Bar.BAR_MOUSEOVER, {
        event: s,
        element: r,
        datum: a
      });
      let c = n.model.getDisplayData(n.configs.groups).find((l) => {
        const h = n.services.cartesianScales.getDomainIdentifier(l), d = n.services.cartesianScales.getRangeIdentifier(l);
        return l[d] === a.data[a[e]] && l[h].toString() === a.data.sharedStackKey && l[e] === a[e];
      });
      if (c === void 0) {
        const l = n.services.cartesianScales.getDomainIdentifier(), h = n.services.cartesianScales.getRangeIdentifier();
        c = {
          [l]: a.data.sharedStackKey,
          [h]: a.data[a[e]],
          [e]: a[e]
        };
      }
      n.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: s,
        hoveredElement: r,
        data: [c]
      });
    }).on("mousemove", function(s, a) {
      const r = D(this);
      n.services.events.dispatchEvent(T.Bar.BAR_MOUSEMOVE, {
        event: s,
        element: r,
        datum: a
      }), n.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      n.services.events.dispatchEvent(T.Bar.BAR_CLICK, {
        event: s,
        element: D(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const r = D(this);
      r.classed("hovered", !1), n.services.events.dispatchEvent(T.Bar.BAR_MOUSEOUT, {
        event: s,
        element: r,
        datum: a
      }), n.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  getBarWidth() {
    const t = this.getOptions();
    if (O(t, "bars", "width"))
      return t.bars.width;
    const e = this.services.cartesianScales.getMainXScale(), n = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, s = this.model.getStackKeys().length, a = O(t, "bars", "spacingFactor");
    return e.step ? Math.min(t.bars.maxWidth, e.step() / 2) : Math.min(t.bars.maxWidth, n * a / s);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class qm extends Qi {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = at.SVG;
  }
  render(t) {
    if (!O(this.getOptions(), "points", "enabled"))
      return;
    const n = this.getComponentContainer({ ariaLabel: "scatter points", withinChartClip: !0 }), s = this.getOptions(), { groupMapsTo: a } = s.data, r = Object.keys(s.axes).some((p) => s.axes[p].percentage), o = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: r
    }), c = n.selectAll("g.dots").data(o, (p) => O(p, 0, a));
    c.exit().attr("opacity", 0).remove();
    const h = c.enter().append("g").classed("dots", !0).attr("role", lt.GROUP).merge(c).selectAll("circle.dot").data((p) => p);
    h.exit().attr("opacity", 0).remove();
    const u = h.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(h).datum((p) => {
      const f = p[a], g = this.services.cartesianScales.getDomainIdentifier(p), m = this.services.cartesianScales.getRangeIdentifier(p);
      return {
        [a]: f,
        [g]: p.data.sharedStackKey,
        [m]: p[1]
      };
    });
    this.styleCircles(u, t), this.addEventListeners();
  }
  getTooltipData(t, e) {
    const n = this.getOptions(), { groupMapsTo: s } = n.data, a = Object.keys(n.axes).some((c) => n.axes[c].percentage), r = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: a
    }), o = [];
    return r.forEach((c, l) => {
      c.forEach((h, d) => {
        const u = h[s], p = h.data.sharedStackKey;
        let f = h.data[u];
        const g = h[1], m = this.services.cartesianScales.getDomainIdentifier(h), v = this.services.cartesianScales.getRangeIdentifier(h);
        f != null && t === this.services.cartesianScales.getDomainValue(p) && e === this.services.cartesianScales.getRangeValue(g) && (a && (f = this.model.getStackedData({
          groups: this.configs.groups
        })[l][d].data[u]), f !== null && o.push({
          [s]: u,
          [m]: p,
          [v]: f
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((c) => {
      const l = this.services.cartesianScales.getDomainIdentifier(c), h = this.services.cartesianScales.getRangeIdentifier(c);
      return o.find((d) => d[s] == c[s] && d[l] == c[l] && d[h] == c[h]) !== void 0;
    });
  }
}
const vn = 6;
class jm extends dt {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = at.SVG;
  }
  getLongestLabel(t) {
    let e = "";
    return t.forEach((n) => {
      const s = n.children ? this.getLongestLabel(n.children) : "";
      (s.length > e.length || n.name.length > e.length) && (e = s.length > n.name.length ? s : n.name);
    }), e;
  }
  getMockLabelWidth(t, e) {
    const n = t.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(e), { width: s } = I.getSVGElementSize(n.node(), {
      useBBox: !0
    });
    return n.remove(), s;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "tree diagram"
    });
    e.html("");
    const { width: n, height: s } = I.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || s < 1)
      return;
    const a = this.model.getOptions(), r = this.model.getDisplayData(), o = O(a, "tree", "rootTitle") || "Tree", c = this.getMockLabelWidth(e, o), l = this.getLongestLabel(r), h = this.getMockLabelWidth(e, l), d = {
      left: c > 0 ? c + vn : 30 - vn
    }, u = Dn({
      name: o,
      children: r
    }), p = 10, f = n / 6, g = (b) => {
      const k = u.descendants().reverse(), _ = u.links();
      let G = u, R = u;
      u.eachBefore((C) => {
        C.x < G.x && (G = C), C.x > R.x && (R = C);
      });
      const A = R.x - G.x, H = e.transition().call(
        (C) => this.services.transitions.setupTransition({
          transition: C,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-d.left, G.x, n, A].join(" ")), N = x.selectAll("g").data(k, (C) => C.id), M = this, L = N.enter().append("g").attr("transform", () => `translate(${b.y0},${b.x0})`).attr(
        "class",
        (C) => C.depth !== 0 && C.children && C.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(C, V) {
        M.services.events.dispatchEvent(T.Tree.NODE_MOUSEOVER, {
          event: C,
          element: D(this),
          datum: V
        });
      }).on("click", function(C, V) {
        V.depth !== 0 && (V.children = V.children ? null : V._children, g(V)), M.services.events.dispatchEvent(T.Tree.NODE_CLICK, {
          event: C,
          element: D(this),
          datum: V
        });
      }).on("mouseout", function(C, V) {
        M.services.events.dispatchEvent(T.Tree.NODE_MOUSEOUT, {
          event: C,
          element: D(this),
          datum: V
        });
      });
      L.append("circle").attr("r", 2.5).attr("class", (C) => C._children ? "parent" : "child").attr("stroke-width", 10), L.append("text").attr("dy", "0.31em").attr("x", (C) => C._children ? -6 : vn).attr("text-anchor", (C) => C._children ? "end" : "start").text((C) => C.data.name).clone(!0).attr("class", "text-stroke").lower(), N.merge(L).transition(H).attr("transform", (C) => `translate(${C.y},${C.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), N.exit().transition(H).remove().attr("transform", () => `translate(${b.y},${b.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const P = E.selectAll("path").data(_, (C) => C.target.id), $ = P.enter().append("path").attr("d", () => {
        const C = { x: b.x0, y: b.y0 };
        return y({ source: C, target: C });
      });
      P.merge($).transition(H).attr("d", y), P.exit().transition(H).remove().attr("d", () => {
        const C = { x: b.x, y: b.y };
        return y({ source: C, target: C });
      }), u.eachBefore((C) => {
        C.x0 = C.x, C.y0 = C.y;
      });
    }, m = u.descendants(), v = m[m.length - 1].depth, S = O(a, "tree", "type") === bl.DENDROGRAM ? th().size([
      s,
      n - h - v * vn - c
    ]) : Bh().nodeSize([p, f]).size([
      s,
      n - h - v * vn - c
    ]), y = ud().x((b) => b.y).y((b) => b.x);
    u.x0 = f / 2, u.y0 = 0, u.descendants().forEach((b, k) => {
      b.id = k, b._children = b.children;
    }), S(u), e.attr("viewBox", [-d.left, -0, n, p]).style("user-select", "none");
    const E = e.append("g").attr("class", "links"), x = e.append("g").attr("class", "nodes");
    g(u);
  }
}
var gp = "#000000", mp = "#ffffff", vp = "#fcf4d6", yp = "#fddc69", Ep = "#f1c21b", xp = "#d2a106", Sp = "#b28600", bp = "#8e6a00", Tp = "#684e00", Op = "#483700", Lp = "#302400", Ap = "#1c1500", Mp = {
  10: vp,
  20: yp,
  30: Ep,
  40: xp,
  50: Sp,
  60: bp,
  70: Tp,
  80: Op,
  90: Lp,
  100: Ap
}, wp = "#fff2e8", Cp = "#ffd9be", kp = "#ffb784", _p = "#ff832b", Ip = "#eb6200", Rp = "#ba4e00", Dp = "#8a3800", Np = "#5e2900", Pp = "#3e1a00", $p = "#231000", Vp = {
  10: wp,
  20: Cp,
  30: kp,
  40: _p,
  50: Ip,
  60: Rp,
  70: Dp,
  80: Np,
  90: Pp,
  100: $p
}, Gp = "#fff1f1", Hp = "#ffd7d9", Bp = "#ffb3b8", zp = "#ff8389", Up = "#fa4d56", Fp = "#da1e28", Wp = "#a2191f", Xp = "#750e13", Yp = "#520408", Zp = "#2d0709", qp = {
  10: Gp,
  20: Hp,
  30: Bp,
  40: zp,
  50: Up,
  60: Fp,
  70: Wp,
  80: Xp,
  90: Yp,
  100: Zp
}, jp = "#fff0f7", Kp = "#ffd6e8", Jp = "#ffafd2", Qp = "#ff7eb6", tf = "#ee5396", ef = "#d02670", nf = "#9f1853", sf = "#740937", af = "#510224", rf = "#2a0a18", of = {
  10: jp,
  20: Kp,
  30: Jp,
  40: Qp,
  50: tf,
  60: ef,
  70: nf,
  80: sf,
  90: af,
  100: rf
}, lf = "#f6f2ff", cf = "#e8daff", uf = "#d4bbff", hf = "#be95ff", df = "#a56eff", pf = "#8a3ffc", ff = "#6929c4", gf = "#491d8b", mf = "#31135e", vf = "#1c0f30", yf = {
  10: lf,
  20: cf,
  30: uf,
  40: hf,
  50: df,
  60: pf,
  70: ff,
  80: gf,
  90: mf,
  100: vf
}, Ef = "#edf5ff", xf = "#d0e2ff", Sf = "#a6c8ff", bf = "#78a9ff", Tf = "#4589ff", Of = "#0f62fe", Lf = "#0043ce", Af = "#002d9c", Mf = "#001d6c", wf = "#001141", Cf = {
  10: Ef,
  20: xf,
  30: Sf,
  40: bf,
  50: Tf,
  60: Of,
  70: Lf,
  80: Af,
  90: Mf,
  100: wf
}, kf = "#e5f6ff", _f = "#bae6ff", If = "#82cfff", Rf = "#33b1ff", Df = "#1192e8", Nf = "#0072c3", Pf = "#00539a", $f = "#003a6d", Vf = "#012749", Gf = "#061727", Hf = {
  10: kf,
  20: _f,
  30: If,
  40: Rf,
  50: Df,
  60: Nf,
  70: Pf,
  80: $f,
  90: Vf,
  100: Gf
}, Bf = "#d9fbfb", zf = "#9ef0f0", Uf = "#3ddbd9", Ff = "#08bdba", Wf = "#009d9a", Xf = "#007d79", Yf = "#005d5d", Zf = "#004144", qf = "#022b30", jf = "#081a1c", Kf = {
  10: Bf,
  20: zf,
  30: Uf,
  40: Ff,
  50: Wf,
  60: Xf,
  70: Yf,
  80: Zf,
  90: qf,
  100: jf
}, Jf = "#defbe6", Qf = "#a7f0ba", tg = "#6fdc8c", eg = "#42be65", ng = "#24a148", sg = "#198038", ig = "#0e6027", ag = "#044317", rg = "#022d0d", og = "#071908", lg = {
  10: Jf,
  20: Qf,
  30: tg,
  40: eg,
  50: ng,
  60: sg,
  70: ig,
  80: ag,
  90: rg,
  100: og
}, cg = "#f2f4f8", ug = "#dde1e6", hg = "#c1c7cd", dg = "#a2a9b0", pg = "#878d96", fg = "#697077", gg = "#4d5358", mg = "#343a3f", vg = "#21272a", yg = "#121619", Eg = {
  10: cg,
  20: ug,
  30: hg,
  40: dg,
  50: pg,
  60: fg,
  70: gg,
  80: mg,
  90: vg,
  100: yg
}, xg = "#f4f4f4", Sg = "#e0e0e0", bg = "#c6c6c6", Tg = "#a8a8a8", Og = "#8d8d8d", Lg = "#6f6f6f", Ag = "#525252", Mg = "#393939", wg = "#262626", Cg = "#161616", kg = {
  10: xg,
  20: Sg,
  30: bg,
  40: Tg,
  50: Og,
  60: Lg,
  70: Ag,
  80: Mg,
  90: wg,
  100: Cg
}, _g = "#f7f3f2", Ig = "#e5e0df", Rg = "#cac5c4", Dg = "#ada8a8", Ng = "#8f8b8b", Pg = "#726e6e", $g = "#565151", Vg = "#3c3838", Gg = "#272525", Hg = "#171414", Bg = {
  10: _g,
  20: Ig,
  30: Rg,
  40: Dg,
  50: Ng,
  60: Pg,
  70: $g,
  80: Vg,
  90: Gg,
  100: Hg
}, $r = {
  black: {
    100: gp
  },
  blue: Cf,
  coolGray: Eg,
  cyan: Hf,
  gray: kg,
  green: lg,
  magenta: of,
  orange: Vp,
  purple: yf,
  red: qp,
  teal: Kf,
  warmGray: Bg,
  white: {
    0: mp
  },
  yellow: Mp
};
const zg = (i) => {
  if (!i)
    return null;
  for (const t of Object.keys($r)) {
    const e = $r[t];
    for (const n of Object.keys(e))
      if (e[+n] === i)
        return n;
  }
  return null;
}, Vr = function(i) {
  const t = D(this.parentNode).select("rect.leaf"), e = i.backgroundColor ?? getComputedStyle(t.node(), null).getPropertyValue("fill"), n = Yr(e);
  let s;
  if (n && (s = zg(n ? n.hex() : null)), s == null) {
    const a = El(n).l;
    s = Math.abs(a * 100 - 100);
  }
  return s > 50 ? "white" : "black";
};
let Ug = 0;
class Km extends dt {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (n) => n.parent.data.name === e.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({
      ariaLabel: "treemap"
    });
    this.model.getData();
    const n = this.model.getDisplayData(), s = this.model.getOptions(), a = O(window, "location"), { width: r, height: o } = I.getSVGElementSize(e, {
      useAttrs: !0
    }), c = Dn({
      name: s.title || "Treemap",
      children: n
    }).sum((g) => g.value).sort((g, m) => m.value - g.value), l = Xh().size([r, o]).paddingInner(1).paddingOuter(0).round(!0)(
      c
    ), h = e.selectAll("g[data-name='leaf']").data(l.leaves(), (g) => g.data.name);
    h.exit().attr("opacity", 0).remove();
    const u = h.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => Ug++).merge(h);
    u.attr("data-name", "leaf").transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "treemap-group-update",
        animate: t
      })
    ).attr("transform", (g) => `translate(${g.x0},${g.y0})`);
    const p = u.selectAll("rect.leaf").data((g) => [g]);
    p.exit().attr("width", 0).attr("height", 0).remove(), p.enter().append("rect").classed("leaf", !0).merge(p).attr("width", 0).attr("height", 0).attr("id", function() {
      const g = D(this.parentNode).attr("data-uid");
      return `${s.style.prefix}-leaf-${g}`;
    }).attr("class", (g) => {
      for (; g.depth > 1; ) g = g.parent;
      return this.model.getColorClassName({
        classNameTypes: [nt.FILL],
        dataGroupName: g.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "treemap-leaf-update-enter",
        animate: t
      })
    ).attr("width", (g) => g.x1 - g.x0).attr("height", (g) => g.y1 - g.y0).style("fill", (g) => {
      for (; g.depth > 1; ) g = g.parent;
      return this.model.getFillColor(g.data.name, null, g.data);
    }), u.selectAll("clipPath").data(
      (g) => g.data.showLabel !== !0 ? [] : [1],
      (g) => g
    ).join(
      (g) => g.append("clipPath").attr("id", function() {
        const m = D(this.parentNode).attr("data-uid");
        return `${s.style.prefix}-clip-${m}`;
      }).append("use").attr("xlink:href", function() {
        const m = D(this.parentNode.parentNode).attr("data-uid"), v = `${s.style.prefix}-leaf-${m}`;
        return new URL(`#${v}`, a) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (g) => null,
      (g) => g.remove()
    ), u.selectAll("text").data(
      (g) => {
        if (g.data.showLabel !== !0)
          return [];
        let m = g;
        for (; m.depth > 1; ) m = m.parent;
        return [
          {
            text: g.data.name,
            backgroundColor: this.model.getFillColor(m.data.name)
          }
        ];
      },
      (g) => g
    ).join(
      (g) => {
        const m = g.append("text").text((v) => v.text).style("fill", Vr).attr("x", 7).attr("y", 18);
        return a && m.attr("clip-path", function() {
          const v = D(this.parentNode).attr("data-uid"), S = `${s.style.prefix}-clip-${v}`;
          return `url(${new URL(`#${S}`, a) + ""})`;
        }), m;
      },
      (g) => g.text((m) => m.text).style("fill", Vr),
      (g) => g.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(e, n) {
      const s = D(this);
      let a = getComputedStyle(this, null).getPropertyValue("fill"), r = n;
      for (; r.depth > 1; ) r = r.parent;
      s.transition("graph_element_mouseover_fill_update").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (o) => {
        const c = t.model.getFillColor(o.parent.data.name, null, o.data);
        return c && (a = c), Yr(a).darker(0.7).toString();
      }), t.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: e,
        hoveredElement: s,
        items: [
          {
            color: a,
            label: r.data.name,
            bold: !0
          },
          {
            label: n.data.name,
            value: n.data.value
          }
        ]
      }), t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEOVER, {
        event: e,
        element: s,
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const s = D(this);
      t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEMOVE, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(T.Treemap.LEAF_CLICK, {
        event: e,
        element: D(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const s = D(this);
      s.classed("hovered", !1);
      let a = n;
      for (; a.depth > 1; ) a = a.parent;
      s.transition().call(
        (r) => t.services.transitions.setupTransition({
          transition: r,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (r) => t.model.getFillColor(r.parent.data.name, null, r.data)), t.services.events.dispatchEvent(T.Treemap.LEAF_MOUSEOUT, {
        event: e,
        element: s,
        datum: n
      }), t.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
}
function Fg(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function Wg(i) {
  if (Object.prototype.hasOwnProperty.call(i, "__esModule")) return i;
  var t = i.default;
  if (typeof t == "function") {
    var e = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(i).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(i, n);
    Object.defineProperty(e, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return i[n];
      }
    });
  }), e;
}
var Xg = { value: function() {
} };
function Ko() {
  for (var i = 0, t = arguments.length, e = {}, n; i < t; ++i) {
    if (!(n = arguments[i] + "") || n in e || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    e[n] = [];
  }
  return new us(e);
}
function us(i) {
  this._ = i;
}
function Yg(i, t) {
  return i.trim().split(/^|\s+/).map(function(e) {
    var n = "", s = e.indexOf(".");
    if (s >= 0 && (n = e.slice(s + 1), e = e.slice(0, s)), e && !t.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    return { type: e, name: n };
  });
}
us.prototype = Ko.prototype = {
  constructor: us,
  on: function(i, t) {
    var e = this._, n = Yg(i + "", e), s, a = -1, r = n.length;
    if (arguments.length < 2) {
      for (; ++a < r; ) if ((s = (i = n[a]).type) && (s = Zg(e[s], i.name))) return s;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++a < r; )
      if (s = (i = n[a]).type) e[s] = Gr(e[s], i.name, t);
      else if (t == null) for (s in e) e[s] = Gr(e[s], i.name, null);
    return this;
  },
  copy: function() {
    var i = {}, t = this._;
    for (var e in t) i[e] = t[e].slice();
    return new us(i);
  },
  call: function(i, t) {
    if ((s = arguments.length - 2) > 0) for (var e = new Array(s), n = 0, s, a; n < s; ++n) e[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    for (a = this._[i], n = 0, s = a.length; n < s; ++n) a[n].value.apply(t, e);
  },
  apply: function(i, t, e) {
    if (!this._.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    for (var n = this._[i], s = 0, a = n.length; s < a; ++s) n[s].value.apply(t, e);
  }
};
function Zg(i, t) {
  for (var e = 0, n = i.length, s; e < n; ++e)
    if ((s = i[e]).name === t)
      return s.value;
}
function Gr(i, t, e) {
  for (var n = 0, s = i.length; n < s; ++n)
    if (i[n].name === t) {
      i[n] = Xg, i = i.slice(0, n).concat(i.slice(n + 1));
      break;
    }
  return e != null && i.push({ name: t, value: e }), i;
}
const qg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispatch: Ko
}, Symbol.toStringTag, { value: "Module" })), jg = /* @__PURE__ */ Wg(qg);
var ui, Hr;
function Kg() {
  if (Hr) return ui;
  Hr = 1;
  const i = jg.dispatch, t = Math.PI / 180, e = {
    archimedean: g,
    rectangular: m
  }, n = 64, s = 2048;
  ui = function() {
    var E = [256, 256], x = a, b = r, k = c, _ = o, G = o, R = l, A = h, H = g, N = [], M = 1 / 0, L = i("word", "end"), P = null, $ = Math.random, C = {}, V = S;
    C.canvas = function(F) {
      return arguments.length ? (V = y(F), C) : V;
    }, C.start = function() {
      var F = q(V()), Z = v((E[0] >> 5) * E[1]), rt = null, j = N.length, Y = -1, K = [], ot = N.map(function(st, it) {
        return st.text = x.call(this, st, it), st.font = b.call(this, st, it), st.style = _.call(this, st, it), st.weight = G.call(this, st, it), st.rotate = R.call(this, st, it), st.size = ~~k.call(this, st, it), st.padding = A.call(this, st, it), st;
      }).sort(function(st, it) {
        return it.size - st.size;
      });
      return P && clearInterval(P), P = setInterval(ct, 0), ct(), C;
      function ct() {
        for (var st = Date.now(); Date.now() - st < M && ++Y < j && P; ) {
          var it = ot[Y];
          it.x = E[0] * ($() + 0.5) >> 1, it.y = E[1] * ($() + 0.5) >> 1, d(F, it, ot, Y), it.hasText && X(Z, it, rt) && (K.push(it), L.call("word", C, it), rt ? p(rt, it) : rt = [{ x: it.x + it.x0, y: it.y + it.y0 }, { x: it.x + it.x1, y: it.y + it.y1 }], it.x -= E[0] >> 1, it.y -= E[1] >> 1);
        }
        Y >= j && (C.stop(), L.call("end", C, K, rt));
      }
    }, C.stop = function() {
      P && (clearInterval(P), P = null);
      for (const F of N)
        delete F.sprite;
      return C;
    };
    function q(F) {
      const Z = F.getContext("2d", { willReadFrequently: !0 });
      F.width = F.height = 1;
      const rt = Math.sqrt(Z.getImageData(0, 0, 1, 1).data.length >> 2);
      return F.width = (n << 5) / rt, F.height = s / rt, Z.fillStyle = Z.strokeStyle = "red", { context: Z, ratio: rt };
    }
    function X(F, Z, rt) {
      E[0], E[1];
      for (var j = Z.x, Y = Z.y, K = Math.sqrt(E[0] * E[0] + E[1] * E[1]), ot = H(E), ct = $() < 0.5 ? 1 : -1, st = -ct, it, z, B; (it = ot(st += ct)) && (z = ~~it[0], B = ~~it[1], !(Math.min(Math.abs(z), Math.abs(B)) >= K)); )
        if (Z.x = j + z, Z.y = Y + B, !(Z.x + Z.x0 < 0 || Z.y + Z.y0 < 0 || Z.x + Z.x1 > E[0] || Z.y + Z.y1 > E[1]) && (!rt || f(Z, rt)) && !u(Z, F, E[0])) {
          for (var U = Z.sprite, wt = Z.width >> 5, be = E[0] >> 5, et = Z.x - (wt << 4), yt = et & 127, Zt = 32 - yt, Wt = Z.y1 - Z.y0, on = (Z.y + Z.y0) * be + (et >> 5), ln, Le = 0; Le < Wt; Le++) {
            ln = 0;
            for (var ne = 0; ne <= wt; ne++)
              F[on + ne] |= ln << Zt | (ne < wt ? (ln = U[Le * wt + ne]) >>> yt : 0);
            on += be;
          }
          return !0;
        }
      return !1;
    }
    return C.timeInterval = function(F) {
      return arguments.length ? (M = F ?? 1 / 0, C) : M;
    }, C.words = function(F) {
      return arguments.length ? (N = F, C) : N;
    }, C.size = function(F) {
      return arguments.length ? (E = [+F[0], +F[1]], C) : E;
    }, C.font = function(F) {
      return arguments.length ? (b = y(F), C) : b;
    }, C.fontStyle = function(F) {
      return arguments.length ? (_ = y(F), C) : _;
    }, C.fontWeight = function(F) {
      return arguments.length ? (G = y(F), C) : G;
    }, C.rotate = function(F) {
      return arguments.length ? (R = y(F), C) : R;
    }, C.text = function(F) {
      return arguments.length ? (x = y(F), C) : x;
    }, C.spiral = function(F) {
      return arguments.length ? (H = e[F] || F, C) : H;
    }, C.fontSize = function(F) {
      return arguments.length ? (k = y(F), C) : k;
    }, C.padding = function(F) {
      return arguments.length ? (A = y(F), C) : A;
    }, C.random = function(F) {
      return arguments.length ? ($ = F, C) : $;
    }, C.on = function() {
      var F = L.on.apply(L, arguments);
      return F === L ? C : F;
    }, C;
  };
  function a(E) {
    return E.text;
  }
  function r() {
    return "serif";
  }
  function o() {
    return "normal";
  }
  function c(E) {
    return Math.sqrt(E.value);
  }
  function l() {
    return (~~(random() * 6) - 3) * 30;
  }
  function h() {
    return 1;
  }
  function d(E, x, b, k) {
    if (!x.sprite) {
      var _ = E.context, G = E.ratio;
      _.clearRect(0, 0, (n << 5) / G, s / G);
      var R = 0, A = 0, H = 0, N = b.length;
      for (--k; ++k < N; ) {
        x = b[k], _.save(), _.font = x.style + " " + x.weight + " " + ~~((x.size + 1) / G) + "px " + x.font;
        const it = _.measureText(x.text), z = -Math.floor(it.width / 2);
        let B = (it.width + 1) * G, U = x.size << 1;
        if (x.rotate) {
          var M = Math.sin(x.rotate * t), L = Math.cos(x.rotate * t), P = B * L, $ = B * M, C = U * L, V = U * M;
          B = Math.max(Math.abs(P + V), Math.abs(P - V)) + 31 >> 5 << 5, U = ~~Math.max(Math.abs($ + C), Math.abs($ - C));
        } else
          B = B + 31 >> 5 << 5;
        if (U > H && (H = U), R + B >= n << 5 && (R = 0, A += H, H = 0), A + U >= s) break;
        _.translate((R + (B >> 1)) / G, (A + (U >> 1)) / G), x.rotate && _.rotate(x.rotate * t), _.fillText(x.text, z, 0), x.padding && (_.lineWidth = 2 * x.padding, _.strokeText(x.text, z, 0)), _.restore(), x.width = B, x.height = U, x.xoff = R, x.yoff = A, x.x1 = B >> 1, x.y1 = U >> 1, x.x0 = -x.x1, x.y0 = -x.y1, x.hasText = !0, R += B;
      }
      for (var q = _.getImageData(0, 0, (n << 5) / G, s / G).data, X = []; --k >= 0; )
        if (x = b[k], !!x.hasText) {
          for (var F = x.width, Z = F >> 5, rt = x.y1 - x.y0, j = 0; j < rt * Z; j++) X[j] = 0;
          if (R = x.xoff, R == null) return;
          A = x.yoff;
          for (var Y = 0, K = -1, ot = 0; ot < rt; ot++) {
            for (var j = 0; j < F; j++) {
              var ct = Z * ot + (j >> 5), st = q[(A + ot) * (n << 5) + (R + j) << 2] ? 1 << 31 - j % 32 : 0;
              X[ct] |= st, Y |= st;
            }
            Y ? K = ot : (x.y0++, rt--, ot--, A++);
          }
          x.y1 = x.y0 + K, x.sprite = X.slice(0, (x.y1 - x.y0) * Z);
        }
    }
  }
  function u(E, x, b) {
    b >>= 5;
    for (var k = E.sprite, _ = E.width >> 5, G = E.x - (_ << 4), R = G & 127, A = 32 - R, H = E.y1 - E.y0, N = (E.y + E.y0) * b + (G >> 5), M, L = 0; L < H; L++) {
      M = 0;
      for (var P = 0; P <= _; P++)
        if ((M << A | (P < _ ? (M = k[L * _ + P]) >>> R : 0)) & x[N + P]) return !0;
      N += b;
    }
    return !1;
  }
  function p(E, x) {
    var b = E[0], k = E[1];
    x.x + x.x0 < b.x && (b.x = x.x + x.x0), x.y + x.y0 < b.y && (b.y = x.y + x.y0), x.x + x.x1 > k.x && (k.x = x.x + x.x1), x.y + x.y1 > k.y && (k.y = x.y + x.y1);
  }
  function f(E, x) {
    return E.x + E.x1 > x[0].x && E.x + E.x0 < x[1].x && E.y + E.y1 > x[0].y && E.y + E.y0 < x[1].y;
  }
  function g(E) {
    var x = E[0] / E[1];
    return function(b) {
      return [x * (b *= 0.1) * Math.cos(b), b * Math.sin(b)];
    };
  }
  function m(E) {
    var x = 4, b = x * E[0] / E[1], k = 0, _ = 0;
    return function(G) {
      var R = G < 0 ? -1 : 1;
      switch (Math.sqrt(1 + 4 * R * G) - R & 3) {
        case 0:
          k += b;
          break;
        case 1:
          _ += x;
          break;
        case 2:
          k -= b;
          break;
        default:
          _ -= x;
          break;
      }
      return [k, _];
    };
  }
  function v(E) {
    for (var x = [], b = -1; ++b < E; ) x[b] = 0;
    return x;
  }
  function S() {
    return document.createElement("canvas");
  }
  function y(E) {
    return typeof E == "function" ? E : function() {
      return E;
    };
  }
  return ui;
}
var Jg = Kg();
const Qg = /* @__PURE__ */ Fg(Jg);
class Jm extends dt {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = at.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (s) => s[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(T.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(T.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer({
      ariaLabel: "word cloud"
    }).attr("width", "100%").attr("height", "100%"), s = this.model.getDisplayData(), a = this.getFontSizeScale(s), r = this.getOptions(), { fontSizeMapsTo: o, wordMapsTo: c } = r.wordCloud, { groupMapsTo: l } = r.data, { width: h, height: d } = I.getSVGElementSize(n, {
      useAttrs: !0
    });
    if (h === 0 || d === 0)
      return;
    const u = Qg().size([h, d]).words(
      s.map(function(f) {
        const g = f[o];
        if (typeof f[o] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [l]: f[l],
          text: f[c],
          size: g,
          value: g
        };
      })
    ).padding(5).rotate(0).fontSize((f) => a(f.size)).on("end", p);
    u.start();
    function p(f) {
      const g = I.appendOrSelect(n, "g.words");
      g.attr("transform", `translate(${u.size()[0] / 2}, ${u.size()[1] / 2})`);
      const m = g.selectAll("text").data(f, (S) => `${S[l]}-${S.text}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("text").attr("opacity", 0).merge(m).style("font-size", (S) => `${S.size}px`).text(function(S) {
        return S.text;
      }).attr(
        "class",
        (S) => e.model.getColorClassName({
          classNameTypes: [nt.FILL],
          dataGroupName: S[l],
          originalClassName: `word ${S.size > 32 ? "light" : ""}`
        })
      ).style("fill", (S) => e.model.getFillColor(S[l], S.text, S)).attr("text-anchor", "middle").transition().call(
        (S) => e.services.transitions.setupTransition({
          transition: S,
          name: "wordcloud-text-update-enter",
          animate: t
        })
      ).attr("transform", (S) => `translate(${S.x}, ${S.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(t) {
    const e = this.getOptions(), { fontSizeMapsTo: n } = e.wordCloud, s = t.map((c) => c[n]).filter((c) => c), a = I.getHTMLElementSize(this.services.domUtils.getMainContainer()), r = s.length > 0, o = r ? Os(s) : [1, 1];
    return Re().domain(o).range(r ? e.wordCloud.fontSizeRange(a, t) : [4, 4]);
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this, s = fi((a) => {
      const r = n.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (o) => n.services.transitions.setupTransition({
          transition: o,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      a === null ? r.attr("opacity", 1) : r.attr("opacity", function() {
        return a === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(a, r) {
      const o = this;
      s(o), n.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEOVER, {
        event: a,
        element: D(this),
        datum: r
      }), n.services.events.dispatchEvent(T.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        items: [
          {
            label: t.tooltip.wordLabel,
            value: r.text
          },
          {
            label: t.tooltip.valueLabel,
            value: r.value
          },
          {
            label: xt(t, "locale.translations.group") || xt(t, "tooltip.groupLabel") || "Group",
            value: r[e],
            class: n.model.getColorClassName({
              classNameTypes: [nt.TOOLTIP],
              dataGroupName: r[e]
            })
          }
        ]
      });
    }).on("mousemove", function(a, r) {
      const o = D(this);
      n.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEMOVE, {
        element: o,
        datum: r
      }), n.services.events.dispatchEvent(T.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, r) {
      n.services.events.dispatchEvent(T.WordCloud.WORD_CLICK, {
        event: a,
        element: D(this),
        datum: r
      });
    }).on("mouseout", function(a, r) {
      const o = D(this);
      s(null), n.services.events.dispatchEvent(T.WordCloud.WORD_MOUSEOUT, {
        event: a,
        element: o,
        datum: r
      }), n.services.events.dispatchEvent(T.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class tm extends dt {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = at.SVG;
  }
  render() {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: e, height: n } = I.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (e < 1 || n < 1)
      return;
    const s = this.getProjection(), a = O(this.getOptions(), "geoData"), r = this.model.getCombinedData(), o = {}, c = {};
    Object.keys(r).forEach((v) => {
      typeof r[v].value == "number" ? o[v] = r[v] : c[v] = r[v];
    });
    const l = hp(a, Object.values(c)), h = lp(a, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(o)
    }), d = s.fitSize([e, n], h), u = Au().projection(d);
    I.appendOrSelect(t, "g.geo").selectAll("path").data(h.features).join("path").attr("d", u);
    const f = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), g = I.appendOrSelect(t, "defs");
    I.appendOrSelect(g, "pattern").attr("id", f).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      Nn()([
        [0, 0],
        [0, 10]
      ])
    );
    const m = I.appendOrSelect(t, "g.missing-data");
    I.appendOrSelect(m, "path").datum(l).attr("d", u).style("fill", `url(#${f})`);
  }
  /**
   * Retrieves the D3 geographic projection based on the options provided.
   *
   * This method selects a geographic projection from the available D3 projections
   * based on the `projection` property in the `thematic` options. If the projection
   * is not supported or is missing, an error is thrown.
   *
   * @returns {d3.GeoProjection} - The D3 geographic projection corresponding to the selected option.
   * @throws {Error} If the projection is not supported or is missing.
   */
  getProjection() {
    let t = null;
    switch (O(this.getOptions(), "thematic", "projection")) {
      // Azimuthal Projections
      case we.geoEqualEarth:
        t = Wu();
        break;
      // Conic Projections
      case we.geoAlbers:
        t = Vu();
        break;
      case we.geoConicEqualArea:
        t = Do();
        break;
      case we.geoConicEquidistant:
        t = Uu();
        break;
      // Cyndrical projections
      case we.geoEquirectangular:
        t = Bu();
        break;
      case we.geoMercator:
        t = Gu();
        break;
      case we.geoNaturalEarth1:
        t = Xu();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return t;
  }
}
class Qm extends tm {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    super.render();
    const e = this.model.getCombinedData(), n = this.getComponentContainer({ ariaLabel: "map", withinChartClip: !0 }), s = O(this.getOptions(), "color"), a = O(s, "gradient", "colors");
    n.select("g.geo").selectAll("path").classed("border", !0).attr("class", (o) => this.model.getColorClassName({
      value: e[o.properties.NAME].value,
      originalClassName: "border"
    })).attr("style", (o) => a ? `fill: ${this.model.getColorClassName({
      value: e[o.properties.NAME].value
    })}` : null), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const t = this, e = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(Un.CHOROPLETH_MOUSEOVER, {
        event: n,
        element: a,
        datum: e[s.properties.NAME]
      }), t.services.events.dispatchEvent(zs.SHOW, {
        event: n,
        hoveredElement: a,
        items: [
          {
            label: s.properties.NAME,
            value: e[s.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(n, s) {
      t.services.events.dispatchEvent(Un.CHOROPLETH_MOUSEMOVE, {
        event: n,
        element: D(this),
        datum: e[s.properties.NAME]
      }), t.services.events.dispatchEvent(zs.MOVE, {
        event: n
      });
    }).on("click", function(n, s) {
      t.services.events.dispatchEvent(Un.CHOROPLETH_CLICK, {
        event: n,
        element: D(this),
        datum: e[s.properties.NAME]
      });
    }).on("mouseout", function(n, s) {
      const a = D(this);
      t.services.events.dispatchEvent(Un.CHOROPLETH_MOUSEOUT, {
        event: n,
        element: a,
        datum: e[s.properties.NAME]
      }), t.services.events.dispatchEvent(zs.HIDE, {
        event: n,
        hoveredElement: a
      });
    });
  }
}
export {
  Cm as $,
  pm as A,
  Em as B,
  cm as C,
  $m as D,
  Hm as E,
  Tm as F,
  gm as G,
  dm as H,
  Bm as I,
  Xm as J,
  zm as K,
  Dd as L,
  lm as M,
  Nm as N,
  Um as O,
  fp as P,
  Fm as Q,
  qo as R,
  om as S,
  Rd as T,
  jm as U,
  Km as V,
  Jm as W,
  jo as X,
  sp as Y,
  um as Z,
  wm as _,
  br as a,
  Mm as a0,
  Am as a1,
  Lm as a2,
  km as a3,
  _m as a4,
  Im as a5,
  Rm as a6,
  tm as a7,
  ea as a8,
  dt as a9,
  Tr as b,
  yc as c,
  Pd as d,
  Nd as e,
  Ar as f,
  hm as g,
  fm as h,
  ym as i,
  vm as j,
  mm as k,
  Qi as l,
  ip as m,
  xm as n,
  Sm as o,
  bm as p,
  Dm as q,
  Qm as r,
  Pm as s,
  Zm as t,
  Om as u,
  Gm as v,
  Wm as w,
  Ym as x,
  qm as y,
  Vm as z
};
//# sourceMappingURL=choropleth-DvuP75LI.mjs.map
